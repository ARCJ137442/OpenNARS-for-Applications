pub const __builtin_bswap16 = @import("std").zig.c_builtins.__builtin_bswap16;
pub const __builtin_bswap32 = @import("std").zig.c_builtins.__builtin_bswap32;
pub const __builtin_bswap64 = @import("std").zig.c_builtins.__builtin_bswap64;
pub const __builtin_signbit = @import("std").zig.c_builtins.__builtin_signbit;
pub const __builtin_signbitf = @import("std").zig.c_builtins.__builtin_signbitf;
pub const __builtin_popcount = @import("std").zig.c_builtins.__builtin_popcount;
pub const __builtin_ctz = @import("std").zig.c_builtins.__builtin_ctz;
pub const __builtin_clz = @import("std").zig.c_builtins.__builtin_clz;
pub const __builtin_sqrt = @import("std").zig.c_builtins.__builtin_sqrt;
pub const __builtin_sqrtf = @import("std").zig.c_builtins.__builtin_sqrtf;
pub const __builtin_sin = @import("std").zig.c_builtins.__builtin_sin;
pub const __builtin_sinf = @import("std").zig.c_builtins.__builtin_sinf;
pub const __builtin_cos = @import("std").zig.c_builtins.__builtin_cos;
pub const __builtin_cosf = @import("std").zig.c_builtins.__builtin_cosf;
pub const __builtin_exp = @import("std").zig.c_builtins.__builtin_exp;
pub const __builtin_expf = @import("std").zig.c_builtins.__builtin_expf;
pub const __builtin_exp2 = @import("std").zig.c_builtins.__builtin_exp2;
pub const __builtin_exp2f = @import("std").zig.c_builtins.__builtin_exp2f;
pub const __builtin_log = @import("std").zig.c_builtins.__builtin_log;
pub const __builtin_logf = @import("std").zig.c_builtins.__builtin_logf;
pub const __builtin_log2 = @import("std").zig.c_builtins.__builtin_log2;
pub const __builtin_log2f = @import("std").zig.c_builtins.__builtin_log2f;
pub const __builtin_log10 = @import("std").zig.c_builtins.__builtin_log10;
pub const __builtin_log10f = @import("std").zig.c_builtins.__builtin_log10f;
pub const __builtin_abs = @import("std").zig.c_builtins.__builtin_abs;
pub const __builtin_labs = @import("std").zig.c_builtins.__builtin_labs;
pub const __builtin_llabs = @import("std").zig.c_builtins.__builtin_llabs;
pub const __builtin_fabs = @import("std").zig.c_builtins.__builtin_fabs;
pub const __builtin_fabsf = @import("std").zig.c_builtins.__builtin_fabsf;
pub const __builtin_floor = @import("std").zig.c_builtins.__builtin_floor;
pub const __builtin_floorf = @import("std").zig.c_builtins.__builtin_floorf;
pub const __builtin_ceil = @import("std").zig.c_builtins.__builtin_ceil;
pub const __builtin_ceilf = @import("std").zig.c_builtins.__builtin_ceilf;
pub const __builtin_trunc = @import("std").zig.c_builtins.__builtin_trunc;
pub const __builtin_truncf = @import("std").zig.c_builtins.__builtin_truncf;
pub const __builtin_round = @import("std").zig.c_builtins.__builtin_round;
pub const __builtin_roundf = @import("std").zig.c_builtins.__builtin_roundf;
pub const __builtin_strlen = @import("std").zig.c_builtins.__builtin_strlen;
pub const __builtin_strcmp = @import("std").zig.c_builtins.__builtin_strcmp;
pub const __builtin_object_size = @import("std").zig.c_builtins.__builtin_object_size;
pub const __builtin___memset_chk = @import("std").zig.c_builtins.__builtin___memset_chk;
pub const __builtin_memset = @import("std").zig.c_builtins.__builtin_memset;
pub const __builtin___memcpy_chk = @import("std").zig.c_builtins.__builtin___memcpy_chk;
pub const __builtin_memcpy = @import("std").zig.c_builtins.__builtin_memcpy;
pub const __builtin_expect = @import("std").zig.c_builtins.__builtin_expect;
pub const __builtin_nanf = @import("std").zig.c_builtins.__builtin_nanf;
pub const __builtin_huge_valf = @import("std").zig.c_builtins.__builtin_huge_valf;
pub const __builtin_inff = @import("std").zig.c_builtins.__builtin_inff;
pub const __builtin_isnan = @import("std").zig.c_builtins.__builtin_isnan;
pub const __builtin_isinf = @import("std").zig.c_builtins.__builtin_isinf;
pub const __builtin_isinf_sign = @import("std").zig.c_builtins.__builtin_isinf_sign;
pub const __has_builtin = @import("std").zig.c_builtins.__has_builtin;
pub const __builtin_assume = @import("std").zig.c_builtins.__builtin_assume;
pub const __builtin_unreachable = @import("std").zig.c_builtins.__builtin_unreachable;
pub const __builtin_constant_p = @import("std").zig.c_builtins.__builtin_constant_p;
pub const __builtin_mul_overflow = @import("std").zig.c_builtins.__builtin_mul_overflow;
pub const __builtin_va_list = [*c]u8;
pub const __gnuc_va_list = __builtin_va_list;
pub const va_list = __gnuc_va_list;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:584:3: warning: TODO implement translation of stmt class GCCAsmStmtClass

// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:581:36: warning: unable to translate function, demoted to extern
pub extern fn __debugbreak() void;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:605:3: warning: TODO implement translation of stmt class GCCAsmStmtClass

// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:602:60: warning: unable to translate function, demoted to extern
pub extern fn __fastfail(arg_code: c_uint) noreturn;
pub extern fn __mingw_get_crt_info() [*c]const u8;
pub const rsize_t = usize;
pub const ptrdiff_t = c_longlong;
pub const wchar_t = c_ushort;
pub const wint_t = c_ushort;
pub const wctype_t = c_ushort;
pub const errno_t = c_int;
pub const __time32_t = c_long;
pub const __time64_t = c_longlong;
pub const time_t = __time64_t;
pub const struct_threadlocaleinfostruct = extern struct {
    _locale_pctype: [*c]const c_ushort = @import("std").mem.zeroes([*c]const c_ushort),
    _locale_mb_cur_max: c_int = @import("std").mem.zeroes(c_int),
    _locale_lc_codepage: c_uint = @import("std").mem.zeroes(c_uint),
};
pub const struct_threadmbcinfostruct = opaque {};
pub const pthreadlocinfo = [*c]struct_threadlocaleinfostruct;
pub const pthreadmbcinfo = ?*struct_threadmbcinfostruct;
pub const struct___lc_time_data = opaque {};
pub const struct_localeinfo_struct = extern struct {
    locinfo: pthreadlocinfo = @import("std").mem.zeroes(pthreadlocinfo),
    mbcinfo: pthreadmbcinfo = @import("std").mem.zeroes(pthreadmbcinfo),
};
pub const _locale_tstruct = struct_localeinfo_struct;
pub const _locale_t = [*c]struct_localeinfo_struct;
pub const struct_tagLC_ID = extern struct {
    wLanguage: c_ushort = @import("std").mem.zeroes(c_ushort),
    wCountry: c_ushort = @import("std").mem.zeroes(c_ushort),
    wCodePage: c_ushort = @import("std").mem.zeroes(c_ushort),
};
pub const LC_ID = struct_tagLC_ID;
pub const LPLC_ID = [*c]struct_tagLC_ID;
pub const threadlocinfo = struct_threadlocaleinfostruct;
pub const struct___timeb32 = extern struct {
    time: __time32_t = @import("std").mem.zeroes(__time32_t),
    millitm: c_ushort = @import("std").mem.zeroes(c_ushort),
    timezone: c_short = @import("std").mem.zeroes(c_short),
    dstflag: c_short = @import("std").mem.zeroes(c_short),
};
pub const struct_timeb = extern struct {
    time: time_t = @import("std").mem.zeroes(time_t),
    millitm: c_ushort = @import("std").mem.zeroes(c_ushort),
    timezone: c_short = @import("std").mem.zeroes(c_short),
    dstflag: c_short = @import("std").mem.zeroes(c_short),
};
pub const struct___timeb64 = extern struct {
    time: __time64_t = @import("std").mem.zeroes(__time64_t),
    millitm: c_ushort = @import("std").mem.zeroes(c_ushort),
    timezone: c_short = @import("std").mem.zeroes(c_short),
    dstflag: c_short = @import("std").mem.zeroes(c_short),
};
pub extern fn _ftime64(_Time: [*c]struct___timeb64) void;
pub extern fn _ftime32(_Time: [*c]struct___timeb32) void;
pub const struct__timespec32 = extern struct {
    tv_sec: __time32_t = @import("std").mem.zeroes(__time32_t),
    tv_nsec: c_long = @import("std").mem.zeroes(c_long),
};
pub const struct__timespec64 = extern struct {
    tv_sec: __time64_t = @import("std").mem.zeroes(__time64_t),
    tv_nsec: c_long = @import("std").mem.zeroes(c_long),
};
pub const struct_timespec = extern struct {
    tv_sec: time_t = @import("std").mem.zeroes(time_t),
    tv_nsec: c_long = @import("std").mem.zeroes(c_long),
};
pub const struct_itimerspec = extern struct {
    it_interval: struct_timespec = @import("std").mem.zeroes(struct_timespec),
    it_value: struct_timespec = @import("std").mem.zeroes(struct_timespec),
};
pub extern fn ftime([*c]struct_timeb) void;
pub extern fn _ftime32_s(_Time: [*c]struct___timeb32) errno_t;
pub extern fn _ftime64_s(_Time: [*c]struct___timeb64) errno_t;
pub const clock_t = c_long;
pub const struct_tm = extern struct {
    tm_sec: c_int = @import("std").mem.zeroes(c_int),
    tm_min: c_int = @import("std").mem.zeroes(c_int),
    tm_hour: c_int = @import("std").mem.zeroes(c_int),
    tm_mday: c_int = @import("std").mem.zeroes(c_int),
    tm_mon: c_int = @import("std").mem.zeroes(c_int),
    tm_year: c_int = @import("std").mem.zeroes(c_int),
    tm_wday: c_int = @import("std").mem.zeroes(c_int),
    tm_yday: c_int = @import("std").mem.zeroes(c_int),
    tm_isdst: c_int = @import("std").mem.zeroes(c_int),
};
pub extern fn __daylight() [*c]c_int;
pub extern fn __dstbias() [*c]c_long;
pub extern fn __timezone() [*c]c_long;
pub extern fn __tzname() [*c][*c]u8;
pub extern fn _get_daylight(_Daylight: [*c]c_int) errno_t;
pub extern fn _get_dstbias(_Daylight_savings_bias: [*c]c_long) errno_t;
pub extern fn _get_timezone(_Timezone: [*c]c_long) errno_t;
pub extern fn _get_tzname(_ReturnValue: [*c]usize, _Buffer: [*c]u8, _SizeInBytes: usize, _Index: c_int) errno_t;
pub extern fn asctime(_Tm: [*c]const struct_tm) [*c]u8;
pub extern fn asctime_s(_Buf: [*c]u8, _SizeInWords: usize, _Tm: [*c]const struct_tm) errno_t;
pub extern fn _ctime32(_Time: [*c]const __time32_t) [*c]u8;
pub extern fn _ctime32_s(_Buf: [*c]u8, _SizeInBytes: usize, _Time: [*c]const __time32_t) errno_t;
pub extern fn clock() clock_t;
pub extern fn _difftime32(_Time1: __time32_t, _Time2: __time32_t) f64;
pub extern fn _gmtime32(_Time: [*c]const __time32_t) [*c]struct_tm;
pub extern fn _gmtime32_s(_Tm: [*c]struct_tm, _Time: [*c]const __time32_t) errno_t;
pub extern fn _localtime32(_Time: [*c]const __time32_t) [*c]struct_tm;
pub extern fn _localtime32_s(_Tm: [*c]struct_tm, _Time: [*c]const __time32_t) errno_t;
pub extern fn strftime(noalias _Buf: [*c]u8, _SizeInBytes: usize, noalias _Format: [*c]const u8, noalias _Tm: [*c]const struct_tm) usize;
pub extern fn _strftime_l(noalias _Buf: [*c]u8, _Max_size: usize, noalias _Format: [*c]const u8, noalias _Tm: [*c]const struct_tm, _Locale: _locale_t) usize;
pub extern fn _strdate(_Buffer: [*c]u8) [*c]u8;
pub extern fn _strdate_s(_Buf: [*c]u8, _SizeInBytes: usize) errno_t;
pub extern fn _strtime(_Buffer: [*c]u8) [*c]u8;
pub extern fn _strtime_s(_Buf: [*c]u8, _SizeInBytes: usize) errno_t;
pub extern fn _time32(_Time: [*c]__time32_t) __time32_t;
pub extern fn _timespec32_get(_Ts: [*c]struct__timespec32, _Base: c_int) c_int;
pub extern fn _mktime32(_Tm: [*c]struct_tm) __time32_t;
pub extern fn _mkgmtime32(_Tm: [*c]struct_tm) __time32_t;
pub extern fn tzset() void;
pub extern fn _tzset() void;
pub extern fn _difftime64(_Time1: __time64_t, _Time2: __time64_t) f64;
pub extern fn _ctime64(_Time: [*c]const __time64_t) [*c]u8;
pub extern fn _ctime64_s(_Buf: [*c]u8, _SizeInBytes: usize, _Time: [*c]const __time64_t) errno_t;
pub extern fn _gmtime64(_Time: [*c]const __time64_t) [*c]struct_tm;
pub extern fn _gmtime64_s(_Tm: [*c]struct_tm, _Time: [*c]const __time64_t) errno_t;
pub extern fn _localtime64(_Time: [*c]const __time64_t) [*c]struct_tm;
pub extern fn _localtime64_s(_Tm: [*c]struct_tm, _Time: [*c]const __time64_t) errno_t;
pub extern fn _mktime64(_Tm: [*c]struct_tm) __time64_t;
pub extern fn _mkgmtime64(_Tm: [*c]struct_tm) __time64_t;
pub extern fn _time64(_Time: [*c]__time64_t) __time64_t;
pub extern fn _timespec64_get(_Ts: [*c]struct__timespec64, _Base: c_int) c_int;
pub extern fn _getsystime(_Tm: [*c]struct_tm) c_uint;
pub extern fn _setsystime(_Tm: [*c]struct_tm, _MilliSec: c_uint) c_uint;
pub extern fn _wasctime(_Tm: [*c]const struct_tm) [*c]wchar_t;
pub extern fn _wasctime_s(_Buf: [*c]wchar_t, _SizeInWords: usize, _Tm: [*c]const struct_tm) errno_t;
pub extern fn _wctime32(_Time: [*c]const __time32_t) [*c]wchar_t;
pub extern fn _wctime32_s(_Buf: [*c]wchar_t, _SizeInWords: usize, _Time: [*c]const __time32_t) errno_t;
pub extern fn wcsftime(noalias _Buf: [*c]wchar_t, _SizeInWords: usize, noalias _Format: [*c]const wchar_t, noalias _Tm: [*c]const struct_tm) usize;
pub extern fn _wcsftime_l(noalias _Buf: [*c]wchar_t, _SizeInWords: usize, noalias _Format: [*c]const wchar_t, noalias _Tm: [*c]const struct_tm, _Locale: _locale_t) usize;
pub extern fn _wstrdate(_Buffer: [*c]wchar_t) [*c]wchar_t;
pub extern fn _wstrdate_s(_Buf: [*c]wchar_t, _SizeInWords: usize) errno_t;
pub extern fn _wstrtime(_Buffer: [*c]wchar_t) [*c]wchar_t;
pub extern fn _wstrtime_s(_Buf: [*c]wchar_t, _SizeInWords: usize) errno_t;
pub extern fn _wctime64(_Time: [*c]const __time64_t) [*c]wchar_t;
pub extern fn _wctime64_s(_Buf: [*c]wchar_t, _SizeInWords: usize, _Time: [*c]const __time64_t) errno_t;
pub extern fn _wctime([*c]const time_t) [*c]wchar_t;
pub extern fn _wctime_s([*c]wchar_t, usize, [*c]const time_t) errno_t;
pub fn time(arg__Time: [*c]time_t) callconv(.C) time_t {
    var _Time = arg__Time;
    _ = &_Time;
    return _time64(_Time);
}
pub fn timespec_get(arg__Ts: [*c]struct_timespec, arg__Base: c_int) callconv(.C) c_int {
    var _Ts = arg__Ts;
    _ = &_Ts;
    var _Base = arg__Base;
    _ = &_Base;
    return _timespec64_get(@as([*c]struct__timespec64, @ptrCast(@alignCast(_Ts))), _Base);
}
pub fn difftime(arg__Time1: time_t, arg__Time2: time_t) callconv(.C) f64 {
    var _Time1 = arg__Time1;
    _ = &_Time1;
    var _Time2 = arg__Time2;
    _ = &_Time2;
    return _difftime64(_Time1, _Time2);
}
pub fn localtime(arg__Time: [*c]const time_t) callconv(.C) [*c]struct_tm {
    var _Time = arg__Time;
    _ = &_Time;
    return _localtime64(_Time);
}
pub fn localtime_s(arg__Tm: [*c]struct_tm, arg__Time: [*c]const time_t) callconv(.C) errno_t {
    var _Tm = arg__Tm;
    _ = &_Tm;
    var _Time = arg__Time;
    _ = &_Time;
    return _localtime64_s(_Tm, _Time);
}
pub fn gmtime(arg__Time: [*c]const time_t) callconv(.C) [*c]struct_tm {
    var _Time = arg__Time;
    _ = &_Time;
    return _gmtime64(_Time);
}
pub fn gmtime_s(arg__Tm: [*c]struct_tm, arg__Time: [*c]const time_t) callconv(.C) errno_t {
    var _Tm = arg__Tm;
    _ = &_Tm;
    var _Time = arg__Time;
    _ = &_Time;
    return _gmtime64_s(_Tm, _Time);
}
pub fn ctime(arg__Time: [*c]const time_t) callconv(.C) [*c]u8 {
    var _Time = arg__Time;
    _ = &_Time;
    return _ctime64(_Time);
}
pub fn ctime_s(arg__Buf: [*c]u8, arg__SizeInBytes: usize, arg__Time: [*c]const time_t) callconv(.C) errno_t {
    var _Buf = arg__Buf;
    _ = &_Buf;
    var _SizeInBytes = arg__SizeInBytes;
    _ = &_SizeInBytes;
    var _Time = arg__Time;
    _ = &_Time;
    return _ctime64_s(_Buf, _SizeInBytes, _Time);
}
pub fn mktime(arg__Tm: [*c]struct_tm) callconv(.C) time_t {
    var _Tm = arg__Tm;
    _ = &_Tm;
    return _mktime64(_Tm);
}
pub fn _mkgmtime(arg__Tm: [*c]struct_tm) callconv(.C) time_t {
    var _Tm = arg__Tm;
    _ = &_Tm;
    return _mkgmtime64(_Tm);
}
pub extern var daylight: c_int;
pub extern var timezone: c_long;
pub extern var tzname: [2][*c]u8;
pub const struct_timeval = extern struct {
    tv_sec: c_long = @import("std").mem.zeroes(c_long),
    tv_usec: c_long = @import("std").mem.zeroes(c_long),
};
pub const struct_timezone = extern struct {
    tz_minuteswest: c_int = @import("std").mem.zeroes(c_int),
    tz_dsttime: c_int = @import("std").mem.zeroes(c_int),
};
pub extern fn mingw_gettimeofday(p: [*c]struct_timeval, z: [*c]struct_timezone) c_int;
pub extern fn _memccpy(_Dst: ?*anyopaque, _Src: ?*const anyopaque, _Val: c_int, _MaxCount: usize) ?*anyopaque;
pub extern fn memchr(_Buf: ?*const anyopaque, _Val: c_int, _MaxCount: c_ulonglong) ?*anyopaque;
pub extern fn _memicmp(_Buf1: ?*const anyopaque, _Buf2: ?*const anyopaque, _Size: usize) c_int;
pub extern fn _memicmp_l(_Buf1: ?*const anyopaque, _Buf2: ?*const anyopaque, _Size: usize, _Locale: _locale_t) c_int;
pub extern fn memcmp(_Buf1: ?*const anyopaque, _Buf2: ?*const anyopaque, _Size: c_ulonglong) c_int;
pub extern fn memcpy(_Dst: ?*anyopaque, _Src: ?*const anyopaque, _Size: c_ulonglong) ?*anyopaque;
pub extern fn memcpy_s(_dest: ?*anyopaque, _numberOfElements: usize, _src: ?*const anyopaque, _count: usize) errno_t;
pub extern fn mempcpy(_Dst: ?*anyopaque, _Src: ?*const anyopaque, _Size: c_ulonglong) ?*anyopaque;
pub extern fn memset(_Dst: ?*anyopaque, _Val: c_int, _Size: c_ulonglong) ?*anyopaque;
pub extern fn memccpy(_Dst: ?*anyopaque, _Src: ?*const anyopaque, _Val: c_int, _Size: c_ulonglong) ?*anyopaque;
pub extern fn memicmp(_Buf1: ?*const anyopaque, _Buf2: ?*const anyopaque, _Size: usize) c_int;
pub extern fn _strset(_Str: [*c]u8, _Val: c_int) [*c]u8;
pub extern fn _strset_l(_Str: [*c]u8, _Val: c_int, _Locale: _locale_t) [*c]u8;
pub extern fn strcpy(_Dest: [*c]u8, _Source: [*c]const u8) [*c]u8;
pub extern fn strcat(_Dest: [*c]u8, _Source: [*c]const u8) [*c]u8;
pub extern fn strcmp(_Str1: [*c]const u8, _Str2: [*c]const u8) c_int;
pub extern fn strlen(_Str: [*c]const u8) c_ulonglong;
pub extern fn strnlen(_Str: [*c]const u8, _MaxCount: usize) usize;
pub extern fn memmove(_Dst: ?*anyopaque, _Src: ?*const anyopaque, _Size: c_ulonglong) ?*anyopaque;
pub extern fn _strdup(_Src: [*c]const u8) [*c]u8;
pub extern fn strchr(_Str: [*c]const u8, _Val: c_int) [*c]u8;
pub extern fn _stricmp(_Str1: [*c]const u8, _Str2: [*c]const u8) c_int;
pub extern fn _strcmpi(_Str1: [*c]const u8, _Str2: [*c]const u8) c_int;
pub extern fn _stricmp_l(_Str1: [*c]const u8, _Str2: [*c]const u8, _Locale: _locale_t) c_int;
pub extern fn strcoll(_Str1: [*c]const u8, _Str2: [*c]const u8) c_int;
pub extern fn _strcoll_l(_Str1: [*c]const u8, _Str2: [*c]const u8, _Locale: _locale_t) c_int;
pub extern fn _stricoll(_Str1: [*c]const u8, _Str2: [*c]const u8) c_int;
pub extern fn _stricoll_l(_Str1: [*c]const u8, _Str2: [*c]const u8, _Locale: _locale_t) c_int;
pub extern fn _strncoll(_Str1: [*c]const u8, _Str2: [*c]const u8, _MaxCount: usize) c_int;
pub extern fn _strncoll_l(_Str1: [*c]const u8, _Str2: [*c]const u8, _MaxCount: usize, _Locale: _locale_t) c_int;
pub extern fn _strnicoll(_Str1: [*c]const u8, _Str2: [*c]const u8, _MaxCount: usize) c_int;
pub extern fn _strnicoll_l(_Str1: [*c]const u8, _Str2: [*c]const u8, _MaxCount: usize, _Locale: _locale_t) c_int;
pub extern fn strcspn(_Str: [*c]const u8, _Control: [*c]const u8) c_ulonglong;
pub extern fn _strerror(_ErrMsg: [*c]const u8) [*c]u8;
pub extern fn strerror(c_int) [*c]u8;
pub extern fn _strlwr(_String: [*c]u8) [*c]u8;
pub extern fn strlwr_l(_String: [*c]u8, _Locale: _locale_t) [*c]u8;
pub extern fn strncat(_Dest: [*c]u8, _Source: [*c]const u8, _Count: c_ulonglong) [*c]u8;
pub extern fn strncmp(_Str1: [*c]const u8, _Str2: [*c]const u8, _MaxCount: c_ulonglong) c_int;
pub extern fn _strnicmp(_Str1: [*c]const u8, _Str2: [*c]const u8, _MaxCount: usize) c_int;
pub extern fn _strnicmp_l(_Str1: [*c]const u8, _Str2: [*c]const u8, _MaxCount: usize, _Locale: _locale_t) c_int;
pub extern fn strncpy(_Dest: [*c]u8, _Source: [*c]const u8, _Count: c_ulonglong) [*c]u8;
pub extern fn _strnset(_Str: [*c]u8, _Val: c_int, _MaxCount: usize) [*c]u8;
pub extern fn _strnset_l(str: [*c]u8, c: c_int, count: usize, _Locale: _locale_t) [*c]u8;
pub extern fn strpbrk(_Str: [*c]const u8, _Control: [*c]const u8) [*c]u8;
pub extern fn strrchr(_Str: [*c]const u8, _Ch: c_int) [*c]u8;
pub extern fn _strrev(_Str: [*c]u8) [*c]u8;
pub extern fn strspn(_Str: [*c]const u8, _Control: [*c]const u8) c_ulonglong;
pub extern fn strstr(_Str: [*c]const u8, _SubStr: [*c]const u8) [*c]u8;
pub extern fn strtok(_Str: [*c]u8, _Delim: [*c]const u8) [*c]u8;
pub extern fn strtok_r(noalias _Str: [*c]u8, noalias _Delim: [*c]const u8, noalias __last: [*c][*c]u8) [*c]u8;
pub extern fn _strupr(_String: [*c]u8) [*c]u8;
pub extern fn _strupr_l(_String: [*c]u8, _Locale: _locale_t) [*c]u8;
pub extern fn strxfrm(_Dst: [*c]u8, _Src: [*c]const u8, _MaxCount: c_ulonglong) c_ulonglong;
pub extern fn _strxfrm_l(noalias _Dst: [*c]u8, noalias _Src: [*c]const u8, _MaxCount: usize, _Locale: _locale_t) usize;
pub extern fn strdup(_Src: [*c]const u8) [*c]u8;
pub extern fn strcmpi(_Str1: [*c]const u8, _Str2: [*c]const u8) c_int;
pub extern fn stricmp(_Str1: [*c]const u8, _Str2: [*c]const u8) c_int;
pub extern fn strlwr(_Str: [*c]u8) [*c]u8;
pub extern fn strnicmp(_Str1: [*c]const u8, _Str: [*c]const u8, _MaxCount: usize) c_int;
pub extern fn strncasecmp([*c]const u8, [*c]const u8, c_ulonglong) c_int;
pub extern fn strcasecmp([*c]const u8, [*c]const u8) c_int;
pub extern fn strnset(_Str: [*c]u8, _Val: c_int, _MaxCount: usize) [*c]u8;
pub extern fn strrev(_Str: [*c]u8) [*c]u8;
pub extern fn strset(_Str: [*c]u8, _Val: c_int) [*c]u8;
pub extern fn strupr(_Str: [*c]u8) [*c]u8;
pub extern fn _wcsdup(_Str: [*c]const wchar_t) [*c]wchar_t;
pub extern fn wcscat(noalias _Dest: [*c]wchar_t, noalias _Source: [*c]const wchar_t) [*c]wchar_t;
pub extern fn wcschr(_Str: [*c]const c_ushort, _Ch: c_ushort) [*c]c_ushort;
pub extern fn wcscmp(_Str1: [*c]const c_ushort, _Str2: [*c]const c_ushort) c_int;
pub extern fn wcscpy(noalias _Dest: [*c]wchar_t, noalias _Source: [*c]const wchar_t) [*c]wchar_t;
pub extern fn wcscspn(_Str: [*c]const wchar_t, _Control: [*c]const wchar_t) usize;
pub extern fn wcslen(_Str: [*c]const c_ushort) c_ulonglong;
pub extern fn wcsnlen(_Src: [*c]const wchar_t, _MaxCount: usize) usize;
pub extern fn wcsncat(noalias _Dest: [*c]wchar_t, noalias _Source: [*c]const wchar_t, _Count: usize) [*c]wchar_t;
pub extern fn wcsncmp(_Str1: [*c]const c_ushort, _Str2: [*c]const c_ushort, _MaxCount: c_ulonglong) c_int;
pub extern fn wcsncpy(noalias _Dest: [*c]wchar_t, noalias _Source: [*c]const wchar_t, _Count: usize) [*c]wchar_t;
pub extern fn _wcsncpy_l(noalias _Dest: [*c]wchar_t, noalias _Source: [*c]const wchar_t, _Count: usize, _Locale: _locale_t) [*c]wchar_t;
pub extern fn wcspbrk(_Str: [*c]const wchar_t, _Control: [*c]const wchar_t) [*c]wchar_t;
pub extern fn wcsrchr(_Str: [*c]const wchar_t, _Ch: wchar_t) [*c]wchar_t;
pub extern fn wcsspn(_Str: [*c]const wchar_t, _Control: [*c]const wchar_t) usize;
pub extern fn wcsstr(_Str: [*c]const wchar_t, _SubStr: [*c]const wchar_t) [*c]wchar_t;
pub extern fn wcstok(noalias _Str: [*c]wchar_t, noalias _Delim: [*c]const wchar_t, _Ptr: [*c][*c]wchar_t) [*c]wchar_t;
pub extern fn _wcserror(_ErrNum: c_int) [*c]wchar_t;
pub extern fn __wcserror(_Str: [*c]const wchar_t) [*c]wchar_t;
pub extern fn _wcsicmp(_Str1: [*c]const wchar_t, _Str2: [*c]const wchar_t) c_int;
pub extern fn _wcsicmp_l(_Str1: [*c]const wchar_t, _Str2: [*c]const wchar_t, _Locale: _locale_t) c_int;
pub extern fn _wcsnicmp(_Str1: [*c]const wchar_t, _Str2: [*c]const wchar_t, _MaxCount: usize) c_int;
pub extern fn _wcsnicmp_l(_Str1: [*c]const wchar_t, _Str2: [*c]const wchar_t, _MaxCount: usize, _Locale: _locale_t) c_int;
pub extern fn _wcsnset(_Str: [*c]wchar_t, _Val: wchar_t, _MaxCount: usize) [*c]wchar_t;
pub extern fn _wcsrev(_Str: [*c]wchar_t) [*c]wchar_t;
pub extern fn _wcsset(_Str: [*c]wchar_t, _Val: wchar_t) [*c]wchar_t;
pub extern fn _wcslwr(_String: [*c]wchar_t) [*c]wchar_t;
pub extern fn _wcslwr_l(_String: [*c]wchar_t, _Locale: _locale_t) [*c]wchar_t;
pub extern fn _wcsupr(_String: [*c]wchar_t) [*c]wchar_t;
pub extern fn _wcsupr_l(_String: [*c]wchar_t, _Locale: _locale_t) [*c]wchar_t;
pub extern fn wcsxfrm(noalias _Dst: [*c]wchar_t, noalias _Src: [*c]const wchar_t, _MaxCount: usize) usize;
pub extern fn _wcsxfrm_l(noalias _Dst: [*c]wchar_t, noalias _Src: [*c]const wchar_t, _MaxCount: usize, _Locale: _locale_t) usize;
pub extern fn wcscoll(_Str1: [*c]const wchar_t, _Str2: [*c]const wchar_t) c_int;
pub extern fn _wcscoll_l(_Str1: [*c]const wchar_t, _Str2: [*c]const wchar_t, _Locale: _locale_t) c_int;
pub extern fn _wcsicoll(_Str1: [*c]const wchar_t, _Str2: [*c]const wchar_t) c_int;
pub extern fn _wcsicoll_l(_Str1: [*c]const wchar_t, _Str2: [*c]const wchar_t, _Locale: _locale_t) c_int;
pub extern fn _wcsncoll(_Str1: [*c]const wchar_t, _Str2: [*c]const wchar_t, _MaxCount: usize) c_int;
pub extern fn _wcsncoll_l(_Str1: [*c]const wchar_t, _Str2: [*c]const wchar_t, _MaxCount: usize, _Locale: _locale_t) c_int;
pub extern fn _wcsnicoll(_Str1: [*c]const wchar_t, _Str2: [*c]const wchar_t, _MaxCount: usize) c_int;
pub extern fn _wcsnicoll_l(_Str1: [*c]const wchar_t, _Str2: [*c]const wchar_t, _MaxCount: usize, _Locale: _locale_t) c_int;
pub extern fn wcsdup(_Str: [*c]const wchar_t) [*c]wchar_t;
pub extern fn wcsicmp(_Str1: [*c]const wchar_t, _Str2: [*c]const wchar_t) c_int;
pub extern fn wcsnicmp(_Str1: [*c]const wchar_t, _Str2: [*c]const wchar_t, _MaxCount: usize) c_int;
pub extern fn wcsnset(_Str: [*c]wchar_t, _Val: wchar_t, _MaxCount: usize) [*c]wchar_t;
pub extern fn wcsrev(_Str: [*c]wchar_t) [*c]wchar_t;
pub extern fn wcsset(_Str: [*c]wchar_t, _Val: wchar_t) [*c]wchar_t;
pub extern fn wcslwr(_Str: [*c]wchar_t) [*c]wchar_t;
pub extern fn wcsupr(_Str: [*c]wchar_t) [*c]wchar_t;
pub extern fn wcsicoll(_Str1: [*c]const wchar_t, _Str2: [*c]const wchar_t) c_int;
pub extern fn _strset_s(_Dst: [*c]u8, _DstSize: usize, _Value: c_int) errno_t;
pub extern fn _strerror_s(_Buf: [*c]u8, _SizeInBytes: usize, _ErrMsg: [*c]const u8) errno_t;
pub extern fn strerror_s(_Buf: [*c]u8, _SizeInBytes: usize, _ErrNum: c_int) errno_t;
pub extern fn _strlwr_s(_Str: [*c]u8, _Size: usize) errno_t;
pub extern fn _strlwr_s_l(_Str: [*c]u8, _Size: usize, _Locale: _locale_t) errno_t;
pub extern fn _strnset_s(_Str: [*c]u8, _Size: usize, _Val: c_int, _MaxCount: usize) errno_t;
pub extern fn _strupr_s(_Str: [*c]u8, _Size: usize) errno_t;
pub extern fn _strupr_s_l(_Str: [*c]u8, _Size: usize, _Locale: _locale_t) errno_t;
pub extern fn strncat_s(_Dst: [*c]u8, _DstSizeInChars: usize, _Src: [*c]const u8, _MaxCount: usize) errno_t;
pub extern fn _strncat_s_l(_Dst: [*c]u8, _DstSizeInChars: usize, _Src: [*c]const u8, _MaxCount: usize, _Locale: _locale_t) errno_t;
pub extern fn strcpy_s(_Dst: [*c]u8, _SizeInBytes: rsize_t, _Src: [*c]const u8) errno_t;
pub extern fn strncpy_s(_Dst: [*c]u8, _DstSizeInChars: usize, _Src: [*c]const u8, _MaxCount: usize) errno_t;
pub extern fn _strncpy_s_l(_Dst: [*c]u8, _DstSizeInChars: usize, _Src: [*c]const u8, _MaxCount: usize, _Locale: _locale_t) errno_t;
pub extern fn strtok_s(_Str: [*c]u8, _Delim: [*c]const u8, _Context: [*c][*c]u8) [*c]u8;
pub extern fn _strtok_s_l(_Str: [*c]u8, _Delim: [*c]const u8, _Context: [*c][*c]u8, _Locale: _locale_t) [*c]u8;
pub extern fn strcat_s(_Dst: [*c]u8, _SizeInBytes: rsize_t, _Src: [*c]const u8) errno_t;
pub inline fn strnlen_s(arg__src: [*c]const u8, arg__count: usize) usize {
    var _src = arg__src;
    _ = &_src;
    var _count = arg__count;
    _ = &_count;
    return if (_src != null) strnlen(_src, _count) else @as(usize, @bitCast(@as(c_longlong, @as(c_int, 0))));
}
pub extern fn memmove_s(_dest: ?*anyopaque, _numberOfElements: usize, _src: ?*const anyopaque, _count: usize) errno_t;
pub extern fn wcstok_s(_Str: [*c]wchar_t, _Delim: [*c]const wchar_t, _Context: [*c][*c]wchar_t) [*c]wchar_t;
pub extern fn _wcserror_s(_Buf: [*c]wchar_t, _SizeInWords: usize, _ErrNum: c_int) errno_t;
pub extern fn __wcserror_s(_Buffer: [*c]wchar_t, _SizeInWords: usize, _ErrMsg: [*c]const wchar_t) errno_t;
pub extern fn _wcsnset_s(_Dst: [*c]wchar_t, _DstSizeInWords: usize, _Val: wchar_t, _MaxCount: usize) errno_t;
pub extern fn _wcsset_s(_Str: [*c]wchar_t, _SizeInWords: usize, _Val: wchar_t) errno_t;
pub extern fn _wcslwr_s(_Str: [*c]wchar_t, _SizeInWords: usize) errno_t;
pub extern fn _wcslwr_s_l(_Str: [*c]wchar_t, _SizeInWords: usize, _Locale: _locale_t) errno_t;
pub extern fn _wcsupr_s(_Str: [*c]wchar_t, _Size: usize) errno_t;
pub extern fn _wcsupr_s_l(_Str: [*c]wchar_t, _Size: usize, _Locale: _locale_t) errno_t;
pub extern fn wcscpy_s(_Dst: [*c]wchar_t, _SizeInWords: rsize_t, _Src: [*c]const wchar_t) errno_t;
pub extern fn wcscat_s(_Dst: [*c]wchar_t, _SizeInWords: rsize_t, _Src: [*c]const wchar_t) errno_t;
pub extern fn wcsncat_s(_Dst: [*c]wchar_t, _DstSizeInChars: usize, _Src: [*c]const wchar_t, _MaxCount: usize) errno_t;
pub extern fn _wcsncat_s_l(_Dst: [*c]wchar_t, _DstSizeInChars: usize, _Src: [*c]const wchar_t, _MaxCount: usize, _Locale: _locale_t) errno_t;
pub extern fn wcsncpy_s(_Dst: [*c]wchar_t, _DstSizeInChars: usize, _Src: [*c]const wchar_t, _MaxCount: usize) errno_t;
pub extern fn _wcsncpy_s_l(_Dst: [*c]wchar_t, _DstSizeInChars: usize, _Src: [*c]const wchar_t, _MaxCount: usize, _Locale: _locale_t) errno_t;
pub extern fn _wcstok_s_l(_Str: [*c]wchar_t, _Delim: [*c]const wchar_t, _Context: [*c][*c]wchar_t, _Locale: _locale_t) [*c]wchar_t;
pub extern fn _wcsset_s_l(_Str: [*c]wchar_t, _SizeInChars: usize, _Val: wchar_t, _Locale: _locale_t) errno_t;
pub extern fn _wcsnset_s_l(_Str: [*c]wchar_t, _SizeInChars: usize, _Val: wchar_t, _Count: usize, _Locale: _locale_t) errno_t;
pub inline fn wcsnlen_s(arg__src: [*c]const wchar_t, arg__count: usize) usize {
    var _src = arg__src;
    _ = &_src;
    var _count = arg__count;
    _ = &_count;
    return if (_src != null) wcsnlen(_src, _count) else @as(usize, @bitCast(@as(c_longlong, @as(c_int, 0))));
}
pub extern fn _getcwd([*c]u8, c_int) [*c]u8;
pub const _fsize_t = c_ulong;
pub const struct__finddata32_t = extern struct {
    attrib: c_uint = @import("std").mem.zeroes(c_uint),
    time_create: __time32_t = @import("std").mem.zeroes(__time32_t),
    time_access: __time32_t = @import("std").mem.zeroes(__time32_t),
    time_write: __time32_t = @import("std").mem.zeroes(__time32_t),
    size: _fsize_t = @import("std").mem.zeroes(_fsize_t),
    name: [260]u8 = @import("std").mem.zeroes([260]u8),
};
pub const struct__finddata32i64_t = extern struct {
    attrib: c_uint = @import("std").mem.zeroes(c_uint),
    time_create: __time32_t = @import("std").mem.zeroes(__time32_t),
    time_access: __time32_t = @import("std").mem.zeroes(__time32_t),
    time_write: __time32_t = @import("std").mem.zeroes(__time32_t),
    size: c_longlong = @import("std").mem.zeroes(c_longlong),
    name: [260]u8 = @import("std").mem.zeroes([260]u8),
};
pub const struct__finddata64i32_t = extern struct {
    attrib: c_uint = @import("std").mem.zeroes(c_uint),
    time_create: __time64_t = @import("std").mem.zeroes(__time64_t),
    time_access: __time64_t = @import("std").mem.zeroes(__time64_t),
    time_write: __time64_t = @import("std").mem.zeroes(__time64_t),
    size: _fsize_t = @import("std").mem.zeroes(_fsize_t),
    name: [260]u8 = @import("std").mem.zeroes([260]u8),
};
pub const struct___finddata64_t = extern struct {
    attrib: c_uint = @import("std").mem.zeroes(c_uint),
    time_create: __time64_t = @import("std").mem.zeroes(__time64_t),
    time_access: __time64_t = @import("std").mem.zeroes(__time64_t),
    time_write: __time64_t = @import("std").mem.zeroes(__time64_t),
    size: c_longlong = @import("std").mem.zeroes(c_longlong),
    name: [260]u8 = @import("std").mem.zeroes([260]u8),
};
pub const struct__wfinddata32_t = extern struct {
    attrib: c_uint = @import("std").mem.zeroes(c_uint),
    time_create: __time32_t = @import("std").mem.zeroes(__time32_t),
    time_access: __time32_t = @import("std").mem.zeroes(__time32_t),
    time_write: __time32_t = @import("std").mem.zeroes(__time32_t),
    size: _fsize_t = @import("std").mem.zeroes(_fsize_t),
    name: [260]wchar_t = @import("std").mem.zeroes([260]wchar_t),
};
pub const struct__wfinddata32i64_t = extern struct {
    attrib: c_uint = @import("std").mem.zeroes(c_uint),
    time_create: __time32_t = @import("std").mem.zeroes(__time32_t),
    time_access: __time32_t = @import("std").mem.zeroes(__time32_t),
    time_write: __time32_t = @import("std").mem.zeroes(__time32_t),
    size: c_longlong = @import("std").mem.zeroes(c_longlong),
    name: [260]wchar_t = @import("std").mem.zeroes([260]wchar_t),
};
pub const struct__wfinddata64i32_t = extern struct {
    attrib: c_uint = @import("std").mem.zeroes(c_uint),
    time_create: __time64_t = @import("std").mem.zeroes(__time64_t),
    time_access: __time64_t = @import("std").mem.zeroes(__time64_t),
    time_write: __time64_t = @import("std").mem.zeroes(__time64_t),
    size: _fsize_t = @import("std").mem.zeroes(_fsize_t),
    name: [260]wchar_t = @import("std").mem.zeroes([260]wchar_t),
};
pub const struct__wfinddata64_t = extern struct {
    attrib: c_uint = @import("std").mem.zeroes(c_uint),
    time_create: __time64_t = @import("std").mem.zeroes(__time64_t),
    time_access: __time64_t = @import("std").mem.zeroes(__time64_t),
    time_write: __time64_t = @import("std").mem.zeroes(__time64_t),
    size: c_longlong = @import("std").mem.zeroes(c_longlong),
    name: [260]wchar_t = @import("std").mem.zeroes([260]wchar_t),
};
pub const _off_t = c_long;
pub const off32_t = c_long;
pub const _off64_t = c_longlong;
pub const off64_t = c_longlong;
pub const off_t = off32_t;
pub extern fn _access(_Filename: [*c]const u8, _AccessMode: c_int) c_int;
pub extern fn _access_s(_Filename: [*c]const u8, _AccessMode: c_int) errno_t;
pub extern fn _chmod(_Filename: [*c]const u8, _Mode: c_int) c_int;
pub extern fn _chsize(_FileHandle: c_int, _Size: c_long) c_int;
pub extern fn _chsize_s(_FileHandle: c_int, _Size: c_longlong) errno_t;
pub extern fn _close(_FileHandle: c_int) c_int;
pub extern fn _commit(_FileHandle: c_int) c_int;
pub extern fn _creat(_Filename: [*c]const u8, _PermissionMode: c_int) c_int;
pub extern fn _dup(_FileHandle: c_int) c_int;
pub extern fn _dup2(_FileHandleSrc: c_int, _FileHandleDst: c_int) c_int;
pub extern fn _eof(_FileHandle: c_int) c_int;
pub extern fn _filelength(_FileHandle: c_int) c_long;
pub extern fn _findfirst32(_Filename: [*c]const u8, _FindData: [*c]struct__finddata32_t) isize;
pub extern fn _findnext32(_FindHandle: isize, _FindData: [*c]struct__finddata32_t) c_int;
pub extern fn _findclose(_FindHandle: isize) c_int;
pub extern fn _isatty(_FileHandle: c_int) c_int;
pub extern fn _locking(_FileHandle: c_int, _LockMode: c_int, _NumOfBytes: c_long) c_int;
pub extern fn _lseek(_FileHandle: c_int, _Offset: c_long, _Origin: c_int) c_long;
pub extern fn lseek64(fd: c_int, offset: _off64_t, whence: c_int) _off64_t;
pub extern fn _mktemp(_TemplateName: [*c]u8) [*c]u8;
pub extern fn _mktemp_s(_TemplateName: [*c]u8, _Size: usize) errno_t;
pub extern fn _pipe(_PtHandles: [*c]c_int, _PipeSize: c_uint, _TextMode: c_int) c_int;
pub extern fn _read(_FileHandle: c_int, _DstBuf: ?*anyopaque, _MaxCharCount: c_uint) c_int;
pub extern fn remove(_Filename: [*c]const u8) c_int;
pub extern fn rename(_OldFilename: [*c]const u8, _NewFilename: [*c]const u8) c_int;
pub extern fn _unlink(_Filename: [*c]const u8) c_int;
pub extern fn unlink(_Filename: [*c]const u8) c_int;
pub extern fn _setmode(_FileHandle: c_int, _Mode: c_int) c_int;
pub extern fn _tell(_FileHandle: c_int) c_long;
pub extern fn _umask(_Mode: c_int) c_int;
pub extern fn _umask_s(_NewMode: c_int, _OldMode: [*c]c_int) errno_t;
pub extern fn _write(_FileHandle: c_int, _Buf: ?*const anyopaque, _MaxCharCount: c_uint) c_int;
pub extern fn _filelengthi64(_FileHandle: c_int) c_longlong;
pub extern fn _findfirst32i64(_Filename: [*c]const u8, _FindData: [*c]struct__finddata32i64_t) isize;
pub extern fn _findfirst64(_Filename: [*c]const u8, _FindData: [*c]struct___finddata64_t) isize;
pub extern fn _findfirst64i32(_Filename: [*c]const u8, _FindData: [*c]struct__finddata64i32_t) isize;
pub extern fn _findnext32i64(_FindHandle: isize, _FindData: [*c]struct__finddata32i64_t) c_int;
pub extern fn _findnext64(_FindHandle: isize, _FindData: [*c]struct___finddata64_t) c_int;
pub extern fn _findnext64i32(_FindHandle: isize, _FindData: [*c]struct__finddata64i32_t) c_int;
pub extern fn _lseeki64(_FileHandle: c_int, _Offset: c_longlong, _Origin: c_int) c_longlong;
pub extern fn _telli64(_FileHandle: c_int) c_longlong;
pub extern fn chdir([*c]const u8) c_int;
pub extern fn getcwd([*c]u8, c_int) [*c]u8;
pub extern fn mkdir([*c]const u8) c_int;
pub extern fn mktemp([*c]u8) [*c]u8;
pub extern fn rmdir([*c]const u8) c_int;
pub extern fn chmod([*c]const u8, c_int) c_int;
pub extern fn _sopen_s(_FileHandle: [*c]c_int, _Filename: [*c]const u8, _OpenFlag: c_int, _ShareFlag: c_int, _PermissionMode: c_int) errno_t;
pub extern fn _open(_Filename: [*c]const u8, _OpenFlag: c_int, ...) c_int;
pub extern fn _sopen(_Filename: [*c]const u8, _OpenFlag: c_int, _ShareFlag: c_int, ...) c_int;
pub extern fn _waccess(_Filename: [*c]const wchar_t, _AccessMode: c_int) c_int;
pub extern fn _waccess_s(_Filename: [*c]const wchar_t, _AccessMode: c_int) errno_t;
pub extern fn _wchmod(_Filename: [*c]const wchar_t, _Mode: c_int) c_int;
pub extern fn _wcreat(_Filename: [*c]const wchar_t, _PermissionMode: c_int) c_int;
pub extern fn _wfindfirst32(_Filename: [*c]const wchar_t, _FindData: [*c]struct__wfinddata32_t) isize;
pub extern fn _wfindnext32(_FindHandle: isize, _FindData: [*c]struct__wfinddata32_t) c_int;
pub extern fn _wunlink(_Filename: [*c]const wchar_t) c_int;
pub extern fn _wrename(_OldFilename: [*c]const wchar_t, _NewFilename: [*c]const wchar_t) c_int;
pub extern fn _wmktemp(_TemplateName: [*c]wchar_t) [*c]wchar_t;
pub extern fn _wmktemp_s(_TemplateName: [*c]wchar_t, _SizeInWords: usize) errno_t;
pub extern fn _wfindfirst32i64(_Filename: [*c]const wchar_t, _FindData: [*c]struct__wfinddata32i64_t) isize;
pub extern fn _wfindfirst64i32(_Filename: [*c]const wchar_t, _FindData: [*c]struct__wfinddata64i32_t) isize;
pub extern fn _wfindfirst64(_Filename: [*c]const wchar_t, _FindData: [*c]struct__wfinddata64_t) isize;
pub extern fn _wfindnext32i64(_FindHandle: isize, _FindData: [*c]struct__wfinddata32i64_t) c_int;
pub extern fn _wfindnext64i32(_FindHandle: isize, _FindData: [*c]struct__wfinddata64i32_t) c_int;
pub extern fn _wfindnext64(_FindHandle: isize, _FindData: [*c]struct__wfinddata64_t) c_int;
pub extern fn _wsopen_s(_FileHandle: [*c]c_int, _Filename: [*c]const wchar_t, _OpenFlag: c_int, _ShareFlag: c_int, _PermissionFlag: c_int) errno_t;
pub extern fn _wopen(_Filename: [*c]const wchar_t, _OpenFlag: c_int, ...) c_int;
pub extern fn _wsopen(_Filename: [*c]const wchar_t, _OpenFlag: c_int, _ShareFlag: c_int, ...) c_int;
pub extern fn __lock_fhandle(_Filehandle: c_int) c_int;
pub extern fn _unlock_fhandle(_Filehandle: c_int) void;
pub extern fn _get_osfhandle(_FileHandle: c_int) isize;
pub extern fn _open_osfhandle(_OSFileHandle: isize, _Flags: c_int) c_int;
pub extern fn access(_Filename: [*c]const u8, _AccessMode: c_int) c_int;
pub extern fn chsize(_FileHandle: c_int, _Size: c_long) c_int;
pub extern fn close(_FileHandle: c_int) c_int;
pub extern fn creat(_Filename: [*c]const u8, _PermissionMode: c_int) c_int;
pub extern fn dup(_FileHandle: c_int) c_int;
pub extern fn dup2(_FileHandleSrc: c_int, _FileHandleDst: c_int) c_int;
pub extern fn eof(_FileHandle: c_int) c_int;
pub extern fn filelength(_FileHandle: c_int) c_long;
pub extern fn isatty(_FileHandle: c_int) c_int;
pub extern fn locking(_FileHandle: c_int, _LockMode: c_int, _NumOfBytes: c_long) c_int;
pub extern fn lseek(_FileHandle: c_int, _Offset: c_long, _Origin: c_int) c_long;
pub extern fn open(_Filename: [*c]const u8, _OpenFlag: c_int, ...) c_int;
pub extern fn read(_FileHandle: c_int, _DstBuf: ?*anyopaque, _MaxCharCount: c_uint) c_int;
pub extern fn setmode(_FileHandle: c_int, _Mode: c_int) c_int;
pub extern fn sopen(_Filename: [*c]const u8, _OpenFlag: c_int, _ShareFlag: c_int, ...) c_int;
pub extern fn tell(_FileHandle: c_int) c_long;
pub extern fn umask(_Mode: c_int) c_int;
pub extern fn write(_Filehandle: c_int, _Buf: ?*const anyopaque, _MaxCharCount: c_uint) c_int;
pub extern fn __p__acmdln() [*c][*c]u8;
pub extern fn __p__wcmdln() [*c][*c]wchar_t;
pub const _PVFV = ?*const fn () callconv(.C) void;
pub const _PIFV = ?*const fn () callconv(.C) c_int;
pub const _PVFI = ?*const fn (c_int) callconv(.C) void;
pub const struct__onexit_table_t = extern struct {
    _first: [*c]_PVFV = @import("std").mem.zeroes([*c]_PVFV),
    _last: [*c]_PVFV = @import("std").mem.zeroes([*c]_PVFV),
    _end: [*c]_PVFV = @import("std").mem.zeroes([*c]_PVFV),
};
pub const _onexit_table_t = struct__onexit_table_t;
pub const _onexit_t = ?*const fn () callconv(.C) c_int;
pub extern fn _initialize_onexit_table([*c]_onexit_table_t) c_int;
pub extern fn _register_onexit_function([*c]_onexit_table_t, _onexit_t) c_int;
pub extern fn _execute_onexit_table([*c]_onexit_table_t) c_int;
pub extern fn _crt_atexit(func: _PVFV) c_int;
pub extern fn _crt_at_quick_exit(func: _PVFV) c_int;
pub const _ino_t = c_ushort;
pub const ino_t = c_ushort;
pub const _dev_t = c_uint;
pub const dev_t = c_uint;
pub const _pid_t = c_longlong;
pub const pid_t = _pid_t;
pub const _mode_t = c_ushort;
pub const mode_t = _mode_t;
pub const useconds_t = c_uint;
pub const _sigset_t = c_ulonglong;
pub const _beginthread_proc_type = ?*const fn (?*anyopaque) callconv(.C) void;
pub const _beginthreadex_proc_type = ?*const fn (?*anyopaque) callconv(.C) c_uint;
pub extern fn _beginthread(_StartAddress: _beginthread_proc_type, _StackSize: c_uint, _ArgList: ?*anyopaque) usize;
pub extern fn _endthread() noreturn;
pub extern fn _beginthreadex(_Security: ?*anyopaque, _StackSize: c_uint, _StartAddress: _beginthreadex_proc_type, _ArgList: ?*anyopaque, _InitFlag: c_uint, _ThrdAddr: [*c]c_uint) usize;
pub extern fn _endthreadex(_Retval: c_uint) noreturn;
pub extern fn exit(_Code: c_int) noreturn;
pub extern fn _exit(_Code: c_int) noreturn;
pub extern fn quick_exit(_Code: c_int) noreturn;
pub extern fn _Exit(c_int) noreturn;
pub extern fn abort() noreturn;
pub const _tls_callback_type = ?*const fn (?*anyopaque, c_ulong, ?*anyopaque) callconv(.C) void;
pub extern fn _register_thread_local_exe_atexit_callback(callback: _tls_callback_type) void;
pub extern fn _cexit() void;
pub extern fn _c_exit() void;
pub extern fn _getpid() c_int;
pub extern fn _cwait(_TermStat: [*c]c_int, _ProcHandle: isize, _Action: c_int) isize;
pub extern fn _execl(_Filename: [*c]const u8, _ArgList: [*c]const u8, ...) isize;
pub extern fn _execle(_Filename: [*c]const u8, _ArgList: [*c]const u8, ...) isize;
pub extern fn _execlp(_Filename: [*c]const u8, _ArgList: [*c]const u8, ...) isize;
pub extern fn _execlpe(_Filename: [*c]const u8, _ArgList: [*c]const u8, ...) isize;
pub extern fn _execv(_Filename: [*c]const u8, _ArgList: [*c]const [*c]const u8) isize;
pub extern fn _execve(_Filename: [*c]const u8, _ArgList: [*c]const [*c]const u8, _Env: [*c]const [*c]const u8) isize;
pub extern fn _execvp(_Filename: [*c]const u8, _ArgList: [*c]const [*c]const u8) isize;
pub extern fn _execvpe(_Filename: [*c]const u8, _ArgList: [*c]const [*c]const u8, _Env: [*c]const [*c]const u8) isize;
pub extern fn _spawnl(_Mode: c_int, _Filename: [*c]const u8, _ArgList: [*c]const u8, ...) isize;
pub extern fn _spawnle(_Mode: c_int, _Filename: [*c]const u8, _ArgList: [*c]const u8, ...) isize;
pub extern fn _spawnlp(_Mode: c_int, _Filename: [*c]const u8, _ArgList: [*c]const u8, ...) isize;
pub extern fn _spawnlpe(_Mode: c_int, _Filename: [*c]const u8, _ArgList: [*c]const u8, ...) isize;
pub extern fn _spawnv(_Mode: c_int, _Filename: [*c]const u8, _ArgList: [*c]const [*c]const u8) isize;
pub extern fn _spawnve(_Mode: c_int, _Filename: [*c]const u8, _ArgList: [*c]const [*c]const u8, _Env: [*c]const [*c]const u8) isize;
pub extern fn _spawnvp(_Mode: c_int, _Filename: [*c]const u8, _ArgList: [*c]const [*c]const u8) isize;
pub extern fn _spawnvpe(_Mode: c_int, _Filename: [*c]const u8, _ArgList: [*c]const [*c]const u8, _Env: [*c]const [*c]const u8) isize;
pub extern fn system(_Command: [*c]const u8) c_int;
pub extern fn _wexecl(_Filename: [*c]const wchar_t, _ArgList: [*c]const wchar_t, ...) isize;
pub extern fn _wexecle(_Filename: [*c]const wchar_t, _ArgList: [*c]const wchar_t, ...) isize;
pub extern fn _wexeclp(_Filename: [*c]const wchar_t, _ArgList: [*c]const wchar_t, ...) isize;
pub extern fn _wexeclpe(_Filename: [*c]const wchar_t, _ArgList: [*c]const wchar_t, ...) isize;
pub extern fn _wexecv(_Filename: [*c]const wchar_t, _ArgList: [*c]const [*c]const wchar_t) isize;
pub extern fn _wexecve(_Filename: [*c]const wchar_t, _ArgList: [*c]const [*c]const wchar_t, _Env: [*c]const [*c]const wchar_t) isize;
pub extern fn _wexecvp(_Filename: [*c]const wchar_t, _ArgList: [*c]const [*c]const wchar_t) isize;
pub extern fn _wexecvpe(_Filename: [*c]const wchar_t, _ArgList: [*c]const [*c]const wchar_t, _Env: [*c]const [*c]const wchar_t) isize;
pub extern fn _wspawnl(_Mode: c_int, _Filename: [*c]const wchar_t, _ArgList: [*c]const wchar_t, ...) isize;
pub extern fn _wspawnle(_Mode: c_int, _Filename: [*c]const wchar_t, _ArgList: [*c]const wchar_t, ...) isize;
pub extern fn _wspawnlp(_Mode: c_int, _Filename: [*c]const wchar_t, _ArgList: [*c]const wchar_t, ...) isize;
pub extern fn _wspawnlpe(_Mode: c_int, _Filename: [*c]const wchar_t, _ArgList: [*c]const wchar_t, ...) isize;
pub extern fn _wspawnv(_Mode: c_int, _Filename: [*c]const wchar_t, _ArgList: [*c]const [*c]const wchar_t) isize;
pub extern fn _wspawnve(_Mode: c_int, _Filename: [*c]const wchar_t, _ArgList: [*c]const [*c]const wchar_t, _Env: [*c]const [*c]const wchar_t) isize;
pub extern fn _wspawnvp(_Mode: c_int, _Filename: [*c]const wchar_t, _ArgList: [*c]const [*c]const wchar_t) isize;
pub extern fn _wspawnvpe(_Mode: c_int, _Filename: [*c]const wchar_t, _ArgList: [*c]const [*c]const wchar_t, _Env: [*c]const [*c]const wchar_t) isize;
pub extern fn _wsystem(_Command: [*c]const wchar_t) c_int;
pub extern fn _loaddll(_Filename: [*c]u8) isize;
pub extern fn _unloaddll(_Handle: isize) c_int;
pub extern fn _getdllprocaddr(_Handle: isize, _ProcedureName: [*c]u8, _Ordinal: isize) ?*const fn () callconv(.C) c_int;
pub extern fn getpid() c_int;
pub extern fn cwait(_TermStat: [*c]c_int, _ProcHandle: isize, _Action: c_int) isize;
pub extern fn execl(_Filename: [*c]const u8, _ArgList: [*c]const u8, ...) c_int;
pub extern fn execle(_Filename: [*c]const u8, _ArgList: [*c]const u8, ...) c_int;
pub extern fn execlp(_Filename: [*c]const u8, _ArgList: [*c]const u8, ...) c_int;
pub extern fn execlpe(_Filename: [*c]const u8, _ArgList: [*c]const u8, ...) c_int;
pub extern fn spawnl(c_int, _Filename: [*c]const u8, _ArgList: [*c]const u8, ...) isize;
pub extern fn spawnle(c_int, _Filename: [*c]const u8, _ArgList: [*c]const u8, ...) isize;
pub extern fn spawnlp(c_int, _Filename: [*c]const u8, _ArgList: [*c]const u8, ...) isize;
pub extern fn spawnlpe(c_int, _Filename: [*c]const u8, _ArgList: [*c]const u8, ...) isize;
pub extern fn execv(_Filename: [*c]const u8, _ArgList: [*c]const [*c]u8) c_int;
pub extern fn execve(_Filename: [*c]const u8, _ArgList: [*c]const [*c]u8, _Env: [*c]const [*c]u8) c_int;
pub extern fn execvp(_Filename: [*c]const u8, _ArgList: [*c]const [*c]u8) c_int;
pub extern fn execvpe(_Filename: [*c]const u8, _ArgList: [*c]const [*c]u8, _Env: [*c]const [*c]u8) c_int;
pub extern fn spawnv(c_int, _Filename: [*c]const u8, _ArgList: [*c]const [*c]u8) isize;
pub extern fn spawnve(c_int, _Filename: [*c]const u8, _ArgList: [*c]const [*c]u8, _Env: [*c]const [*c]u8) isize;
pub extern fn spawnvp(c_int, _Filename: [*c]const u8, _ArgList: [*c]const [*c]u8) isize;
pub extern fn spawnvpe(c_int, _Filename: [*c]const u8, _ArgList: [*c]const [*c]u8, _Env: [*c]const [*c]u8) isize;
pub extern var optind: c_int;
pub extern var optopt: c_int;
pub extern var opterr: c_int;
pub extern var optarg: [*c]u8;
pub extern fn getopt(nargc: c_int, nargv: [*c]const [*c]u8, options: [*c]const u8) c_int;
pub extern fn sleep(c_uint) c_uint;
pub extern fn usleep(useconds_t) c_int;
pub extern fn ftruncate(c_int, off32_t) c_int;
pub extern fn ftruncate64(c_int, off64_t) c_int;
pub extern fn truncate([*c]const u8, off32_t) c_int;
pub extern fn truncate64([*c]const u8, off64_t) c_int;
pub extern fn swab(_Buf1: [*c]u8, _Buf2: [*c]u8, _SizeInBytes: c_int) void;
pub const struct__iobuf = extern struct {
    _Placeholder: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub const FILE = struct__iobuf;
pub extern fn __acrt_iob_func(index: c_uint) [*c]FILE;
pub extern fn __iob_func() [*c]FILE;
pub const fpos_t = c_longlong;
pub extern fn __mingw_sscanf(noalias _Src: [*c]const u8, noalias _Format: [*c]const u8, ...) c_int;
pub extern fn __mingw_vsscanf(noalias _Str: [*c]const u8, noalias Format: [*c]const u8, argp: va_list) c_int;
pub extern fn __mingw_scanf(noalias _Format: [*c]const u8, ...) c_int;
pub extern fn __mingw_vscanf(noalias Format: [*c]const u8, argp: va_list) c_int;
pub extern fn __mingw_fscanf(noalias _File: [*c]FILE, noalias _Format: [*c]const u8, ...) c_int;
pub extern fn __mingw_vfscanf(noalias fp: [*c]FILE, noalias Format: [*c]const u8, argp: va_list) c_int;
pub extern fn __mingw_vsnprintf(noalias _DstBuf: [*c]u8, _MaxCount: usize, noalias _Format: [*c]const u8, _ArgList: va_list) c_int;
pub extern fn __mingw_snprintf(noalias s: [*c]u8, n: usize, noalias format: [*c]const u8, ...) c_int;
pub const __mingw_printf = @compileError("unable to resolve function type clang.TypeClass.MacroQualified");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/stdio.h:195:15
pub const __mingw_vprintf = @compileError("unable to resolve function type clang.TypeClass.MacroQualified");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/stdio.h:198:15
pub const __mingw_fprintf = @compileError("unable to resolve function type clang.TypeClass.MacroQualified");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/stdio.h:201:15
pub const __mingw_vfprintf = @compileError("unable to resolve function type clang.TypeClass.MacroQualified");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/stdio.h:204:15
pub const __mingw_sprintf = @compileError("unable to resolve function type clang.TypeClass.MacroQualified");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/stdio.h:207:15
pub const __mingw_vsprintf = @compileError("unable to resolve function type clang.TypeClass.MacroQualified");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/stdio.h:210:15
pub const __mingw_asprintf = @compileError("unable to resolve function type clang.TypeClass.MacroQualified");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/stdio.h:213:15
pub const __mingw_vasprintf = @compileError("unable to resolve function type clang.TypeClass.MacroQualified");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/stdio.h:216:15
pub extern fn __ms_sscanf(noalias _Src: [*c]const u8, noalias _Format: [*c]const u8, ...) c_int;
pub extern fn __ms_scanf(noalias _Format: [*c]const u8, ...) c_int;
pub extern fn __ms_fscanf(noalias _File: [*c]FILE, noalias _Format: [*c]const u8, ...) c_int;
pub const __ms_printf = @compileError("unable to resolve function type clang.TypeClass.MacroQualified");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/stdio.h:230:15
pub const __ms_vprintf = @compileError("unable to resolve function type clang.TypeClass.MacroQualified");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/stdio.h:233:15
pub const __ms_fprintf = @compileError("unable to resolve function type clang.TypeClass.MacroQualified");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/stdio.h:236:15
pub const __ms_vfprintf = @compileError("unable to resolve function type clang.TypeClass.MacroQualified");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/stdio.h:239:15
pub const __ms_sprintf = @compileError("unable to resolve function type clang.TypeClass.MacroQualified");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/stdio.h:242:15
pub const __ms_vsprintf = @compileError("unable to resolve function type clang.TypeClass.MacroQualified");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/stdio.h:245:15
pub extern fn __stdio_common_vsprintf(options: c_ulonglong, str: [*c]u8, len: usize, format: [*c]const u8, locale: _locale_t, valist: va_list) c_int;
pub extern fn __stdio_common_vfprintf(options: c_ulonglong, file: [*c]FILE, format: [*c]const u8, locale: _locale_t, valist: va_list) c_int;
pub extern fn __stdio_common_vsscanf(options: c_ulonglong, input: [*c]const u8, length: usize, format: [*c]const u8, locale: _locale_t, valist: va_list) c_int;
pub extern fn __stdio_common_vfscanf(options: c_ulonglong, file: [*c]FILE, format: [*c]const u8, locale: _locale_t, valist: va_list) c_int;
pub extern fn fprintf(_File: [*c]FILE, _Format: [*c]const u8, ...) c_int;
pub extern fn printf(_Format: [*c]const u8, ...) c_int;
pub extern fn sprintf(_Dest: [*c]u8, _Format: [*c]const u8, ...) c_int;
pub extern fn vfprintf(_File: [*c]FILE, _Format: [*c]const u8, _ArgList: __builtin_va_list) c_int;
pub extern fn vprintf(_Format: [*c]const u8, _ArgList: __builtin_va_list) c_int;
pub extern fn vsprintf(_Dest: [*c]u8, _Format: [*c]const u8, _Args: __builtin_va_list) c_int;
pub extern fn fscanf(noalias _File: [*c]FILE, noalias _Format: [*c]const u8, ...) c_int;
pub extern fn scanf(noalias _Format: [*c]const u8, ...) c_int;
pub extern fn sscanf(noalias _Src: [*c]const u8, noalias _Format: [*c]const u8, ...) c_int;
pub extern fn vfscanf(noalias __stream: [*c]FILE, noalias __format: [*c]const u8, __local_argv: __builtin_va_list) c_int;
pub extern fn vsscanf(noalias __source: [*c]const u8, noalias __format: [*c]const u8, __local_argv: __builtin_va_list) c_int;
pub extern fn vscanf(noalias __format: [*c]const u8, __local_argv: __builtin_va_list) c_int;
pub extern fn _filbuf(_File: [*c]FILE) c_int;
pub extern fn _flsbuf(_Ch: c_int, _File: [*c]FILE) c_int;
pub extern fn _fsopen(_Filename: [*c]const u8, _Mode: [*c]const u8, _ShFlag: c_int) [*c]FILE;
pub extern fn clearerr(_File: [*c]FILE) void;
pub extern fn fclose(_File: [*c]FILE) c_int;
pub extern fn _fcloseall() c_int;
pub extern fn _fdopen(_FileHandle: c_int, _Mode: [*c]const u8) [*c]FILE;
pub extern fn feof(_File: [*c]FILE) c_int;
pub extern fn ferror(_File: [*c]FILE) c_int;
pub extern fn fflush(_File: [*c]FILE) c_int;
pub extern fn fgetc(_File: [*c]FILE) c_int;
pub extern fn _fgetchar() c_int;
pub extern fn fgetpos(noalias _File: [*c]FILE, noalias _Pos: [*c]fpos_t) c_int;
pub extern fn fgetpos64(noalias _File: [*c]FILE, noalias _Pos: [*c]fpos_t) c_int;
pub extern fn fgets(noalias _Buf: [*c]u8, _MaxCount: c_int, noalias _File: [*c]FILE) [*c]u8;
pub extern fn _fileno(_File: [*c]FILE) c_int;
pub extern fn _tempnam(_DirName: [*c]const u8, _FilePrefix: [*c]const u8) [*c]u8;
pub extern fn _flushall() c_int;
pub extern fn fopen(_Filename: [*c]const u8, _Mode: [*c]const u8) [*c]FILE;
pub extern fn fopen64(noalias filename: [*c]const u8, noalias mode: [*c]const u8) [*c]FILE;
pub extern fn fputc(_Ch: c_int, _File: [*c]FILE) c_int;
pub extern fn _fputchar(_Ch: c_int) c_int;
pub extern fn fputs(noalias _Str: [*c]const u8, noalias _File: [*c]FILE) c_int;
pub extern fn fread(_DstBuf: ?*anyopaque, _ElementSize: c_ulonglong, _Count: c_ulonglong, _File: [*c]FILE) c_ulonglong;
pub extern fn freopen(noalias _Filename: [*c]const u8, noalias _Mode: [*c]const u8, noalias _File: [*c]FILE) [*c]FILE;
pub extern fn fsetpos(_File: [*c]FILE, _Pos: [*c]const fpos_t) c_int;
pub extern fn fsetpos64(_File: [*c]FILE, _Pos: [*c]const fpos_t) c_int;
pub extern fn fseek(_File: [*c]FILE, _Offset: c_long, _Origin: c_int) c_int;
pub extern fn ftell(_File: [*c]FILE) c_long;
pub extern fn _fseeki64(_File: [*c]FILE, _Offset: c_longlong, _Origin: c_int) c_int;
pub extern fn _ftelli64(_File: [*c]FILE) c_longlong;
pub fn fseeko(arg__File: [*c]FILE, arg__Offset: _off_t, arg__Origin: c_int) callconv(.C) c_int {
    var _File = arg__File;
    _ = &_File;
    var _Offset = arg__Offset;
    _ = &_Offset;
    var _Origin = arg__Origin;
    _ = &_Origin;
    return fseek(_File, _Offset, _Origin);
}
pub fn fseeko64(arg__File: [*c]FILE, arg__Offset: _off64_t, arg__Origin: c_int) callconv(.C) c_int {
    var _File = arg__File;
    _ = &_File;
    var _Offset = arg__Offset;
    _ = &_Offset;
    var _Origin = arg__Origin;
    _ = &_Origin;
    return _fseeki64(_File, _Offset, _Origin);
}
pub fn ftello(arg__File: [*c]FILE) callconv(.C) _off_t {
    var _File = arg__File;
    _ = &_File;
    return ftell(_File);
}
pub fn ftello64(arg__File: [*c]FILE) callconv(.C) _off64_t {
    var _File = arg__File;
    _ = &_File;
    return _ftelli64(_File);
}
pub extern fn fwrite(_Str: ?*const anyopaque, _Size: c_ulonglong, _Count: c_ulonglong, _File: [*c]FILE) c_ulonglong;
pub extern fn getc(_File: [*c]FILE) c_int;
pub extern fn getchar() c_int;
pub extern fn _getmaxstdio() c_int;
pub extern fn gets(_Buffer: [*c]u8) [*c]u8;
pub extern fn _getw(_File: [*c]FILE) c_int;
pub extern fn perror(_ErrMsg: [*c]const u8) void;
pub extern fn _pclose(_File: [*c]FILE) c_int;
pub extern fn _popen(_Command: [*c]const u8, _Mode: [*c]const u8) [*c]FILE;
pub extern fn putc(_Ch: c_int, _File: [*c]FILE) c_int;
pub extern fn putchar(_Ch: c_int) c_int;
pub extern fn puts(_Str: [*c]const u8) c_int;
pub extern fn _putw(_Word: c_int, _File: [*c]FILE) c_int;
pub extern fn rewind(_File: [*c]FILE) void;
pub extern fn _rmtmp() c_int;
pub extern fn setbuf(noalias _File: [*c]FILE, noalias _Buffer: [*c]u8) void;
pub extern fn _setmaxstdio(_Max: c_int) c_int;
pub extern fn _set_output_format(_Format: c_uint) c_uint;
pub extern fn _get_output_format() c_uint;
pub extern fn setvbuf(noalias _File: [*c]FILE, noalias _Buf: [*c]u8, _Mode: c_int, _Size: usize) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/stdio.h:741:15: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _scprintf(noalias _Format: [*c]const u8, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/stdio.h:752:15: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _snscanf(noalias _Src: [*c]const u8, _MaxCount: usize, noalias _Format: [*c]const u8, ...) c_int;
pub extern fn _vscprintf(noalias _Format: [*c]const u8, _ArgList: va_list) c_int;
pub extern fn tmpfile() [*c]FILE;
pub extern fn tmpnam(_Buffer: [*c]u8) [*c]u8;
pub extern fn ungetc(_Ch: c_int, _File: [*c]FILE) c_int;
pub extern fn _vsnprintf(noalias _Dest: [*c]u8, _Count: usize, noalias _Format: [*c]const u8, _Args: va_list) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/stdio.h:780:15: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _snprintf(noalias _Dest: [*c]u8, _Count: usize, noalias _Format: [*c]const u8, ...) c_int;
pub extern fn vsnprintf(__stream: [*c]u8, __n: c_ulonglong, __format: [*c]const u8, __local_argv: __builtin_va_list) c_int;
pub extern fn snprintf(__stream: [*c]u8, __n: c_ulonglong, __format: [*c]const u8, ...) c_int;
pub extern fn _set_printf_count_output(_Value: c_int) c_int;
pub extern fn _get_printf_count_output() c_int;
pub extern fn __mingw_swscanf(noalias _Src: [*c]const wchar_t, noalias _Format: [*c]const wchar_t, ...) c_int;
pub extern fn __mingw_vswscanf(noalias _Str: [*c]const wchar_t, noalias Format: [*c]const wchar_t, argp: va_list) c_int;
pub extern fn __mingw_wscanf(noalias _Format: [*c]const wchar_t, ...) c_int;
pub extern fn __mingw_vwscanf(noalias Format: [*c]const wchar_t, argp: va_list) c_int;
pub extern fn __mingw_fwscanf(noalias _File: [*c]FILE, noalias _Format: [*c]const wchar_t, ...) c_int;
pub extern fn __mingw_vfwscanf(noalias fp: [*c]FILE, noalias Format: [*c]const wchar_t, argp: va_list) c_int;
pub extern fn __mingw_fwprintf(noalias _File: [*c]FILE, noalias _Format: [*c]const wchar_t, ...) c_int;
pub extern fn __mingw_wprintf(noalias _Format: [*c]const wchar_t, ...) c_int;
pub extern fn __mingw_vfwprintf(noalias _File: [*c]FILE, noalias _Format: [*c]const wchar_t, _ArgList: va_list) c_int;
pub extern fn __mingw_vwprintf(noalias _Format: [*c]const wchar_t, _ArgList: va_list) c_int;
pub extern fn __mingw_snwprintf(noalias s: [*c]wchar_t, n: usize, noalias format: [*c]const wchar_t, ...) c_int;
pub extern fn __mingw_vsnwprintf(noalias [*c]wchar_t, usize, noalias [*c]const wchar_t, va_list) c_int;
pub extern fn __mingw_swprintf(noalias [*c]wchar_t, noalias [*c]const wchar_t, ...) c_int;
pub extern fn __mingw_vswprintf(noalias [*c]wchar_t, noalias [*c]const wchar_t, va_list) c_int;
pub extern fn __ms_swscanf(noalias _Src: [*c]const wchar_t, noalias _Format: [*c]const wchar_t, ...) c_int;
pub extern fn __ms_wscanf(noalias _Format: [*c]const wchar_t, ...) c_int;
pub extern fn __ms_fwscanf(noalias _File: [*c]FILE, noalias _Format: [*c]const wchar_t, ...) c_int;
pub extern fn __ms_fwprintf(noalias _File: [*c]FILE, noalias _Format: [*c]const wchar_t, ...) c_int;
pub extern fn __ms_wprintf(noalias _Format: [*c]const wchar_t, ...) c_int;
pub extern fn __ms_vfwprintf(noalias _File: [*c]FILE, noalias _Format: [*c]const wchar_t, _ArgList: va_list) c_int;
pub extern fn __ms_vwprintf(noalias _Format: [*c]const wchar_t, _ArgList: va_list) c_int;
pub extern fn __ms_swprintf(noalias [*c]wchar_t, noalias [*c]const wchar_t, ...) c_int;
pub extern fn __ms_vswprintf(noalias [*c]wchar_t, noalias [*c]const wchar_t, va_list) c_int;
pub extern fn __stdio_common_vswprintf(options: c_ulonglong, str: [*c]wchar_t, len: usize, format: [*c]const wchar_t, locale: _locale_t, valist: va_list) c_int;
pub extern fn __stdio_common_vfwprintf(options: c_ulonglong, file: [*c]FILE, format: [*c]const wchar_t, locale: _locale_t, valist: va_list) c_int;
pub extern fn __stdio_common_vswscanf(options: c_ulonglong, input: [*c]const wchar_t, length: usize, format: [*c]const wchar_t, locale: _locale_t, valist: va_list) c_int;
pub extern fn __stdio_common_vfwscanf(options: c_ulonglong, file: [*c]FILE, format: [*c]const wchar_t, locale: _locale_t, valist: va_list) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/stdio.h:1221:15: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn fwscanf(noalias _File: [*c]FILE, noalias _Format: [*c]const wchar_t, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/stdio.h:1231:15: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn swscanf(noalias _Src: [*c]const wchar_t, noalias _Format: [*c]const wchar_t, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/stdio.h:1241:15: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn wscanf(noalias _Format: [*c]const wchar_t, ...) c_int;
pub fn vfwscanf(arg___stream: [*c]FILE, arg___format: [*c]const wchar_t, arg___local_argv: va_list) callconv(.C) c_int {
    var __stream = arg___stream;
    _ = &__stream;
    var __format = arg___format;
    _ = &__format;
    var __local_argv = arg___local_argv;
    _ = &__local_argv;
    return __stdio_common_vfwscanf(@as(c_ulonglong, 2), __stream, __format, null, __local_argv);
}
pub fn vswscanf(noalias arg___source: [*c]const wchar_t, noalias arg___format: [*c]const wchar_t, arg___local_argv: va_list) callconv(.C) c_int {
    var __source = arg___source;
    _ = &__source;
    var __format = arg___format;
    _ = &__format;
    var __local_argv = arg___local_argv;
    _ = &__local_argv;
    return __stdio_common_vswscanf(@as(c_ulonglong, 2), __source, @as(usize, @bitCast(@as(c_longlong, -@as(c_int, 1)))), __format, null, __local_argv);
}
pub fn vwscanf(arg___format: [*c]const wchar_t, arg___local_argv: va_list) callconv(.C) c_int {
    var __format = arg___format;
    _ = &__format;
    var __local_argv = arg___local_argv;
    _ = &__local_argv;
    return __stdio_common_vfwscanf(@as(c_ulonglong, 2), __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 0)))), __format, null, __local_argv);
}
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/stdio.h:1271:15: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn fwprintf(noalias _File: [*c]FILE, noalias _Format: [*c]const wchar_t, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/stdio.h:1281:15: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn wprintf(noalias _Format: [*c]const wchar_t, ...) c_int;
pub fn vfwprintf(noalias arg__File: [*c]FILE, noalias arg__Format: [*c]const wchar_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _File = arg__File;
    _ = &_File;
    var _Format = arg__Format;
    _ = &_Format;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return __stdio_common_vfwprintf(@as(c_ulonglong, 4), _File, _Format, null, _ArgList);
}
pub fn vwprintf(noalias arg__Format: [*c]const wchar_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _Format = arg__Format;
    _ = &_Format;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return __stdio_common_vfwprintf(@as(c_ulonglong, 4), __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))), _Format, null, _ArgList);
}
pub extern fn _wfsopen(_Filename: [*c]const wchar_t, _Mode: [*c]const wchar_t, _ShFlag: c_int) [*c]FILE;
pub extern fn fgetwc(_File: [*c]FILE) wint_t;
pub extern fn _fgetwchar() wint_t;
pub extern fn fputwc(_Ch: wchar_t, _File: [*c]FILE) wint_t;
pub extern fn _fputwchar(_Ch: wchar_t) wint_t;
pub extern fn getwc(_File: [*c]FILE) wint_t;
pub extern fn getwchar() wint_t;
pub extern fn putwc(_Ch: wchar_t, _File: [*c]FILE) wint_t;
pub extern fn putwchar(_Ch: wchar_t) wint_t;
pub extern fn ungetwc(_Ch: wint_t, _File: [*c]FILE) wint_t;
pub extern fn fgetws(noalias _Dst: [*c]wchar_t, _SizeInWords: c_int, noalias _File: [*c]FILE) [*c]wchar_t;
pub extern fn fputws(noalias _Str: [*c]const wchar_t, noalias _File: [*c]FILE) c_int;
pub extern fn _getws(_String: [*c]wchar_t) [*c]wchar_t;
pub extern fn _putws(_Str: [*c]const wchar_t) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/stdio.h:1365:15: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _scwprintf(noalias _Format: [*c]const wchar_t, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/stdio.h:1375:15: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _snwprintf(noalias _Dest: [*c]wchar_t, _Count: usize, noalias _Format: [*c]const wchar_t, ...) c_int;
pub extern fn _vsnwprintf(noalias _Dest: [*c]wchar_t, _Count: usize, noalias _Format: [*c]const wchar_t, _Args: va_list) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/stdio.h:1388:7: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn snwprintf(noalias s: [*c]wchar_t, n: usize, noalias format: [*c]const wchar_t, ...) c_int;
pub fn vsnwprintf(noalias arg_s: [*c]wchar_t, arg_n: usize, noalias arg_format: [*c]const wchar_t, arg_arg: va_list) callconv(.C) c_int {
    var s = arg_s;
    _ = &s;
    var n = arg_n;
    _ = &n;
    var format = arg_format;
    _ = &format;
    var arg = arg_arg;
    _ = &arg;
    var __ret: c_int = __stdio_common_vswprintf(@as(c_ulonglong, 4), s, n, format, null, arg);
    _ = &__ret;
    return if (__ret < @as(c_int, 0)) -@as(c_int, 1) else __ret;
}
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/stdio.h:1406:15: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _swprintf(noalias _Dest: [*c]wchar_t, noalias _Format: [*c]const wchar_t, ...) c_int;
pub fn _vswprintf(noalias arg__Dest: [*c]wchar_t, noalias arg__Format: [*c]const wchar_t, arg__Args: va_list) callconv(.C) c_int {
    var _Dest = arg__Dest;
    _ = &_Dest;
    var _Format = arg__Format;
    _ = &_Format;
    var _Args = arg__Args;
    _ = &_Args;
    return __stdio_common_vswprintf(@as(c_ulonglong, 4), _Dest, @as(usize, @bitCast(@as(c_longlong, -@as(c_int, 1)))), _Format, null, _Args);
}
pub fn _vscwprintf(noalias arg__Format: [*c]const wchar_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _Format = arg__Format;
    _ = &_Format;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    var _Result: c_int = __stdio_common_vswprintf(@as(c_ulonglong, 2), null, @as(usize, @bitCast(@as(c_longlong, @as(c_int, 0)))), _Format, null, _ArgList);
    _ = &_Result;
    return if (_Result < @as(c_int, 0)) -@as(c_int, 1) else _Result;
}
pub fn vswprintf(arg___stream: [*c]wchar_t, arg___count: usize, arg___format: [*c]const wchar_t, arg___local_argv: __builtin_va_list) callconv(.C) c_int {
    var __stream = arg___stream;
    _ = &__stream;
    var __count = arg___count;
    _ = &__count;
    var __format = arg___format;
    _ = &__format;
    var __local_argv = arg___local_argv;
    _ = &__local_argv;
    return vsnwprintf(__stream, __count, __format, __local_argv);
}
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/swprintf.inl:34:5: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn swprintf(__stream: [*c]wchar_t, __count: usize, __format: [*c]const wchar_t, ...) c_int;
pub extern fn _wtempnam(_Directory: [*c]const wchar_t, _FilePrefix: [*c]const wchar_t) [*c]wchar_t;
pub extern fn _snwscanf(noalias _Src: [*c]const wchar_t, _MaxCount: usize, noalias _Format: [*c]const wchar_t, ...) c_int;
pub extern fn _wfdopen(_FileHandle: c_int, _Mode: [*c]const wchar_t) [*c]FILE;
pub extern fn _wfopen(noalias _Filename: [*c]const wchar_t, noalias _Mode: [*c]const wchar_t) [*c]FILE;
pub extern fn _wfreopen(noalias _Filename: [*c]const wchar_t, noalias _Mode: [*c]const wchar_t, noalias _OldFile: [*c]FILE) [*c]FILE;
pub extern fn _wperror(_ErrMsg: [*c]const wchar_t) void;
pub extern fn _wpopen(_Command: [*c]const wchar_t, _Mode: [*c]const wchar_t) [*c]FILE;
pub extern fn _wremove(_Filename: [*c]const wchar_t) c_int;
pub extern fn _wtmpnam(_Buffer: [*c]wchar_t) [*c]wchar_t;
pub extern fn _fgetwc_nolock(_File: [*c]FILE) wint_t;
pub extern fn _fputwc_nolock(_Ch: wchar_t, _File: [*c]FILE) wint_t;
pub extern fn _ungetwc_nolock(_Ch: wint_t, _File: [*c]FILE) wint_t;
pub extern fn _fgetc_nolock(_File: [*c]FILE) c_int;
pub extern fn _fputc_nolock(_Char: c_int, _File: [*c]FILE) c_int;
pub extern fn _getc_nolock(_File: [*c]FILE) c_int;
pub extern fn _putc_nolock(_Char: c_int, _File: [*c]FILE) c_int;
pub extern fn _lock_file(_File: [*c]FILE) void;
pub extern fn _unlock_file(_File: [*c]FILE) void;
pub extern fn _fclose_nolock(_File: [*c]FILE) c_int;
pub extern fn _fflush_nolock(_File: [*c]FILE) c_int;
pub extern fn _fread_nolock(noalias _DstBuf: ?*anyopaque, _ElementSize: usize, _Count: usize, noalias _File: [*c]FILE) usize;
pub extern fn _fseek_nolock(_File: [*c]FILE, _Offset: c_long, _Origin: c_int) c_int;
pub extern fn _ftell_nolock(_File: [*c]FILE) c_long;
pub extern fn _fseeki64_nolock(_File: [*c]FILE, _Offset: c_longlong, _Origin: c_int) c_int;
pub extern fn _ftelli64_nolock(_File: [*c]FILE) c_longlong;
pub extern fn _fwrite_nolock(noalias _DstBuf: ?*const anyopaque, _Size: usize, _Count: usize, noalias _File: [*c]FILE) usize;
pub extern fn _ungetc_nolock(_Ch: c_int, _File: [*c]FILE) c_int;
pub extern fn tempnam(_Directory: [*c]const u8, _FilePrefix: [*c]const u8) [*c]u8;
pub extern fn fcloseall() c_int;
pub extern fn fdopen(_FileHandle: c_int, _Format: [*c]const u8) [*c]FILE;
pub extern fn fgetchar() c_int;
pub extern fn fileno(_File: [*c]FILE) c_int;
pub extern fn flushall() c_int;
pub extern fn fputchar(_Ch: c_int) c_int;
pub extern fn getw(_File: [*c]FILE) c_int;
pub extern fn putw(_Ch: c_int, _File: [*c]FILE) c_int;
pub extern fn rmtmp() c_int;
pub extern fn __mingw_str_wide_utf8(wptr: [*c]const wchar_t, mbptr: [*c][*c]u8, buflen: [*c]usize) c_int;
pub extern fn __mingw_str_utf8_wide(mbptr: [*c]const u8, wptr: [*c][*c]wchar_t, buflen: [*c]usize) c_int;
pub extern fn __mingw_str_free(ptr: ?*anyopaque) void;
pub extern fn clearerr_s(_File: [*c]FILE) errno_t;
pub extern fn fread_s(_DstBuf: ?*anyopaque, _DstSize: usize, _ElementSize: usize, _Count: usize, _File: [*c]FILE) usize;
pub extern fn __stdio_common_vsprintf_s(_Options: c_ulonglong, _Str: [*c]u8, _Len: usize, _Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int;
pub extern fn __stdio_common_vsprintf_p(_Options: c_ulonglong, _Str: [*c]u8, _Len: usize, _Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int;
pub extern fn __stdio_common_vsnprintf_s(_Options: c_ulonglong, _Str: [*c]u8, _Len: usize, _MaxCount: usize, _Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int;
pub extern fn __stdio_common_vfprintf_s(_Options: c_ulonglong, _File: [*c]FILE, _Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int;
pub extern fn __stdio_common_vfprintf_p(_Options: c_ulonglong, _File: [*c]FILE, _Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int;
pub fn _vfscanf_s_l(arg__File: [*c]FILE, arg__Format: [*c]const u8, arg__Locale: _locale_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _File = arg__File;
    _ = &_File;
    var _Format = arg__Format;
    _ = &_Format;
    var _Locale = arg__Locale;
    _ = &_Locale;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return __stdio_common_vfscanf(@as(c_ulonglong, 1), _File, _Format, _Locale, _ArgList);
}
pub fn vfscanf_s(arg__File: [*c]FILE, arg__Format: [*c]const u8, arg__ArgList: va_list) callconv(.C) c_int {
    var _File = arg__File;
    _ = &_File;
    var _Format = arg__Format;
    _ = &_Format;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return _vfscanf_s_l(_File, _Format, null, _ArgList);
}
pub fn _vscanf_s_l(arg__Format: [*c]const u8, arg__Locale: _locale_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _Format = arg__Format;
    _ = &_Format;
    var _Locale = arg__Locale;
    _ = &_Locale;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return _vfscanf_s_l(__acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 0)))), _Format, _Locale, _ArgList);
}
pub fn vscanf_s(arg__Format: [*c]const u8, arg__ArgList: va_list) callconv(.C) c_int {
    var _Format = arg__Format;
    _ = &_Format;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return _vfscanf_s_l(__acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 0)))), _Format, null, _ArgList);
}
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:60:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _fscanf_s_l(_File: [*c]FILE, _Format: [*c]const u8, _Locale: _locale_t, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:70:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn fscanf_s(_File: [*c]FILE, _Format: [*c]const u8, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:80:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _scanf_s_l(_Format: [*c]const u8, _Locale: _locale_t, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:90:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn scanf_s(_Format: [*c]const u8, ...) c_int;
pub fn _vfscanf_l(arg__File: [*c]FILE, arg__Format: [*c]const u8, arg__Locale: _locale_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _File = arg__File;
    _ = &_File;
    var _Format = arg__Format;
    _ = &_Format;
    var _Locale = arg__Locale;
    _ = &_Locale;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return __stdio_common_vfscanf(@as(c_ulonglong, @bitCast(@as(c_longlong, @as(c_int, 0)))), _File, _Format, _Locale, _ArgList);
}
pub fn _vscanf_l(arg__Format: [*c]const u8, arg__Locale: _locale_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _Format = arg__Format;
    _ = &_Format;
    var _Locale = arg__Locale;
    _ = &_Locale;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return _vfscanf_l(__acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 0)))), _Format, _Locale, _ArgList);
}
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:110:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _fscanf_l(_File: [*c]FILE, _Format: [*c]const u8, _Locale: _locale_t, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:119:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _scanf_l(_Format: [*c]const u8, _Locale: _locale_t, ...) c_int;
pub fn _vsscanf_s_l(arg__Src: [*c]const u8, arg__Format: [*c]const u8, arg__Locale: _locale_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _Src = arg__Src;
    _ = &_Src;
    var _Format = arg__Format;
    _ = &_Format;
    var _Locale = arg__Locale;
    _ = &_Locale;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return __stdio_common_vsscanf(@as(c_ulonglong, 1), _Src, @as(usize, @bitCast(@as(c_longlong, -@as(c_int, 1)))), _Format, _Locale, _ArgList);
}
pub fn vsscanf_s(arg__Src: [*c]const u8, arg__Format: [*c]const u8, arg__ArgList: va_list) callconv(.C) c_int {
    var _Src = arg__Src;
    _ = &_Src;
    var _Format = arg__Format;
    _ = &_Format;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return _vsscanf_s_l(_Src, _Format, null, _ArgList);
}
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:137:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _sscanf_s_l(_Src: [*c]const u8, _Format: [*c]const u8, _Locale: _locale_t, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:146:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn sscanf_s(_Src: [*c]const u8, _Format: [*c]const u8, ...) c_int;
pub fn _vsscanf_l(arg__Src: [*c]const u8, arg__Format: [*c]const u8, arg__Locale: _locale_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _Src = arg__Src;
    _ = &_Src;
    var _Format = arg__Format;
    _ = &_Format;
    var _Locale = arg__Locale;
    _ = &_Locale;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return __stdio_common_vsscanf(@as(c_ulonglong, @bitCast(@as(c_longlong, @as(c_int, 0)))), _Src, @as(usize, @bitCast(@as(c_longlong, -@as(c_int, 1)))), _Format, _Locale, _ArgList);
}
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:160:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _sscanf_l(_Src: [*c]const u8, _Format: [*c]const u8, _Locale: _locale_t, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:171:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _snscanf_s_l(_Src: [*c]const u8, _MaxCount: usize, _Format: [*c]const u8, _Locale: _locale_t, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:180:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _snscanf_s(_Src: [*c]const u8, _MaxCount: usize, _Format: [*c]const u8, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:191:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _snscanf_l(_Src: [*c]const u8, _MaxCount: usize, _Format: [*c]const u8, _Locale: _locale_t, ...) c_int;
pub fn _vfprintf_s_l(arg__File: [*c]FILE, arg__Format: [*c]const u8, arg__Locale: _locale_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _File = arg__File;
    _ = &_File;
    var _Format = arg__Format;
    _ = &_Format;
    var _Locale = arg__Locale;
    _ = &_Locale;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return __stdio_common_vfprintf_s(@as(c_ulonglong, @bitCast(@as(c_longlong, @as(c_int, 0)))), _File, _Format, _Locale, _ArgList);
}
pub fn vfprintf_s(arg__File: [*c]FILE, arg__Format: [*c]const u8, arg__ArgList: va_list) callconv(.C) c_int {
    var _File = arg__File;
    _ = &_File;
    var _Format = arg__Format;
    _ = &_Format;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return _vfprintf_s_l(_File, _Format, null, _ArgList);
}
pub fn _vprintf_s_l(arg__Format: [*c]const u8, arg__Locale: _locale_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _Format = arg__Format;
    _ = &_Format;
    var _Locale = arg__Locale;
    _ = &_Locale;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return _vfprintf_s_l(__acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))), _Format, _Locale, _ArgList);
}
pub fn vprintf_s(arg__Format: [*c]const u8, arg__ArgList: va_list) callconv(.C) c_int {
    var _Format = arg__Format;
    _ = &_Format;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return _vfprintf_s_l(__acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))), _Format, null, _ArgList);
}
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:218:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _fprintf_s_l(_File: [*c]FILE, _Format: [*c]const u8, _Locale: _locale_t, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:227:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _printf_s_l(_Format: [*c]const u8, _Locale: _locale_t, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:236:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn fprintf_s(_File: [*c]FILE, _Format: [*c]const u8, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:245:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn printf_s(_Format: [*c]const u8, ...) c_int;
pub fn _vsnprintf_c_l(arg__DstBuf: [*c]u8, arg__MaxCount: usize, arg__Format: [*c]const u8, arg__Locale: _locale_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _DstBuf = arg__DstBuf;
    _ = &_DstBuf;
    var _MaxCount = arg__MaxCount;
    _ = &_MaxCount;
    var _Format = arg__Format;
    _ = &_Format;
    var _Locale = arg__Locale;
    _ = &_Locale;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return __stdio_common_vsprintf(@as(c_ulonglong, @bitCast(@as(c_longlong, @as(c_int, 0)))), _DstBuf, _MaxCount, _Format, _Locale, _ArgList);
}
pub fn _vsnprintf_c(arg__DstBuf: [*c]u8, arg__MaxCount: usize, arg__Format: [*c]const u8, arg__ArgList: va_list) callconv(.C) c_int {
    var _DstBuf = arg__DstBuf;
    _ = &_DstBuf;
    var _MaxCount = arg__MaxCount;
    _ = &_MaxCount;
    var _Format = arg__Format;
    _ = &_Format;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return _vsnprintf_c_l(_DstBuf, _MaxCount, _Format, null, _ArgList);
}
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:263:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _snprintf_c_l(_DstBuf: [*c]u8, _MaxCount: usize, _Format: [*c]const u8, _Locale: _locale_t, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:272:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _snprintf_c(_DstBuf: [*c]u8, _MaxCount: usize, _Format: [*c]const u8, ...) c_int;
pub fn _vsnprintf_s_l(arg__DstBuf: [*c]u8, arg__DstSize: usize, arg__MaxCount: usize, arg__Format: [*c]const u8, arg__Locale: _locale_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _DstBuf = arg__DstBuf;
    _ = &_DstBuf;
    var _DstSize = arg__DstSize;
    _ = &_DstSize;
    var _MaxCount = arg__MaxCount;
    _ = &_MaxCount;
    var _Format = arg__Format;
    _ = &_Format;
    var _Locale = arg__Locale;
    _ = &_Locale;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return __stdio_common_vsnprintf_s(@as(c_ulonglong, @bitCast(@as(c_longlong, @as(c_int, 0)))), _DstBuf, _DstSize, _MaxCount, _Format, _Locale, _ArgList);
}
pub fn vsnprintf_s(arg__DstBuf: [*c]u8, arg__DstSize: usize, arg__MaxCount: usize, arg__Format: [*c]const u8, arg__ArgList: va_list) callconv(.C) c_int {
    var _DstBuf = arg__DstBuf;
    _ = &_DstBuf;
    var _DstSize = arg__DstSize;
    _ = &_DstSize;
    var _MaxCount = arg__MaxCount;
    _ = &_MaxCount;
    var _Format = arg__Format;
    _ = &_Format;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return _vsnprintf_s_l(_DstBuf, _DstSize, _MaxCount, _Format, null, _ArgList);
}
pub fn _vsnprintf_s(arg__DstBuf: [*c]u8, arg__DstSize: usize, arg__MaxCount: usize, arg__Format: [*c]const u8, arg__ArgList: va_list) callconv(.C) c_int {
    var _DstBuf = arg__DstBuf;
    _ = &_DstBuf;
    var _DstSize = arg__DstSize;
    _ = &_DstSize;
    var _MaxCount = arg__MaxCount;
    _ = &_MaxCount;
    var _Format = arg__Format;
    _ = &_Format;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return _vsnprintf_s_l(_DstBuf, _DstSize, _MaxCount, _Format, null, _ArgList);
}
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:294:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _snprintf_s_l(_DstBuf: [*c]u8, _DstSize: usize, _MaxCount: usize, _Format: [*c]const u8, _Locale: _locale_t, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:303:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _snprintf_s(_DstBuf: [*c]u8, _DstSize: usize, _MaxCount: usize, _Format: [*c]const u8, ...) c_int;
pub fn _vsprintf_s_l(arg__DstBuf: [*c]u8, arg__DstSize: usize, arg__Format: [*c]const u8, arg__Locale: _locale_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _DstBuf = arg__DstBuf;
    _ = &_DstBuf;
    var _DstSize = arg__DstSize;
    _ = &_DstSize;
    var _Format = arg__Format;
    _ = &_Format;
    var _Locale = arg__Locale;
    _ = &_Locale;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return __stdio_common_vsprintf_s(@as(c_ulonglong, @bitCast(@as(c_longlong, @as(c_int, 0)))), _DstBuf, _DstSize, _Format, _Locale, _ArgList);
}
pub fn vsprintf_s(arg__DstBuf: [*c]u8, arg__Size: usize, arg__Format: [*c]const u8, arg__ArgList: va_list) callconv(.C) c_int {
    var _DstBuf = arg__DstBuf;
    _ = &_DstBuf;
    var _Size = arg__Size;
    _ = &_Size;
    var _Format = arg__Format;
    _ = &_Format;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return _vsprintf_s_l(_DstBuf, _Size, _Format, null, _ArgList);
}
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:321:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _sprintf_s_l(_DstBuf: [*c]u8, _DstSize: usize, _Format: [*c]const u8, _Locale: _locale_t, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:330:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn sprintf_s(_DstBuf: [*c]u8, _DstSize: usize, _Format: [*c]const u8, ...) c_int;
pub fn _vfprintf_p_l(arg__File: [*c]FILE, arg__Format: [*c]const u8, arg__Locale: _locale_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _File = arg__File;
    _ = &_File;
    var _Format = arg__Format;
    _ = &_Format;
    var _Locale = arg__Locale;
    _ = &_Locale;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return __stdio_common_vfprintf_p(@as(c_ulonglong, @bitCast(@as(c_longlong, @as(c_int, 0)))), _File, _Format, _Locale, _ArgList);
}
pub fn _vfprintf_p(arg__File: [*c]FILE, arg__Format: [*c]const u8, arg__ArgList: va_list) callconv(.C) c_int {
    var _File = arg__File;
    _ = &_File;
    var _Format = arg__Format;
    _ = &_Format;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return _vfprintf_p_l(_File, _Format, null, _ArgList);
}
pub fn _vprintf_p_l(arg__Format: [*c]const u8, arg__Locale: _locale_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _Format = arg__Format;
    _ = &_Format;
    var _Locale = arg__Locale;
    _ = &_Locale;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return _vfprintf_p_l(__acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))), _Format, _Locale, _ArgList);
}
pub fn _vprintf_p(arg__Format: [*c]const u8, arg__ArgList: va_list) callconv(.C) c_int {
    var _Format = arg__Format;
    _ = &_Format;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return _vfprintf_p_l(__acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))), _Format, null, _ArgList);
}
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:356:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _fprintf_p_l(_File: [*c]FILE, _Format: [*c]const u8, _Locale: _locale_t, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:365:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _fprintf_p(_File: [*c]FILE, _Format: [*c]const u8, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:374:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _printf_p_l(_Format: [*c]const u8, _Locale: _locale_t, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:383:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _printf_p(_Format: [*c]const u8, ...) c_int;
pub fn _vsprintf_p_l(arg__DstBuf: [*c]u8, arg__MaxCount: usize, arg__Format: [*c]const u8, arg__Locale: _locale_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _DstBuf = arg__DstBuf;
    _ = &_DstBuf;
    var _MaxCount = arg__MaxCount;
    _ = &_MaxCount;
    var _Format = arg__Format;
    _ = &_Format;
    var _Locale = arg__Locale;
    _ = &_Locale;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return __stdio_common_vsprintf_p(@as(c_ulonglong, @bitCast(@as(c_longlong, @as(c_int, 0)))), _DstBuf, _MaxCount, _Format, _Locale, _ArgList);
}
pub fn _vsprintf_p(arg__Dst: [*c]u8, arg__MaxCount: usize, arg__Format: [*c]const u8, arg__ArgList: va_list) callconv(.C) c_int {
    var _Dst = arg__Dst;
    _ = &_Dst;
    var _MaxCount = arg__MaxCount;
    _ = &_MaxCount;
    var _Format = arg__Format;
    _ = &_Format;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return _vsprintf_p_l(_Dst, _MaxCount, _Format, null, _ArgList);
}
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:401:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _sprintf_p_l(_DstBuf: [*c]u8, _MaxCount: usize, _Format: [*c]const u8, _Locale: _locale_t, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:410:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _sprintf_p(_Dst: [*c]u8, _MaxCount: usize, _Format: [*c]const u8, ...) c_int;
pub fn _vscprintf_p_l(arg__Format: [*c]const u8, arg__Locale: _locale_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _Format = arg__Format;
    _ = &_Format;
    var _Locale = arg__Locale;
    _ = &_Locale;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return __stdio_common_vsprintf_p(@as(c_ulonglong, 2), null, @as(usize, @bitCast(@as(c_longlong, @as(c_int, 0)))), _Format, _Locale, _ArgList);
}
pub fn _vscprintf_p(arg__Format: [*c]const u8, arg__ArgList: va_list) callconv(.C) c_int {
    var _Format = arg__Format;
    _ = &_Format;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return _vscprintf_p_l(_Format, null, _ArgList);
}
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:428:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _scprintf_p_l(_Format: [*c]const u8, _Locale: _locale_t, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:437:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _scprintf_p(_Format: [*c]const u8, ...) c_int;
pub fn _vfprintf_l(arg__File: [*c]FILE, arg__Format: [*c]const u8, arg__Locale: _locale_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _File = arg__File;
    _ = &_File;
    var _Format = arg__Format;
    _ = &_Format;
    var _Locale = arg__Locale;
    _ = &_Locale;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return __stdio_common_vfprintf(@as(c_ulonglong, @bitCast(@as(c_longlong, @as(c_int, 0)))), _File, _Format, _Locale, _ArgList);
}
pub fn _vprintf_l(arg__Format: [*c]const u8, arg__Locale: _locale_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _Format = arg__Format;
    _ = &_Format;
    var _Locale = arg__Locale;
    _ = &_Locale;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return _vfprintf_l(__acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))), _Format, _Locale, _ArgList);
}
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:455:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _fprintf_l(_File: [*c]FILE, _Format: [*c]const u8, _Locale: _locale_t, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:464:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _printf_l(_Format: [*c]const u8, _Locale: _locale_t, ...) c_int;
pub fn _vsnprintf_l(arg__DstBuf: [*c]u8, arg__MaxCount: usize, arg__Format: [*c]const u8, arg__Locale: _locale_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _DstBuf = arg__DstBuf;
    _ = &_DstBuf;
    var _MaxCount = arg__MaxCount;
    _ = &_MaxCount;
    var _Format = arg__Format;
    _ = &_Format;
    var _Locale = arg__Locale;
    _ = &_Locale;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return __stdio_common_vsprintf(@as(c_ulonglong, 1), _DstBuf, _MaxCount, _Format, _Locale, _ArgList);
}
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:478:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _snprintf_l(_DstBuf: [*c]u8, _MaxCount: usize, _Format: [*c]const u8, _Locale: _locale_t, ...) c_int;
pub fn _vsprintf_l(arg__DstBuf: [*c]u8, arg__Format: [*c]const u8, arg__Locale: _locale_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _DstBuf = arg__DstBuf;
    _ = &_DstBuf;
    var _Format = arg__Format;
    _ = &_Format;
    var _Locale = arg__Locale;
    _ = &_Locale;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return _vsnprintf_l(_DstBuf, @as(usize, @bitCast(@as(c_longlong, -@as(c_int, 1)))), _Format, _Locale, _ArgList);
}
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:491:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _sprintf_l(_DstBuf: [*c]u8, _Format: [*c]const u8, _Locale: _locale_t, ...) c_int;
pub fn _vscprintf_l(arg__Format: [*c]const u8, arg__Locale: _locale_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _Format = arg__Format;
    _ = &_Format;
    var _Locale = arg__Locale;
    _ = &_Locale;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return __stdio_common_vsprintf(@as(c_ulonglong, 2), null, @as(usize, @bitCast(@as(c_longlong, @as(c_int, 0)))), _Format, _Locale, _ArgList);
}
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:505:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _scprintf_l(_Format: [*c]const u8, _Locale: _locale_t, ...) c_int;
pub extern fn fopen_s(_File: [*c][*c]FILE, _Filename: [*c]const u8, _Mode: [*c]const u8) errno_t;
pub extern fn freopen_s(_File: [*c][*c]FILE, _Filename: [*c]const u8, _Mode: [*c]const u8, _Stream: [*c]FILE) errno_t;
pub extern fn gets_s([*c]u8, rsize_t) [*c]u8;
pub extern fn tmpfile_s(_File: [*c][*c]FILE) errno_t;
pub extern fn tmpnam_s([*c]u8, rsize_t) errno_t;
pub extern fn _getws_s(_Str: [*c]wchar_t, _SizeInWords: usize) [*c]wchar_t;
pub extern fn __stdio_common_vswprintf_s(_Options: c_ulonglong, _Str: [*c]wchar_t, _Len: usize, _Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int;
pub extern fn __stdio_common_vsnwprintf_s(_Options: c_ulonglong, _Str: [*c]wchar_t, _Len: usize, _MaxCount: usize, _Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int;
pub extern fn __stdio_common_vfwprintf_s(_Options: c_ulonglong, _File: [*c]FILE, _Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int;
pub fn _vfwscanf_s_l(arg__File: [*c]FILE, arg__Format: [*c]const wchar_t, arg__Locale: _locale_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _File = arg__File;
    _ = &_File;
    var _Format = arg__Format;
    _ = &_Format;
    var _Locale = arg__Locale;
    _ = &_Locale;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return __stdio_common_vfwscanf(@as(c_ulonglong, 2) | @as(c_ulonglong, 1), _File, _Format, _Locale, _ArgList);
}
pub fn vfwscanf_s(arg__File: [*c]FILE, arg__Format: [*c]const wchar_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _File = arg__File;
    _ = &_File;
    var _Format = arg__Format;
    _ = &_Format;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return _vfwscanf_s_l(_File, _Format, null, _ArgList);
}
pub fn _vwscanf_s_l(arg__Format: [*c]const wchar_t, arg__Locale: _locale_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _Format = arg__Format;
    _ = &_Format;
    var _Locale = arg__Locale;
    _ = &_Locale;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return _vfwscanf_s_l(__acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 0)))), _Format, _Locale, _ArgList);
}
pub fn vwscanf_s(arg__Format: [*c]const wchar_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _Format = arg__Format;
    _ = &_Format;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return _vfwscanf_s_l(__acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 0)))), _Format, null, _ArgList);
}
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:631:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _fwscanf_s_l(_File: [*c]FILE, _Format: [*c]const wchar_t, _Locale: _locale_t, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:641:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn fwscanf_s(_File: [*c]FILE, _Format: [*c]const wchar_t, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:651:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _wscanf_s_l(_Format: [*c]const wchar_t, _Locale: _locale_t, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:661:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn wscanf_s(_Format: [*c]const wchar_t, ...) c_int;
pub fn _vswscanf_s_l(arg__Src: [*c]const wchar_t, arg__Format: [*c]const wchar_t, arg__Locale: _locale_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _Src = arg__Src;
    _ = &_Src;
    var _Format = arg__Format;
    _ = &_Format;
    var _Locale = arg__Locale;
    _ = &_Locale;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return __stdio_common_vswscanf(@as(c_ulonglong, 2) | @as(c_ulonglong, 1), _Src, @as(usize, @bitCast(@as(c_longlong, -@as(c_int, 1)))), _Format, _Locale, _ArgList);
}
pub fn vswscanf_s(arg__Src: [*c]const wchar_t, arg__Format: [*c]const wchar_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _Src = arg__Src;
    _ = &_Src;
    var _Format = arg__Format;
    _ = &_Format;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return _vswscanf_s_l(_Src, _Format, null, _ArgList);
}
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:681:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _swscanf_s_l(_Src: [*c]const wchar_t, _Format: [*c]const wchar_t, _Locale: _locale_t, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:690:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn swscanf_s(_Src: [*c]const wchar_t, _Format: [*c]const wchar_t, ...) c_int;
pub fn _vsnwscanf_s_l(arg__Src: [*c]const wchar_t, arg__MaxCount: usize, arg__Format: [*c]const wchar_t, arg__Locale: _locale_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _Src = arg__Src;
    _ = &_Src;
    var _MaxCount = arg__MaxCount;
    _ = &_MaxCount;
    var _Format = arg__Format;
    _ = &_Format;
    var _Locale = arg__Locale;
    _ = &_Locale;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return __stdio_common_vswscanf(@as(c_ulonglong, 2) | @as(c_ulonglong, 1), _Src, _MaxCount, _Format, _Locale, _ArgList);
}
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:704:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _snwscanf_s_l(_Src: [*c]const wchar_t, _MaxCount: usize, _Format: [*c]const wchar_t, _Locale: _locale_t, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:713:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _snwscanf_s(_Src: [*c]const wchar_t, _MaxCount: usize, _Format: [*c]const wchar_t, ...) c_int;
pub fn _vfwprintf_s_l(arg__File: [*c]FILE, arg__Format: [*c]const wchar_t, arg__Locale: _locale_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _File = arg__File;
    _ = &_File;
    var _Format = arg__Format;
    _ = &_Format;
    var _Locale = arg__Locale;
    _ = &_Locale;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return __stdio_common_vfwprintf_s(@as(c_ulonglong, 4), _File, _Format, _Locale, _ArgList);
}
pub fn _vwprintf_s_l(arg__Format: [*c]const wchar_t, arg__Locale: _locale_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _Format = arg__Format;
    _ = &_Format;
    var _Locale = arg__Locale;
    _ = &_Locale;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return _vfwprintf_s_l(__acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))), _Format, _Locale, _ArgList);
}
pub fn vfwprintf_s(arg__File: [*c]FILE, arg__Format: [*c]const wchar_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _File = arg__File;
    _ = &_File;
    var _Format = arg__Format;
    _ = &_Format;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return _vfwprintf_s_l(_File, _Format, null, _ArgList);
}
pub fn vwprintf_s(arg__Format: [*c]const wchar_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _Format = arg__Format;
    _ = &_Format;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return _vfwprintf_s_l(__acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))), _Format, null, _ArgList);
}
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:739:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _fwprintf_s_l(_File: [*c]FILE, _Format: [*c]const wchar_t, _Locale: _locale_t, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:748:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _wprintf_s_l(_Format: [*c]const wchar_t, _Locale: _locale_t, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:757:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn fwprintf_s(_File: [*c]FILE, _Format: [*c]const wchar_t, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:766:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn wprintf_s(_Format: [*c]const wchar_t, ...) c_int;
pub fn _vswprintf_s_l(arg__DstBuf: [*c]wchar_t, arg__DstSize: usize, arg__Format: [*c]const wchar_t, arg__Locale: _locale_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _DstBuf = arg__DstBuf;
    _ = &_DstBuf;
    var _DstSize = arg__DstSize;
    _ = &_DstSize;
    var _Format = arg__Format;
    _ = &_Format;
    var _Locale = arg__Locale;
    _ = &_Locale;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return __stdio_common_vswprintf_s(@as(c_ulonglong, 4), _DstBuf, _DstSize, _Format, _Locale, _ArgList);
}
pub fn vswprintf_s(arg__DstBuf: [*c]wchar_t, arg__DstSize: usize, arg__Format: [*c]const wchar_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _DstBuf = arg__DstBuf;
    _ = &_DstBuf;
    var _DstSize = arg__DstSize;
    _ = &_DstSize;
    var _Format = arg__Format;
    _ = &_Format;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return _vswprintf_s_l(_DstBuf, _DstSize, _Format, null, _ArgList);
}
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:784:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _swprintf_s_l(_DstBuf: [*c]wchar_t, _DstSize: usize, _Format: [*c]const wchar_t, _Locale: _locale_t, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:793:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn swprintf_s(_DstBuf: [*c]wchar_t, _DstSize: usize, _Format: [*c]const wchar_t, ...) c_int;
pub fn _vsnwprintf_s_l(arg__DstBuf: [*c]wchar_t, arg__DstSize: usize, arg__MaxCount: usize, arg__Format: [*c]const wchar_t, arg__Locale: _locale_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _DstBuf = arg__DstBuf;
    _ = &_DstBuf;
    var _DstSize = arg__DstSize;
    _ = &_DstSize;
    var _MaxCount = arg__MaxCount;
    _ = &_MaxCount;
    var _Format = arg__Format;
    _ = &_Format;
    var _Locale = arg__Locale;
    _ = &_Locale;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return __stdio_common_vsnwprintf_s(@as(c_ulonglong, 4), _DstBuf, _DstSize, _MaxCount, _Format, _Locale, _ArgList);
}
pub fn _vsnwprintf_s(arg__DstBuf: [*c]wchar_t, arg__DstSize: usize, arg__MaxCount: usize, arg__Format: [*c]const wchar_t, arg__ArgList: va_list) callconv(.C) c_int {
    var _DstBuf = arg__DstBuf;
    _ = &_DstBuf;
    var _DstSize = arg__DstSize;
    _ = &_DstSize;
    var _MaxCount = arg__MaxCount;
    _ = &_MaxCount;
    var _Format = arg__Format;
    _ = &_Format;
    var _ArgList = arg__ArgList;
    _ = &_ArgList;
    return _vsnwprintf_s_l(_DstBuf, _DstSize, _MaxCount, _Format, null, _ArgList);
}
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:811:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _snwprintf_s_l(_DstBuf: [*c]wchar_t, _DstSize: usize, _MaxCount: usize, _Format: [*c]const wchar_t, _Locale: _locale_t, ...) c_int;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/sec_api/stdio_s.h:820:27: warning: TODO unable to translate variadic function, demoted to extern
pub extern fn _snwprintf_s(_DstBuf: [*c]wchar_t, _DstSize: usize, _MaxCount: usize, _Format: [*c]const wchar_t, ...) c_int;
pub extern fn _wfopen_s(_File: [*c][*c]FILE, _Filename: [*c]const wchar_t, _Mode: [*c]const wchar_t) errno_t;
pub extern fn _wfreopen_s(_File: [*c][*c]FILE, _Filename: [*c]const wchar_t, _Mode: [*c]const wchar_t, _OldFile: [*c]FILE) errno_t;
pub extern fn _wtmpnam_s(_DstBuf: [*c]wchar_t, _SizeInWords: usize) errno_t;
pub extern fn _fread_nolock_s(_DstBuf: ?*anyopaque, _DstSize: usize, _ElementSize: usize, _Count: usize, _File: [*c]FILE) usize;
pub extern fn _itow_s(_Val: c_int, _DstBuf: [*c]wchar_t, _SizeInWords: usize, _Radix: c_int) errno_t;
pub extern fn _ltow_s(_Val: c_long, _DstBuf: [*c]wchar_t, _SizeInWords: usize, _Radix: c_int) errno_t;
pub extern fn _ultow_s(_Val: c_ulong, _DstBuf: [*c]wchar_t, _SizeInWords: usize, _Radix: c_int) errno_t;
pub extern fn _wgetenv_s(_ReturnSize: [*c]usize, _DstBuf: [*c]wchar_t, _DstSizeInWords: usize, _VarName: [*c]const wchar_t) errno_t;
pub extern fn _wdupenv_s(_Buffer: [*c][*c]wchar_t, _BufferSizeInWords: [*c]usize, _VarName: [*c]const wchar_t) errno_t;
pub extern fn _i64tow_s(_Val: c_longlong, _DstBuf: [*c]wchar_t, _SizeInWords: usize, _Radix: c_int) errno_t;
pub extern fn _ui64tow_s(_Val: c_ulonglong, _DstBuf: [*c]wchar_t, _SizeInWords: usize, _Radix: c_int) errno_t;
pub extern fn _wmakepath_s(_PathResult: [*c]wchar_t, _SizeInWords: usize, _Drive: [*c]const wchar_t, _Dir: [*c]const wchar_t, _Filename: [*c]const wchar_t, _Ext: [*c]const wchar_t) errno_t;
pub extern fn _wputenv_s(_Name: [*c]const wchar_t, _Value: [*c]const wchar_t) errno_t;
pub extern fn _wsearchenv_s(_Filename: [*c]const wchar_t, _EnvVar: [*c]const wchar_t, _ResultPath: [*c]wchar_t, _SizeInWords: usize) errno_t;
pub extern fn _wsplitpath_s(_FullPath: [*c]const wchar_t, _Drive: [*c]wchar_t, _DriveSizeInWords: usize, _Dir: [*c]wchar_t, _DirSizeInWords: usize, _Filename: [*c]wchar_t, _FilenameSizeInWords: usize, _Ext: [*c]wchar_t, _ExtSizeInWords: usize) errno_t;
pub const struct__div_t = extern struct {
    quot: c_int = @import("std").mem.zeroes(c_int),
    rem: c_int = @import("std").mem.zeroes(c_int),
};
pub const div_t = struct__div_t;
pub const struct__ldiv_t = extern struct {
    quot: c_long = @import("std").mem.zeroes(c_long),
    rem: c_long = @import("std").mem.zeroes(c_long),
};
pub const ldiv_t = struct__ldiv_t;
pub const _LDOUBLE = extern struct {
    ld: [10]u8 = @import("std").mem.zeroes([10]u8),
};
pub const _CRT_DOUBLE = extern struct {
    x: f64 = @import("std").mem.zeroes(f64),
};
pub const _CRT_FLOAT = extern struct {
    f: f32 = @import("std").mem.zeroes(f32),
};
pub const _LONGDOUBLE = extern struct {
    x: c_longdouble = @import("std").mem.zeroes(c_longdouble),
};
pub const _LDBL12 = extern struct {
    ld12: [12]u8 = @import("std").mem.zeroes([12]u8),
};
pub extern fn ___mb_cur_max_func() c_int;
pub const _purecall_handler = ?*const fn () callconv(.C) void;
pub extern fn _set_purecall_handler(_Handler: _purecall_handler) _purecall_handler;
pub extern fn _get_purecall_handler() _purecall_handler;
pub const _invalid_parameter_handler = ?*const fn ([*c]const wchar_t, [*c]const wchar_t, [*c]const wchar_t, c_uint, usize) callconv(.C) void;
pub extern fn _set_invalid_parameter_handler(_Handler: _invalid_parameter_handler) _invalid_parameter_handler;
pub extern fn _get_invalid_parameter_handler() _invalid_parameter_handler;
pub extern fn _errno() [*c]c_int;
pub extern fn _set_errno(_Value: c_int) errno_t;
pub extern fn _get_errno(_Value: [*c]c_int) errno_t;
pub extern fn __doserrno() [*c]c_ulong;
pub extern fn _set_doserrno(_Value: c_ulong) errno_t;
pub extern fn _get_doserrno(_Value: [*c]c_ulong) errno_t;
pub extern fn __sys_errlist() [*c][*c]u8;
pub extern fn __sys_nerr() [*c]c_int;
pub extern fn __p___argv() [*c][*c][*c]u8;
pub extern fn __p__fmode() [*c]c_int;
pub extern fn __p___argc() [*c]c_int;
pub extern fn __p___wargv() [*c][*c][*c]wchar_t;
pub extern fn __p__environ() [*c][*c][*c]u8;
pub extern fn __p__wenviron() [*c][*c][*c]wchar_t;
pub extern fn __p__pgmptr() [*c][*c]u8;
pub extern fn __p__wpgmptr() [*c][*c]wchar_t;
pub extern fn _get_pgmptr(_Value: [*c][*c]u8) errno_t;
pub extern fn _get_wpgmptr(_Value: [*c][*c]wchar_t) errno_t;
pub extern fn _set_fmode(_Mode: c_int) errno_t;
pub extern fn _get_fmode(_PMode: [*c]c_int) errno_t;
pub extern fn _get_osplatform(_Value: [*c]c_uint) errno_t;
pub extern fn _get_osver(_Value: [*c]c_uint) errno_t;
pub extern fn _get_winver(_Value: [*c]c_uint) errno_t;
pub extern fn _get_winmajor(_Value: [*c]c_uint) errno_t;
pub extern fn _get_winminor(_Value: [*c]c_uint) errno_t;
pub extern fn _set_abort_behavior(_Flags: c_uint, _Mask: c_uint) c_uint;
pub extern fn abs(_X: c_int) c_int;
pub extern fn labs(_X: c_long) c_long;
pub inline fn _abs64(arg_x: c_longlong) c_longlong {
    var x = arg_x;
    _ = &x;
    return __builtin_llabs(x);
}
pub extern fn atexit(?*const fn () callconv(.C) void) c_int;
pub extern fn at_quick_exit(?*const fn () callconv(.C) void) c_int;
pub extern fn atof(_String: [*c]const u8) f64;
pub extern fn _atof_l(_String: [*c]const u8, _Locale: _locale_t) f64;
pub extern fn atoi(_Str: [*c]const u8) c_int;
pub extern fn _atoi_l(_Str: [*c]const u8, _Locale: _locale_t) c_int;
pub extern fn atol(_Str: [*c]const u8) c_long;
pub extern fn _atol_l(_Str: [*c]const u8, _Locale: _locale_t) c_long;
pub extern fn bsearch(_Key: ?*const anyopaque, _Base: ?*const anyopaque, _NumOfElements: usize, _SizeOfElements: usize, _PtFuncCompare: ?*const fn (?*const anyopaque, ?*const anyopaque) callconv(.C) c_int) ?*anyopaque;
pub extern fn qsort(_Base: ?*anyopaque, _NumOfElements: usize, _SizeOfElements: usize, _PtFuncCompare: ?*const fn (?*const anyopaque, ?*const anyopaque) callconv(.C) c_int) void;
pub extern fn _byteswap_ushort(_Short: c_ushort) c_ushort;
pub extern fn _byteswap_ulong(_Long: c_ulong) c_ulong;
pub extern fn _byteswap_uint64(_Int64: c_ulonglong) c_ulonglong;
pub extern fn div(_Numerator: c_int, _Denominator: c_int) div_t;
pub extern fn getenv(_VarName: [*c]const u8) [*c]u8;
pub extern fn _itoa(_Value: c_int, _Dest: [*c]u8, _Radix: c_int) [*c]u8;
pub extern fn _i64toa(_Val: c_longlong, _DstBuf: [*c]u8, _Radix: c_int) [*c]u8;
pub extern fn _ui64toa(_Val: c_ulonglong, _DstBuf: [*c]u8, _Radix: c_int) [*c]u8;
pub extern fn _atoi64(_String: [*c]const u8) c_longlong;
pub extern fn _atoi64_l(_String: [*c]const u8, _Locale: _locale_t) c_longlong;
pub extern fn _strtoi64(_String: [*c]const u8, _EndPtr: [*c][*c]u8, _Radix: c_int) c_longlong;
pub extern fn _strtoi64_l(_String: [*c]const u8, _EndPtr: [*c][*c]u8, _Radix: c_int, _Locale: _locale_t) c_longlong;
pub extern fn _strtoui64(_String: [*c]const u8, _EndPtr: [*c][*c]u8, _Radix: c_int) c_ulonglong;
pub extern fn _strtoui64_l(_String: [*c]const u8, _EndPtr: [*c][*c]u8, _Radix: c_int, _Locale: _locale_t) c_ulonglong;
pub extern fn ldiv(_Numerator: c_long, _Denominator: c_long) ldiv_t;
pub extern fn _ltoa(_Value: c_long, _Dest: [*c]u8, _Radix: c_int) [*c]u8;
pub extern fn mblen(_Ch: [*c]const u8, _MaxCount: usize) c_int;
pub extern fn _mblen_l(_Ch: [*c]const u8, _MaxCount: usize, _Locale: _locale_t) c_int;
pub extern fn _mbstrlen(_Str: [*c]const u8) usize;
pub extern fn _mbstrlen_l(_Str: [*c]const u8, _Locale: _locale_t) usize;
pub extern fn _mbstrnlen(_Str: [*c]const u8, _MaxCount: usize) usize;
pub extern fn _mbstrnlen_l(_Str: [*c]const u8, _MaxCount: usize, _Locale: _locale_t) usize;
pub extern fn mbtowc(noalias _DstCh: [*c]wchar_t, noalias _SrcCh: [*c]const u8, _SrcSizeInBytes: usize) c_int;
pub extern fn _mbtowc_l(noalias _DstCh: [*c]wchar_t, noalias _SrcCh: [*c]const u8, _SrcSizeInBytes: usize, _Locale: _locale_t) c_int;
pub extern fn mbstowcs(noalias _Dest: [*c]wchar_t, noalias _Source: [*c]const u8, _MaxCount: usize) usize;
pub extern fn _mbstowcs_l(noalias _Dest: [*c]wchar_t, noalias _Source: [*c]const u8, _MaxCount: usize, _Locale: _locale_t) usize;
pub extern fn mkstemp(template_name: [*c]u8) c_int;
pub extern fn rand() c_int;
pub extern fn _set_error_mode(_Mode: c_int) c_int;
pub extern fn srand(_Seed: c_uint) void;
pub extern fn strtod(_Str: [*c]const u8, _EndPtr: [*c][*c]u8) f64;
pub extern fn strtof(nptr: [*c]const u8, endptr: [*c][*c]u8) f32;
pub extern fn strtold([*c]const u8, [*c][*c]u8) c_longdouble;
pub extern fn __strtod(noalias [*c]const u8, noalias [*c][*c]u8) f64;
pub extern fn __mingw_strtof(noalias [*c]const u8, noalias [*c][*c]u8) f32;
pub extern fn __mingw_strtod(noalias [*c]const u8, noalias [*c][*c]u8) f64;
pub extern fn __mingw_strtold(noalias [*c]const u8, noalias [*c][*c]u8) c_longdouble;
pub extern fn _strtof_l(noalias _Str: [*c]const u8, noalias _EndPtr: [*c][*c]u8, _Locale: _locale_t) f32;
pub extern fn _strtod_l(noalias _Str: [*c]const u8, noalias _EndPtr: [*c][*c]u8, _Locale: _locale_t) f64;
pub extern fn strtol(_Str: [*c]const u8, _EndPtr: [*c][*c]u8, _Radix: c_int) c_long;
pub extern fn _strtol_l(noalias _Str: [*c]const u8, noalias _EndPtr: [*c][*c]u8, _Radix: c_int, _Locale: _locale_t) c_long;
pub extern fn strtoul(_Str: [*c]const u8, _EndPtr: [*c][*c]u8, _Radix: c_int) c_ulong;
pub extern fn _strtoul_l(noalias _Str: [*c]const u8, noalias _EndPtr: [*c][*c]u8, _Radix: c_int, _Locale: _locale_t) c_ulong;
pub extern fn _ultoa(_Value: c_ulong, _Dest: [*c]u8, _Radix: c_int) [*c]u8;
pub extern fn wctomb(_MbCh: [*c]u8, _WCh: wchar_t) c_int;
pub extern fn _wctomb_l(_MbCh: [*c]u8, _WCh: wchar_t, _Locale: _locale_t) c_int;
pub extern fn wcstombs(noalias _Dest: [*c]u8, noalias _Source: [*c]const wchar_t, _MaxCount: usize) usize;
pub extern fn _wcstombs_l(noalias _Dest: [*c]u8, noalias _Source: [*c]const wchar_t, _MaxCount: usize, _Locale: _locale_t) usize;
pub extern fn calloc(_NumOfElements: c_ulonglong, _SizeOfElements: c_ulonglong) ?*anyopaque;
pub extern fn free(_Memory: ?*anyopaque) void;
pub extern fn malloc(_Size: c_ulonglong) ?*anyopaque;
pub extern fn realloc(_Memory: ?*anyopaque, _NewSize: c_ulonglong) ?*anyopaque;
pub extern fn _aligned_free(_Memory: ?*anyopaque) void;
pub extern fn _aligned_malloc(_Size: usize, _Alignment: usize) ?*anyopaque;
pub extern fn _aligned_offset_malloc(_Size: usize, _Alignment: usize, _Offset: usize) ?*anyopaque;
pub extern fn _aligned_realloc(_Memory: ?*anyopaque, _Size: usize, _Alignment: usize) ?*anyopaque;
pub extern fn _aligned_offset_realloc(_Memory: ?*anyopaque, _Size: usize, _Alignment: usize, _Offset: usize) ?*anyopaque;
pub extern fn _recalloc(_Memory: ?*anyopaque, _Count: usize, _Size: usize) ?*anyopaque;
pub extern fn _aligned_recalloc(_Memory: ?*anyopaque, _Count: usize, _Size: usize, _Alignment: usize) ?*anyopaque;
pub extern fn _aligned_offset_recalloc(_Memory: ?*anyopaque, _Count: usize, _Size: usize, _Alignment: usize, _Offset: usize) ?*anyopaque;
pub extern fn _aligned_msize(_Memory: ?*anyopaque, _Alignment: usize, _Offset: usize) usize;
pub extern fn _itow(_Value: c_int, _Dest: [*c]wchar_t, _Radix: c_int) [*c]wchar_t;
pub extern fn _ltow(_Value: c_long, _Dest: [*c]wchar_t, _Radix: c_int) [*c]wchar_t;
pub extern fn _ultow(_Value: c_ulong, _Dest: [*c]wchar_t, _Radix: c_int) [*c]wchar_t;
pub extern fn __mingw_wcstod(noalias _Str: [*c]const wchar_t, noalias _EndPtr: [*c][*c]wchar_t) f64;
pub extern fn __mingw_wcstof(noalias nptr: [*c]const wchar_t, noalias endptr: [*c][*c]wchar_t) f32;
pub extern fn __mingw_wcstold(noalias [*c]const wchar_t, noalias [*c][*c]wchar_t) c_longdouble;
pub extern fn wcstod(noalias _Str: [*c]const wchar_t, noalias _EndPtr: [*c][*c]wchar_t) f64;
pub extern fn wcstof(noalias nptr: [*c]const wchar_t, noalias endptr: [*c][*c]wchar_t) f32;
pub extern fn wcstold(noalias [*c]const wchar_t, noalias [*c][*c]wchar_t) c_longdouble;
pub extern fn _wcstod_l(noalias _Str: [*c]const wchar_t, noalias _EndPtr: [*c][*c]wchar_t, _Locale: _locale_t) f64;
pub extern fn _wcstof_l(noalias _Str: [*c]const wchar_t, noalias _EndPtr: [*c][*c]wchar_t, _Locale: _locale_t) f32;
pub extern fn wcstol(noalias _Str: [*c]const wchar_t, noalias _EndPtr: [*c][*c]wchar_t, _Radix: c_int) c_long;
pub extern fn _wcstol_l(noalias _Str: [*c]const wchar_t, noalias _EndPtr: [*c][*c]wchar_t, _Radix: c_int, _Locale: _locale_t) c_long;
pub extern fn wcstoul(noalias _Str: [*c]const wchar_t, noalias _EndPtr: [*c][*c]wchar_t, _Radix: c_int) c_ulong;
pub extern fn _wcstoul_l(noalias _Str: [*c]const wchar_t, noalias _EndPtr: [*c][*c]wchar_t, _Radix: c_int, _Locale: _locale_t) c_ulong;
pub extern fn _wgetenv(_VarName: [*c]const wchar_t) [*c]wchar_t;
pub extern fn _wtof(_Str: [*c]const wchar_t) f64;
pub extern fn _wtof_l(_Str: [*c]const wchar_t, _Locale: _locale_t) f64;
pub extern fn _wtoi(_Str: [*c]const wchar_t) c_int;
pub extern fn _wtoi_l(_Str: [*c]const wchar_t, _Locale: _locale_t) c_int;
pub extern fn _wtol(_Str: [*c]const wchar_t) c_long;
pub extern fn _wtol_l(_Str: [*c]const wchar_t, _Locale: _locale_t) c_long;
pub extern fn _i64tow(_Val: c_longlong, _DstBuf: [*c]wchar_t, _Radix: c_int) [*c]wchar_t;
pub extern fn _ui64tow(_Val: c_ulonglong, _DstBuf: [*c]wchar_t, _Radix: c_int) [*c]wchar_t;
pub extern fn _wtoi64(_Str: [*c]const wchar_t) c_longlong;
pub extern fn _wtoi64_l(_Str: [*c]const wchar_t, _Locale: _locale_t) c_longlong;
pub extern fn _wcstoi64(_Str: [*c]const wchar_t, _EndPtr: [*c][*c]wchar_t, _Radix: c_int) c_longlong;
pub extern fn _wcstoi64_l(_Str: [*c]const wchar_t, _EndPtr: [*c][*c]wchar_t, _Radix: c_int, _Locale: _locale_t) c_longlong;
pub extern fn _wcstoui64(_Str: [*c]const wchar_t, _EndPtr: [*c][*c]wchar_t, _Radix: c_int) c_ulonglong;
pub extern fn _wcstoui64_l(_Str: [*c]const wchar_t, _EndPtr: [*c][*c]wchar_t, _Radix: c_int, _Locale: _locale_t) c_ulonglong;
pub extern fn _putenv(_EnvString: [*c]const u8) c_int;
pub extern fn _wputenv(_EnvString: [*c]const wchar_t) c_int;
pub extern fn _fullpath(_FullPath: [*c]u8, _Path: [*c]const u8, _SizeInBytes: usize) [*c]u8;
pub extern fn _ecvt(_Val: f64, _NumOfDigits: c_int, _PtDec: [*c]c_int, _PtSign: [*c]c_int) [*c]u8;
pub extern fn _fcvt(_Val: f64, _NumOfDec: c_int, _PtDec: [*c]c_int, _PtSign: [*c]c_int) [*c]u8;
pub extern fn _gcvt(_Val: f64, _NumOfDigits: c_int, _DstBuf: [*c]u8) [*c]u8;
pub extern fn _atodbl(_Result: [*c]_CRT_DOUBLE, _Str: [*c]u8) c_int;
pub extern fn _atoldbl(_Result: [*c]_LDOUBLE, _Str: [*c]u8) c_int;
pub extern fn _atoflt(_Result: [*c]_CRT_FLOAT, _Str: [*c]u8) c_int;
pub extern fn _atodbl_l(_Result: [*c]_CRT_DOUBLE, _Str: [*c]u8, _Locale: _locale_t) c_int;
pub extern fn _atoldbl_l(_Result: [*c]_LDOUBLE, _Str: [*c]u8, _Locale: _locale_t) c_int;
pub extern fn _atoflt_l(_Result: [*c]_CRT_FLOAT, _Str: [*c]u8, _Locale: _locale_t) c_int;
pub extern fn _lrotl(c_ulong, c_int) c_ulong;
pub extern fn _lrotr(c_ulong, c_int) c_ulong;
pub extern fn _makepath(_Path: [*c]u8, _Drive: [*c]const u8, _Dir: [*c]const u8, _Filename: [*c]const u8, _Ext: [*c]const u8) void;
pub extern fn _onexit(_Func: _onexit_t) _onexit_t;
pub extern fn _rotl64(_Val: c_ulonglong, _Shift: c_int) c_ulonglong;
pub extern fn _rotr64(Value: c_ulonglong, Shift: c_int) c_ulonglong;
pub extern fn _rotr(_Val: c_uint, _Shift: c_int) c_uint;
pub extern fn _rotl(_Val: c_uint, _Shift: c_int) c_uint;
pub extern fn _searchenv(_Filename: [*c]const u8, _EnvVar: [*c]const u8, _ResultPath: [*c]u8) void;
pub extern fn _splitpath(_FullPath: [*c]const u8, _Drive: [*c]u8, _Dir: [*c]u8, _Filename: [*c]u8, _Ext: [*c]u8) void;
pub extern fn _swab(_Buf1: [*c]u8, _Buf2: [*c]u8, _SizeInBytes: c_int) void;
pub extern fn _wfullpath(_FullPath: [*c]wchar_t, _Path: [*c]const wchar_t, _SizeInWords: usize) [*c]wchar_t;
pub extern fn _wmakepath(_ResultPath: [*c]wchar_t, _Drive: [*c]const wchar_t, _Dir: [*c]const wchar_t, _Filename: [*c]const wchar_t, _Ext: [*c]const wchar_t) void;
pub extern fn _wsearchenv(_Filename: [*c]const wchar_t, _EnvVar: [*c]const wchar_t, _ResultPath: [*c]wchar_t) void;
pub extern fn _wsplitpath(_FullPath: [*c]const wchar_t, _Drive: [*c]wchar_t, _Dir: [*c]wchar_t, _Filename: [*c]wchar_t, _Ext: [*c]wchar_t) void;
pub const _beep = @compileError("unable to resolve function type clang.TypeClass.MacroQualified");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/stdlib.h:686:24
pub const _seterrormode = @compileError("unable to resolve function type clang.TypeClass.MacroQualified");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/stdlib.h:688:24
pub const _sleep = @compileError("unable to resolve function type clang.TypeClass.MacroQualified");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/stdlib.h:689:24
pub extern fn ecvt(_Val: f64, _NumOfDigits: c_int, _PtDec: [*c]c_int, _PtSign: [*c]c_int) [*c]u8;
pub extern fn fcvt(_Val: f64, _NumOfDec: c_int, _PtDec: [*c]c_int, _PtSign: [*c]c_int) [*c]u8;
pub extern fn gcvt(_Val: f64, _NumOfDigits: c_int, _DstBuf: [*c]u8) [*c]u8;
pub extern fn itoa(_Val: c_int, _DstBuf: [*c]u8, _Radix: c_int) [*c]u8;
pub extern fn ltoa(_Val: c_long, _DstBuf: [*c]u8, _Radix: c_int) [*c]u8;
pub extern fn putenv(_EnvString: [*c]const u8) c_int;
pub extern fn ultoa(_Val: c_ulong, _Dstbuf: [*c]u8, _Radix: c_int) [*c]u8;
pub extern fn onexit(_Func: _onexit_t) _onexit_t;
pub const lldiv_t = extern struct {
    quot: c_longlong = @import("std").mem.zeroes(c_longlong),
    rem: c_longlong = @import("std").mem.zeroes(c_longlong),
};
pub extern fn lldiv(c_longlong, c_longlong) lldiv_t;
pub extern fn llabs(c_longlong) c_longlong;
pub extern fn strtoll([*c]const u8, [*c][*c]u8, c_int) c_longlong;
pub extern fn strtoull([*c]const u8, [*c][*c]u8, c_int) c_ulonglong;
pub extern fn atoll([*c]const u8) c_longlong;
pub extern fn wtoll([*c]const wchar_t) c_longlong;
pub extern fn lltoa(c_longlong, [*c]u8, c_int) [*c]u8;
pub extern fn ulltoa(c_ulonglong, [*c]u8, c_int) [*c]u8;
pub extern fn lltow(c_longlong, [*c]wchar_t, c_int) [*c]wchar_t;
pub extern fn ulltow(c_ulonglong, [*c]wchar_t, c_int) [*c]wchar_t;
pub extern fn bsearch_s(_Key: ?*const anyopaque, _Base: ?*const anyopaque, _NumOfElements: rsize_t, _SizeOfElements: rsize_t, _PtFuncCompare: ?*const fn (?*anyopaque, ?*const anyopaque, ?*const anyopaque) callconv(.C) c_int, _Context: ?*anyopaque) ?*anyopaque;
pub extern fn _dupenv_s(_PBuffer: [*c][*c]u8, _PBufferSizeInBytes: [*c]usize, _VarName: [*c]const u8) errno_t;
pub extern fn getenv_s(_ReturnSize: [*c]usize, _DstBuf: [*c]u8, _DstSize: rsize_t, _VarName: [*c]const u8) errno_t;
pub extern fn _itoa_s(_Value: c_int, _DstBuf: [*c]u8, _Size: usize, _Radix: c_int) errno_t;
pub extern fn _i64toa_s(_Val: c_longlong, _DstBuf: [*c]u8, _Size: usize, _Radix: c_int) errno_t;
pub extern fn _ui64toa_s(_Val: c_ulonglong, _DstBuf: [*c]u8, _Size: usize, _Radix: c_int) errno_t;
pub extern fn _ltoa_s(_Val: c_long, _DstBuf: [*c]u8, _Size: usize, _Radix: c_int) errno_t;
pub extern fn mbstowcs_s(_PtNumOfCharConverted: [*c]usize, _DstBuf: [*c]wchar_t, _SizeInWords: usize, _SrcBuf: [*c]const u8, _MaxCount: usize) errno_t;
pub extern fn _mbstowcs_s_l(_PtNumOfCharConverted: [*c]usize, _DstBuf: [*c]wchar_t, _SizeInWords: usize, _SrcBuf: [*c]const u8, _MaxCount: usize, _Locale: _locale_t) errno_t;
pub extern fn _ultoa_s(_Val: c_ulong, _DstBuf: [*c]u8, _Size: usize, _Radix: c_int) errno_t;
pub extern fn wctomb_s(_SizeConverted: [*c]c_int, _MbCh: [*c]u8, _SizeInBytes: rsize_t, _WCh: wchar_t) errno_t;
pub extern fn _wctomb_s_l(_SizeConverted: [*c]c_int, _MbCh: [*c]u8, _SizeInBytes: usize, _WCh: wchar_t, _Locale: _locale_t) errno_t;
pub extern fn wcstombs_s(_PtNumOfCharConverted: [*c]usize, _Dst: [*c]u8, _DstSizeInBytes: usize, _Src: [*c]const wchar_t, _MaxCountInBytes: usize) errno_t;
pub extern fn _wcstombs_s_l(_PtNumOfCharConverted: [*c]usize, _Dst: [*c]u8, _DstSizeInBytes: usize, _Src: [*c]const wchar_t, _MaxCountInBytes: usize, _Locale: _locale_t) errno_t;
pub extern fn _ecvt_s(_DstBuf: [*c]u8, _Size: usize, _Val: f64, _NumOfDights: c_int, _PtDec: [*c]c_int, _PtSign: [*c]c_int) errno_t;
pub extern fn _fcvt_s(_DstBuf: [*c]u8, _Size: usize, _Val: f64, _NumOfDec: c_int, _PtDec: [*c]c_int, _PtSign: [*c]c_int) errno_t;
pub extern fn _gcvt_s(_DstBuf: [*c]u8, _Size: usize, _Val: f64, _NumOfDigits: c_int) errno_t;
pub extern fn _makepath_s(_PathResult: [*c]u8, _Size: usize, _Drive: [*c]const u8, _Dir: [*c]const u8, _Filename: [*c]const u8, _Ext: [*c]const u8) errno_t;
pub extern fn _putenv_s(_Name: [*c]const u8, _Value: [*c]const u8) errno_t;
pub extern fn _searchenv_s(_Filename: [*c]const u8, _EnvVar: [*c]const u8, _ResultPath: [*c]u8, _SizeInBytes: usize) errno_t;
pub extern fn _splitpath_s(_FullPath: [*c]const u8, _Drive: [*c]u8, _DriveSize: usize, _Dir: [*c]u8, _DirSize: usize, _Filename: [*c]u8, _FilenameSize: usize, _Ext: [*c]u8, _ExtSize: usize) errno_t;
pub extern fn qsort_s(_Base: ?*anyopaque, _NumOfElements: usize, _SizeOfElements: usize, _PtFuncCompare: ?*const fn (?*anyopaque, ?*const anyopaque, ?*const anyopaque) callconv(.C) c_int, _Context: ?*anyopaque) void;
pub const struct__heapinfo = extern struct {
    _pentry: [*c]c_int = @import("std").mem.zeroes([*c]c_int),
    _size: usize = @import("std").mem.zeroes(usize),
    _useflag: c_int = @import("std").mem.zeroes(c_int),
};
pub const _HEAPINFO = struct__heapinfo;
pub extern var _amblksiz: c_uint;
pub extern fn __mingw_aligned_malloc(_Size: usize, _Alignment: usize) ?*anyopaque;
pub extern fn __mingw_aligned_free(_Memory: ?*anyopaque) void;
pub extern fn __mingw_aligned_offset_realloc(_Memory: ?*anyopaque, _Size: usize, _Alignment: usize, _Offset: usize) ?*anyopaque;
pub extern fn __mingw_aligned_realloc(_Memory: ?*anyopaque, _Size: usize, _Offset: usize) ?*anyopaque;
pub inline fn _mm_malloc(arg___size: usize, arg___align: usize) ?*anyopaque {
    var __size = arg___size;
    _ = &__size;
    var __align = arg___align;
    _ = &__align;
    if (__align == @as(usize, @bitCast(@as(c_longlong, @as(c_int, 1))))) {
        return malloc(__size);
    }
    if (!((__align & (__align -% @as(usize, @bitCast(@as(c_longlong, @as(c_int, 1)))))) != 0) and (__align < @sizeOf(?*anyopaque))) {
        __align = @sizeOf(?*anyopaque);
    }
    var __mallocedMemory: ?*anyopaque = undefined;
    _ = &__mallocedMemory;
    __mallocedMemory = __mingw_aligned_malloc(__size, __align);
    return __mallocedMemory;
}
pub inline fn _mm_free(arg___p: ?*anyopaque) void {
    var __p = arg___p;
    _ = &__p;
    __mingw_aligned_free(__p);
}
pub extern fn _resetstkoflw() c_int;
pub extern fn _set_malloc_crt_max_wait(_NewValue: c_ulong) c_ulong;
pub extern fn _expand(_Memory: ?*anyopaque, _NewSize: usize) ?*anyopaque;
pub extern fn _msize(_Memory: ?*anyopaque) usize;
pub extern fn _get_sbh_threshold() usize;
pub extern fn _set_sbh_threshold(_NewValue: usize) c_int;
pub extern fn _set_amblksiz(_Value: usize) errno_t;
pub extern fn _get_amblksiz(_Value: [*c]usize) errno_t;
pub extern fn _heapadd(_Memory: ?*anyopaque, _Size: usize) c_int;
pub extern fn _heapchk() c_int;
pub extern fn _heapmin() c_int;
pub extern fn _heapset(_Fill: c_uint) c_int;
pub extern fn _heapwalk(_EntryInfo: [*c]_HEAPINFO) c_int;
pub extern fn _heapused(_Used: [*c]usize, _Commit: [*c]usize) usize;
pub extern fn _get_heap_handle() isize;
pub fn _MarkAllocaS(arg__Ptr: ?*anyopaque, arg__Marker: c_uint) callconv(.C) ?*anyopaque {
    var _Ptr = arg__Ptr;
    _ = &_Ptr;
    var _Marker = arg__Marker;
    _ = &_Marker;
    if (_Ptr != null) {
        @as([*c]c_uint, @ptrCast(@alignCast(_Ptr))).* = _Marker;
        _Ptr = @as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(_Ptr))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16)))))));
    }
    return _Ptr;
}
pub fn _freea(arg__Memory: ?*anyopaque) callconv(.C) void {
    var _Memory = arg__Memory;
    _ = &_Memory;
    var _Marker: c_uint = undefined;
    _ = &_Marker;
    if (_Memory != null) {
        _Memory = @as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(_Memory))) - @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 16)))))));
        _Marker = @as([*c]c_uint, @ptrCast(@alignCast(_Memory))).*;
        if (_Marker == @as(c_uint, @bitCast(@as(c_int, 56797)))) {
            free(_Memory);
        }
    }
}
pub extern fn __pctype_func() [*c]c_ushort;
pub extern var __imp__wctype: [*c][*c]c_ushort;
pub extern var __imp__pwctype: [*c][*c]c_ushort;
pub const __newclmap: [*c]const u8 = @extern([*c]const u8, .{
    .name = "__newclmap",
});
pub const __newcumap: [*c]const u8 = @extern([*c]const u8, .{
    .name = "__newcumap",
});
pub extern var __ptlocinfo: pthreadlocinfo;
pub extern var __ptmbcinfo: pthreadmbcinfo;
pub extern var __globallocalestatus: c_int;
pub extern var __locale_changed: c_int;
pub extern var __initiallocinfo: struct_threadlocaleinfostruct;
pub extern var __initiallocalestructinfo: _locale_tstruct;
pub extern fn __updatetlocinfo() pthreadlocinfo;
pub extern fn __updatetmbcinfo() pthreadmbcinfo;
pub extern fn _isctype(_C: c_int, _Type: c_int) c_int;
pub extern fn _isctype_l(_C: c_int, _Type: c_int, _Locale: _locale_t) c_int;
pub extern fn isalpha(_C: c_int) c_int;
pub extern fn _isalpha_l(_C: c_int, _Locale: _locale_t) c_int;
pub extern fn isupper(_C: c_int) c_int;
pub extern fn _isupper_l(_C: c_int, _Locale: _locale_t) c_int;
pub extern fn islower(_C: c_int) c_int;
pub extern fn _islower_l(_C: c_int, _Locale: _locale_t) c_int;
pub extern fn isdigit(_C: c_int) c_int;
pub extern fn _isdigit_l(_C: c_int, _Locale: _locale_t) c_int;
pub extern fn isxdigit(_C: c_int) c_int;
pub extern fn _isxdigit_l(_C: c_int, _Locale: _locale_t) c_int;
pub extern fn isspace(_C: c_int) c_int;
pub extern fn _isspace_l(_C: c_int, _Locale: _locale_t) c_int;
pub extern fn ispunct(_C: c_int) c_int;
pub extern fn _ispunct_l(_C: c_int, _Locale: _locale_t) c_int;
pub extern fn isalnum(_C: c_int) c_int;
pub extern fn _isalnum_l(_C: c_int, _Locale: _locale_t) c_int;
pub extern fn isprint(_C: c_int) c_int;
pub extern fn _isprint_l(_C: c_int, _Locale: _locale_t) c_int;
pub extern fn isgraph(_C: c_int) c_int;
pub extern fn _isgraph_l(_C: c_int, _Locale: _locale_t) c_int;
pub extern fn iscntrl(_C: c_int) c_int;
pub extern fn _iscntrl_l(_C: c_int, _Locale: _locale_t) c_int;
pub extern fn toupper(_C: c_int) c_int;
pub extern fn tolower(_C: c_int) c_int;
pub extern fn _tolower(_C: c_int) c_int;
pub extern fn _tolower_l(_C: c_int, _Locale: _locale_t) c_int;
pub extern fn _toupper(_C: c_int) c_int;
pub extern fn _toupper_l(_C: c_int, _Locale: _locale_t) c_int;
pub extern fn __isascii(_C: c_int) c_int;
pub extern fn __toascii(_C: c_int) c_int;
pub extern fn __iscsymf(_C: c_int) c_int;
pub extern fn __iscsym(_C: c_int) c_int;
pub extern fn isblank(_C: c_int) c_int;
pub extern fn iswalpha(_C: wint_t) c_int;
pub extern fn _iswalpha_l(_C: wint_t, _Locale: _locale_t) c_int;
pub extern fn iswupper(_C: wint_t) c_int;
pub extern fn _iswupper_l(_C: wint_t, _Locale: _locale_t) c_int;
pub extern fn iswlower(_C: wint_t) c_int;
pub extern fn _iswlower_l(_C: wint_t, _Locale: _locale_t) c_int;
pub extern fn iswdigit(_C: wint_t) c_int;
pub extern fn _iswdigit_l(_C: wint_t, _Locale: _locale_t) c_int;
pub extern fn iswxdigit(_C: wint_t) c_int;
pub extern fn _iswxdigit_l(_C: wint_t, _Locale: _locale_t) c_int;
pub extern fn iswspace(_C: wint_t) c_int;
pub extern fn _iswspace_l(_C: wint_t, _Locale: _locale_t) c_int;
pub extern fn iswpunct(_C: wint_t) c_int;
pub extern fn _iswpunct_l(_C: wint_t, _Locale: _locale_t) c_int;
pub extern fn iswalnum(_C: wint_t) c_int;
pub extern fn _iswalnum_l(_C: wint_t, _Locale: _locale_t) c_int;
pub extern fn iswprint(_C: wint_t) c_int;
pub extern fn _iswprint_l(_C: wint_t, _Locale: _locale_t) c_int;
pub extern fn iswgraph(_C: wint_t) c_int;
pub extern fn _iswgraph_l(_C: wint_t, _Locale: _locale_t) c_int;
pub extern fn iswcntrl(_C: wint_t) c_int;
pub extern fn _iswcntrl_l(_C: wint_t, _Locale: _locale_t) c_int;
pub extern fn iswascii(_C: wint_t) c_int;
pub extern fn isleadbyte(_C: c_int) c_int;
pub extern fn _isleadbyte_l(_C: c_int, _Locale: _locale_t) c_int;
pub extern fn towupper(_C: wint_t) wint_t;
pub extern fn _towupper_l(_C: wint_t, _Locale: _locale_t) wint_t;
pub extern fn towlower(_C: wint_t) wint_t;
pub extern fn _towlower_l(_C: wint_t, _Locale: _locale_t) wint_t;
pub extern fn iswctype(_C: wint_t, _Type: wctype_t) c_int;
pub extern fn _iswctype_l(_C: wint_t, _Type: wctype_t, _Locale: _locale_t) c_int;
pub extern fn __iswcsymf(_C: wint_t) c_int;
pub extern fn _iswcsymf_l(_C: wint_t, _Locale: _locale_t) c_int;
pub extern fn __iswcsym(_C: wint_t) c_int;
pub extern fn _iswcsym_l(_C: wint_t, _Locale: _locale_t) c_int;
pub extern fn is_wctype(_C: wint_t, _Type: wctype_t) c_int;
pub extern fn iswblank(_C: wint_t) c_int;
pub extern fn Globals_assert(b: bool, message: [*c]u8) void;
pub extern fn Globals_Hash(data: [*c]c_long, pieces: c_int) c_long;
pub extern fn myrand() c_int;
pub extern fn mysrand(seed: c_uint) void;
pub const struct__exception = extern struct {
    type: c_int = @import("std").mem.zeroes(c_int),
    name: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    arg1: f64 = @import("std").mem.zeroes(f64),
    arg2: f64 = @import("std").mem.zeroes(f64),
    retval: f64 = @import("std").mem.zeroes(f64),
};
const struct_unnamed_1 = extern struct {
    low: c_uint = @import("std").mem.zeroes(c_uint),
    high: c_uint = @import("std").mem.zeroes(c_uint),
};
pub const union___mingw_dbl_type_t = extern union {
    x: f64,
    val: c_ulonglong,
    lh: struct_unnamed_1,
};
pub const __mingw_dbl_type_t = union___mingw_dbl_type_t;
pub const union___mingw_flt_type_t = extern union {
    x: f32,
    val: c_uint,
};
pub const __mingw_flt_type_t = union___mingw_flt_type_t;
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/math.h:137:11: warning: struct demoted to opaque type - has bitfield
const struct_unnamed_2 = opaque {};
pub const union___mingw_ldbl_type_t = extern union {
    x: c_longdouble,
    lh: struct_unnamed_2,
};
pub const __mingw_ldbl_type_t = union___mingw_ldbl_type_t;
pub extern const _HUGE: f64;
pub extern fn __mingw_raise_matherr(typ: c_int, name: [*c]const u8, a1: f64, a2: f64, rslt: f64) void;
pub extern fn __mingw_setusermatherr(?*const fn ([*c]struct__exception) callconv(.C) c_int) void;
pub extern fn __setusermatherr(?*const fn ([*c]struct__exception) callconv(.C) c_int) void;
pub extern fn sin(_X: f64) f64;
pub extern fn cos(_X: f64) f64;
pub extern fn tan(_X: f64) f64;
pub extern fn sinh(_X: f64) f64;
pub extern fn cosh(_X: f64) f64;
pub extern fn tanh(_X: f64) f64;
pub extern fn asin(_X: f64) f64;
pub extern fn acos(_X: f64) f64;
pub extern fn atan(_X: f64) f64;
pub extern fn atan2(_Y: f64, _X: f64) f64;
pub extern fn exp(_X: f64) f64;
pub extern fn log(_X: f64) f64;
pub extern fn log10(_X: f64) f64;
pub extern fn pow(_X: f64, _Y: f64) f64;
pub extern fn sqrt(_X: f64) f64;
pub extern fn ceil(_X: f64) f64;
pub extern fn floor(_X: f64) f64;
pub extern fn fabsf(x: f32) f32;
pub extern fn fabsl(c_longdouble) c_longdouble;
pub extern fn fabs(_X: f64) f64;
pub extern fn ldexp(_X: f64, _Y: c_int) f64;
pub extern fn frexp(_X: f64, _Y: [*c]c_int) f64;
pub extern fn modf(_X: f64, _Y: [*c]f64) f64;
pub extern fn fmod(_X: f64, _Y: f64) f64;
pub extern fn sincos(__x: f64, p_sin: [*c]f64, p_cos: [*c]f64) void;
pub extern fn sincosl(__x: c_longdouble, p_sin: [*c]c_longdouble, p_cos: [*c]c_longdouble) void;
pub extern fn sincosf(__x: f32, p_sin: [*c]f32, p_cos: [*c]f32) void;
pub const struct__complex = extern struct {
    x: f64 = @import("std").mem.zeroes(f64),
    y: f64 = @import("std").mem.zeroes(f64),
};
pub extern fn _cabs(_ComplexA: struct__complex) f64;
pub extern fn _hypot(_X: f64, _Y: f64) f64;
pub extern fn _j0(_X: f64) f64;
pub extern fn _j1(_X: f64) f64;
pub extern fn _jn(_X: c_int, _Y: f64) f64;
pub extern fn _y0(_X: f64) f64;
pub extern fn _y1(_X: f64) f64;
pub extern fn _yn(_X: c_int, _Y: f64) f64;
pub extern fn _matherr([*c]struct__exception) c_int;
pub extern fn _chgsign(_X: f64) f64;
pub extern fn _copysign(_Number: f64, _Sign: f64) f64;
pub extern fn _logb(f64) f64;
pub extern fn _nextafter(f64, f64) f64;
pub extern fn _scalb(f64, c_long) f64;
pub extern fn _finite(f64) c_int;
pub extern fn _fpclass(f64) c_int;
pub extern fn _isnan(f64) c_int;
pub extern fn j0(f64) f64;
pub extern fn j1(f64) f64;
pub extern fn jn(c_int, f64) f64;
pub extern fn y0(f64) f64;
pub extern fn y1(f64) f64;
pub extern fn yn(c_int, f64) f64;
pub extern fn chgsign(f64) f64;
pub extern fn finite(f64) c_int;
pub extern fn fpclass(f64) c_int;
pub const float_t = f32;
pub const double_t = f64;
pub extern fn __fpclassifyl(c_longdouble) c_int;
pub extern fn __fpclassifyf(f32) c_int;
pub extern fn __fpclassify(f64) c_int;
pub extern fn __isnan(f64) c_int;
pub extern fn __isnanf(f32) c_int;
pub extern fn __isnanl(c_longdouble) c_int;
pub extern fn __signbit(f64) c_int;
pub extern fn __signbitf(f32) c_int;
pub extern fn __signbitl(c_longdouble) c_int;
pub extern fn sinf(_X: f32) f32;
pub extern fn sinl(c_longdouble) c_longdouble;
pub extern fn cosf(_X: f32) f32;
pub extern fn cosl(c_longdouble) c_longdouble;
pub extern fn tanf(_X: f32) f32;
pub extern fn tanl(c_longdouble) c_longdouble;
pub extern fn asinf(_X: f32) f32;
pub extern fn asinl(c_longdouble) c_longdouble;
pub extern fn acosf(f32) f32;
pub extern fn acosl(c_longdouble) c_longdouble;
pub extern fn atanf(f32) f32;
pub extern fn atanl(c_longdouble) c_longdouble;
pub extern fn atan2f(f32, f32) f32;
pub extern fn atan2l(c_longdouble, c_longdouble) c_longdouble;
pub extern fn sinhf(_X: f32) f32;
pub extern fn sinhl(c_longdouble) c_longdouble;
pub extern fn coshf(_X: f32) f32;
pub extern fn coshl(c_longdouble) c_longdouble;
pub extern fn tanhf(_X: f32) f32;
pub extern fn tanhl(c_longdouble) c_longdouble;
pub extern fn acosh(f64) f64;
pub extern fn acoshf(f32) f32;
pub extern fn acoshl(c_longdouble) c_longdouble;
pub extern fn asinh(f64) f64;
pub extern fn asinhf(f32) f32;
pub extern fn asinhl(c_longdouble) c_longdouble;
pub extern fn atanh(f64) f64;
pub extern fn atanhf(f32) f32;
pub extern fn atanhl(c_longdouble) c_longdouble;
pub extern fn expf(_X: f32) f32;
pub extern fn expl(c_longdouble) c_longdouble;
pub extern fn exp2(f64) f64;
pub extern fn exp2f(f32) f32;
pub extern fn exp2l(c_longdouble) c_longdouble;
pub extern fn expm1(f64) f64;
pub extern fn expm1f(f32) f32;
pub extern fn expm1l(c_longdouble) c_longdouble;
pub extern fn frexpf(_X: f32, _Y: [*c]c_int) f32;
pub extern fn frexpl(c_longdouble, [*c]c_int) c_longdouble;
pub extern fn ilogb(f64) c_int;
pub extern fn ilogbf(f32) c_int;
pub extern fn ilogbl(c_longdouble) c_int;
pub extern fn ldexpf(_X: f32, _Y: c_int) f32;
pub extern fn ldexpl(c_longdouble, c_int) c_longdouble;
pub extern fn logf(f32) f32;
pub extern fn logl(c_longdouble) c_longdouble;
pub extern fn log10f(f32) f32;
pub extern fn log10l(c_longdouble) c_longdouble;
pub extern fn log1p(f64) f64;
pub extern fn log1pf(f32) f32;
pub extern fn log1pl(c_longdouble) c_longdouble;
pub extern fn log2(f64) f64;
pub extern fn log2f(f32) f32;
pub extern fn log2l(c_longdouble) c_longdouble;
pub extern fn logb(f64) f64;
pub extern fn logbf(f32) f32;
pub extern fn logbl(c_longdouble) c_longdouble;
pub extern fn modff(f32, [*c]f32) f32;
pub extern fn modfl(c_longdouble, [*c]c_longdouble) c_longdouble;
pub extern fn scalbn(f64, c_int) f64;
pub extern fn scalbnf(f32, c_int) f32;
pub extern fn scalbnl(c_longdouble, c_int) c_longdouble;
pub extern fn scalbln(f64, c_long) f64;
pub extern fn scalblnf(f32, c_long) f32;
pub extern fn scalblnl(c_longdouble, c_long) c_longdouble;
pub extern fn cbrt(f64) f64;
pub extern fn cbrtf(f32) f32;
pub extern fn cbrtl(c_longdouble) c_longdouble;
pub extern fn hypot(f64, f64) f64;
pub extern fn hypotf(x: f32, y: f32) f32;
pub extern fn hypotl(c_longdouble, c_longdouble) c_longdouble;
pub extern fn powf(_X: f32, _Y: f32) f32;
pub extern fn powl(c_longdouble, c_longdouble) c_longdouble;
pub extern fn sqrtf(f32) f32;
pub extern fn sqrtl(c_longdouble) c_longdouble;
pub extern fn erf(f64) f64;
pub extern fn erff(f32) f32;
pub extern fn erfl(c_longdouble) c_longdouble;
pub extern fn erfc(f64) f64;
pub extern fn erfcf(f32) f32;
pub extern fn erfcl(c_longdouble) c_longdouble;
pub extern fn lgamma(f64) f64;
pub extern fn lgammaf(f32) f32;
pub extern fn lgammal(c_longdouble) c_longdouble;
pub extern var signgam: c_int;
pub extern fn tgamma(f64) f64;
pub extern fn tgammaf(f32) f32;
pub extern fn tgammal(c_longdouble) c_longdouble;
pub extern fn ceilf(f32) f32;
pub extern fn ceill(c_longdouble) c_longdouble;
pub extern fn floorf(f32) f32;
pub extern fn floorl(c_longdouble) c_longdouble;
pub extern fn nearbyint(f64) f64;
pub extern fn nearbyintf(f32) f32;
pub extern fn nearbyintl(c_longdouble) c_longdouble;
pub extern fn rint(f64) f64;
pub extern fn rintf(f32) f32;
pub extern fn rintl(c_longdouble) c_longdouble;
pub extern fn lrint(f64) c_long;
pub extern fn lrintf(f32) c_long;
pub extern fn lrintl(c_longdouble) c_long;
pub extern fn llrint(f64) c_longlong;
pub extern fn llrintf(f32) c_longlong;
pub extern fn llrintl(c_longdouble) c_longlong;
pub extern fn round(f64) f64;
pub extern fn roundf(f32) f32;
pub extern fn roundl(c_longdouble) c_longdouble;
pub extern fn lround(f64) c_long;
pub extern fn lroundf(f32) c_long;
pub extern fn lroundl(c_longdouble) c_long;
pub extern fn llround(f64) c_longlong;
pub extern fn llroundf(f32) c_longlong;
pub extern fn llroundl(c_longdouble) c_longlong;
pub extern fn trunc(f64) f64;
pub extern fn truncf(f32) f32;
pub extern fn truncl(c_longdouble) c_longdouble;
pub extern fn fmodf(f32, f32) f32;
pub extern fn fmodl(c_longdouble, c_longdouble) c_longdouble;
pub extern fn remainder(f64, f64) f64;
pub extern fn remainderf(f32, f32) f32;
pub extern fn remainderl(c_longdouble, c_longdouble) c_longdouble;
pub extern fn remquo(f64, f64, [*c]c_int) f64;
pub extern fn remquof(f32, f32, [*c]c_int) f32;
pub extern fn remquol(c_longdouble, c_longdouble, [*c]c_int) c_longdouble;
pub extern fn copysign(f64, f64) f64;
pub extern fn copysignf(f32, f32) f32;
pub extern fn copysignl(c_longdouble, c_longdouble) c_longdouble;
pub extern fn nan(tagp: [*c]const u8) f64;
pub extern fn nanf(tagp: [*c]const u8) f32;
pub extern fn nanl(tagp: [*c]const u8) c_longdouble;
pub extern fn nextafter(f64, f64) f64;
pub extern fn nextafterf(f32, f32) f32;
pub extern fn nextafterl(c_longdouble, c_longdouble) c_longdouble;
pub extern fn nexttoward(f64, c_longdouble) f64;
pub extern fn nexttowardf(f32, c_longdouble) f32;
pub extern fn nexttowardl(c_longdouble, c_longdouble) c_longdouble;
pub extern fn fdim(x: f64, y: f64) f64;
pub extern fn fdimf(x: f32, y: f32) f32;
pub extern fn fdiml(x: c_longdouble, y: c_longdouble) c_longdouble;
pub extern fn fmax(f64, f64) f64;
pub extern fn fmaxf(f32, f32) f32;
pub extern fn fmaxl(c_longdouble, c_longdouble) c_longdouble;
pub extern fn fmin(f64, f64) f64;
pub extern fn fminf(f32, f32) f32;
pub extern fn fminl(c_longdouble, c_longdouble) c_longdouble;
pub extern fn fma(f64, f64, f64) f64;
pub extern fn fmaf(f32, f32, f32) f32;
pub extern fn fmal(c_longdouble, c_longdouble, c_longdouble) c_longdouble;
pub extern fn _copysignf(_Number: f32, _Sign: f32) f32;
pub extern fn _chgsignf(_X: f32) f32;
pub extern fn _logbf(_X: f32) f32;
pub extern fn _nextafterf(_X: f32, _Y: f32) f32;
pub extern fn _finitef(_X: f32) c_int;
pub extern fn _isnanf(_X: f32) c_int;
pub extern fn _fpclassf(_X: f32) c_int;
pub extern fn _chgsignl(c_longdouble) c_longdouble;
pub const int_least8_t = i8;
pub const uint_least8_t = u8;
pub const int_least16_t = c_short;
pub const uint_least16_t = c_ushort;
pub const int_least32_t = c_int;
pub const uint_least32_t = c_uint;
pub const int_least64_t = c_longlong;
pub const uint_least64_t = c_ulonglong;
pub const int_fast8_t = i8;
pub const uint_fast8_t = u8;
pub const int_fast16_t = c_short;
pub const uint_fast16_t = c_ushort;
pub const int_fast32_t = c_int;
pub const uint_fast32_t = c_uint;
pub const int_fast64_t = c_longlong;
pub const uint_fast64_t = c_ulonglong;
pub const intmax_t = c_longlong;
pub const uintmax_t = c_ulonglong;
pub const Truth = extern struct {
    frequency: f64 = @import("std").mem.zeroes(f64),
    confidence: f64 = @import("std").mem.zeroes(f64),
};
pub extern var TRUTH_EVIDENTAL_HORIZON: f64;
pub extern var TRUTH_PROJECTION_DECAY: f64;
pub extern fn Truth_w2c(w: f64) f64;
pub extern fn Truth_c2w(c: f64) f64;
pub extern fn Truth_Expectation(v: Truth) f64;
pub extern fn Truth_Revision(v1: Truth, v2: Truth) Truth;
pub extern fn Truth_Deduction(v1: Truth, v2: Truth) Truth;
pub extern fn Truth_Induction(v1: Truth, v2: Truth) Truth;
pub extern fn Truth_Intersection(v1: Truth, v2: Truth) Truth;
pub extern fn Truth_Eternalize(v: Truth) Truth;
pub extern fn Truth_Projection(v: Truth, originalTime: c_long, targetTime: c_long) Truth;
pub extern fn Truth_Print(truth: [*c]Truth) void;
pub extern fn Truth_Print2(truth: [*c]Truth) void;
pub extern fn Truth_GoalDeduction(v1: Truth, v2: Truth) Truth;
pub extern fn Truth_Abduction(v1: Truth, v2: Truth) Truth;
pub extern fn Truth_Exemplification(v1: Truth, v2: Truth) Truth;
pub extern fn Truth_Comparison(v1: Truth, v2: Truth) Truth;
pub extern fn Truth_Analogy(v1: Truth, v2: Truth) Truth;
pub extern fn Truth_Resemblance(v1: Truth, v2: Truth) Truth;
pub extern fn Truth_StructuralDeduction(v1: Truth, v2: Truth) Truth;
pub extern fn Truth_StructuralDeductionNegated(v1: Truth, v2: Truth) Truth;
pub extern fn Truth_StructuralIntersection(v1: Truth, v2: Truth) Truth;
pub extern fn Truth_Union(v1: Truth, v2: Truth) Truth;
pub extern fn Truth_Difference(v1: Truth, v2: Truth) Truth;
pub extern fn Truth_Conversion(v1: Truth, v2: Truth) Truth;
pub extern fn Truth_Negation(v1: Truth, v2: Truth) Truth;
pub extern fn Truth_DecomposePNN(v1: Truth, v2: Truth) Truth;
pub extern fn Truth_DecomposeNPP(v1: Truth, v2: Truth) Truth;
pub extern fn Truth_DecomposePNP(v1: Truth, v2: Truth) Truth;
pub extern fn Truth_DecomposePPP(v1: Truth, v2: Truth) Truth;
pub extern fn Truth_DecomposeNNN(v1: Truth, v2: Truth) Truth;
pub extern fn Truth_AnonymousAnalogy(v1: Truth, v2: Truth) Truth;
pub extern fn Truth_FrequencyGreater(v1: Truth, v2: Truth) Truth;
pub extern fn Truth_FrequencyEqual(v1: Truth, v2: Truth) Truth;
pub extern fn Truth_Equal(v1: [*c]Truth, v2: [*c]Truth) bool;
pub const Term = extern struct {
    hashed: bool = @import("std").mem.zeroes(bool),
    hash: c_long = @import("std").mem.zeroes(c_long),
    atoms: [64]c_ushort = @import("std").mem.zeroes([64]c_ushort),
};
pub extern fn Term_Equal(a: [*c]Term, b: [*c]Term) bool;
pub extern fn Term_OverrideSubterm(term: [*c]Term, i: c_int, subterm: [*c]Term) bool;
pub extern fn Term_ExtractSubterm(term: [*c]Term, j: c_int) Term;
pub extern fn Term_Complexity(term: [*c]Term) c_int;
pub extern fn Term_Hash(term: [*c]Term) c_long;
pub extern fn Term_HasAtom(term: [*c]Term, atom: c_ushort) bool;
pub const Stamp = extern struct {
    evidentalBase: [10]c_long = @import("std").mem.zeroes([10]c_long),
};
pub extern fn Stamp_make(stamp1: [*c]Stamp, stamp2: [*c]Stamp) Stamp;
pub extern fn Stamp_checkOverlap(a: [*c]Stamp, b: [*c]Stamp) bool;
pub extern fn Stamp_Equal(a: [*c]Stamp, b: [*c]Stamp) bool;
pub extern fn Stamp_print(stamp: [*c]Stamp) void;
pub extern var base: c_long;
pub extern var importstamp: Stamp;
pub const Event = extern struct {
    term: Term = @import("std").mem.zeroes(Term),
    type: u8 = @import("std").mem.zeroes(u8),
    truth: Truth = @import("std").mem.zeroes(Truth),
    stamp: Stamp = @import("std").mem.zeroes(Stamp),
    occurrenceTime: c_long = @import("std").mem.zeroes(c_long),
    occurrenceTimeOffset: f64 = @import("std").mem.zeroes(f64),
    processed: bool = @import("std").mem.zeroes(bool),
    creationTime: c_long = @import("std").mem.zeroes(c_long),
    input: bool = @import("std").mem.zeroes(bool),
};
pub extern fn Event_INIT(...) void;
pub extern fn Event_InputEvent(term: Term, @"type": u8, truth: Truth, occurrenceTimeOffset: f64, currentTime: c_long) Event;
pub extern fn Event_Equal(event: [*c]Event, existing: [*c]Event) bool;
pub extern fn Event_EqualTermEqualStampLessConfidentThan(event: [*c]Event, existing: [*c]Event) bool;
pub extern fn Event_Eternalized(event: [*c]Event) Event;
pub extern var Narsese_atomValues: [65536]f64;
pub extern var Narsese_atomHasValue: [65536]bool;
pub extern var Narsese_atomMeasurementNames: [65536][32]u8;
pub extern var Narsese_atomNames: [65536][32]u8;
pub extern var Narsese_operatorNames: [10][32]u8;
pub extern var SELF: c_ushort;
pub extern fn Narsese_INIT(...) void;
pub extern fn Narsese_Expand(narsese: [*c]u8) [*c]u8;
pub extern fn Narsese_PrefixTransform(narsese_expanded: [*c]u8) [*c][*c]u8;
pub extern fn Narsese_Term(narsese: [*c]u8) Term;
pub extern fn Narsese_Sentence(narsese: [*c]u8, destTerm: [*c]Term, punctuation: [*c]u8, tense: [*c]c_int, destTv: [*c]Truth, occurrenceTimeOffset: [*c]f64) void;
pub extern fn Narsese_Sequence(a: [*c]Term, b: [*c]Term, success: [*c]bool) Term;
pub extern fn Narsese_AtomicTerm(name: [*c]u8) Term;
pub extern fn Narsese_AtomicTermIndex(name: [*c]u8) c_int;
pub extern fn Narsese_CopulaIndex(name: u8) c_int;
pub extern fn Narsese_PrintAtom(atom: c_ushort) void;
pub extern fn Narsese_PrintTerm(term: [*c]Term) void;
pub extern fn Narsese_copulaEquals(atom: c_ushort, name: u8) bool;
pub extern fn Narsese_isOperator(atom: c_ushort) bool;
pub extern fn Narsese_getOperationAtom(term: [*c]Term) c_ushort;
pub extern fn Narsese_getOperationTerm(term: [*c]Term) Term;
pub extern fn Narsese_isOperation(term: [*c]Term) bool;
pub extern fn Narsese_isExecutableOperation(term: [*c]Term) bool;
pub extern fn Narsese_GetPreconditionWithoutOp(precondition: [*c]Term) Term;
pub extern fn Narsese_IsSimpleAtom(atom: c_ushort) bool;
pub extern fn Narsese_HasSimpleAtom(term: [*c]Term) bool;
pub extern fn Narsese_StringEqual(name1: [*c]u8, name2: [*c]u8) bool;
pub extern fn Narsese_StringHash(name: [*c]u8) c_long;
pub extern fn Term_HasOperation(term: [*c]Term) bool;
pub extern fn Narsese_OperationSequenceAppendLeftNested(start: [*c]Term, sequence: [*c]Term) bool;
pub extern fn Narsese_setAtomValue(atom: c_ushort, value: f64, measurementName: [*c]u8) void;
pub extern fn Narsese_hasAtomValue(atom: c_ushort) bool;
pub extern fn Narsese_getAtomValue(atom: c_ushort) f64;
pub const Implication = extern struct {
    term: Term = @import("std").mem.zeroes(Term),
    truth: Truth = @import("std").mem.zeroes(Truth),
    stamp: Stamp = @import("std").mem.zeroes(Stamp),
    occurrenceTimeOffset: f64 = @import("std").mem.zeroes(f64),
    sourceConcept: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    sourceConceptId: c_long = @import("std").mem.zeroes(c_long),
    creationTime: c_long = @import("std").mem.zeroes(c_long),
};
pub const Substitution = extern struct {
    map: [28]Term = @import("std").mem.zeroes([28]Term),
    success: bool = @import("std").mem.zeroes(bool),
    truth: Truth = @import("std").mem.zeroes(Truth),
};
pub const SimilarityQuery = ?*const fn (Truth, [*c]Term, [*c]Term) callconv(.C) Truth;
pub extern var Variable_similarity_distance: f64;
pub extern fn Variable_isIndependentVariable(atom: c_ushort) bool;
pub extern fn Variable_isDependentVariable(atom: c_ushort) bool;
pub extern fn Variable_isQueryVariable(atom: c_ushort) bool;
pub extern fn Variable_isVariable(atom: c_ushort) bool;
pub extern fn Variable_hasVariable(term: [*c]Term, independent: bool, dependent: bool, query: bool) bool;
pub extern fn Variable_Unify(general: [*c]Term, specific: [*c]Term) Substitution;
pub extern fn Variable_UnifyWithAnalogy(truth: Truth, general: [*c]Term, specific: [*c]Term) Substitution;
pub extern fn Variable_Unify2(truth: Truth, general: [*c]Term, specific: [*c]Term, unifyQueryVarOnly: bool) Substitution;
pub extern fn Variable_ApplySubstitute(term: Term, substitution: Substitution, success: [*c]bool) Term;
pub extern fn Variable_IntroduceImplicationVariables(implication: Term, success: [*c]bool, extensionally: bool) Term;
pub extern fn Variable_IntroduceConjunctionVariables(conjunction: Term, success: [*c]bool, extensionally: bool) Term;
pub extern fn Variable_Normalize(term: [*c]Term) void;
pub extern fn Inference_EventUpdate(ev: [*c]Event, currentTime: c_long) Event;
pub extern fn Inference_BeliefIntersection(a: [*c]Event, b: [*c]Event, success: [*c]bool) Event;
pub extern fn Inference_BeliefInduction(a: [*c]Event, b: [*c]Event, success: [*c]bool) Implication;
pub extern fn Inference_ImplicationRevision(a: [*c]Implication, b: [*c]Implication) Implication;
pub extern fn Inference_GoalDeduction(component: [*c]Event, compound: [*c]Implication, currentTime: c_long) Event;
pub extern fn Inference_GoalSequenceDeduction(compound: [*c]Event, component: [*c]Event, currentTime: c_long) Event;
pub extern fn Inference_RevisionAndChoice(existing_potential: [*c]Event, incoming_spike: [*c]Event, currentTime: c_long, revised: [*c]bool) Event;
pub extern fn Inference_BeliefDeduction(component: [*c]Event, compound: [*c]Implication) Event;
pub extern fn Inference_EventRevision(a: [*c]Event, b: [*c]Event) Event;
pub const Table = extern struct {
    array: [20]Implication = @import("std").mem.zeroes([20]Implication),
    itemsAmount: c_int = @import("std").mem.zeroes(c_int),
};
pub extern fn Table_Add(table: [*c]Table, imp: [*c]Implication) [*c]Implication;
pub extern fn Table_Remove(table: [*c]Table, index: c_int) void;
pub extern fn Table_AddAndRevise(table: [*c]Table, imp: [*c]Implication) [*c]Implication;
pub const Usage = extern struct {
    useCount: c_long = @import("std").mem.zeroes(c_long),
    lastUsed: c_long = @import("std").mem.zeroes(c_long),
};
pub extern fn Usage_usefulness(usage: Usage, currentTime: c_long) f64;
pub extern fn Usage_use(usage: Usage, currentTime: c_long, eternalInput: bool) Usage;
pub extern fn Usage_Print(usage: [*c]Usage) void;
pub const Concept = extern struct {
    id: c_long = @import("std").mem.zeroes(c_long),
    usage: Usage = @import("std").mem.zeroes(Usage),
    term: Term = @import("std").mem.zeroes(Term),
    belief: Event = @import("std").mem.zeroes(Event),
    belief_spike: Event = @import("std").mem.zeroes(Event),
    predicted_belief: Event = @import("std").mem.zeroes(Event),
    goal_spike: Event = @import("std").mem.zeroes(Event),
    precondition_beliefs: [11]Table = @import("std").mem.zeroes([11]Table),
    priority: f64 = @import("std").mem.zeroes(f64),
    processID: c_long = @import("std").mem.zeroes(c_long),
    processID2: c_long = @import("std").mem.zeroes(c_long),
    processID3: c_long = @import("std").mem.zeroes(c_long),
    lastSelectionTime: c_long = @import("std").mem.zeroes(c_long),
};
pub const OccurrenceTimeIndex = extern struct {
    itemsAmount: c_int = @import("std").mem.zeroes(c_int),
    currentIndex: c_int = @import("std").mem.zeroes(c_int),
    array: [512][*c]Concept = @import("std").mem.zeroes([512][*c]Concept),
};
pub extern fn OccurrenceTimeIndex_Add(concept: [*c]Concept, fifo: [*c]OccurrenceTimeIndex) void;
pub extern fn OccurrenceTimeIndex_GetKthNewestElement(fifo: [*c]OccurrenceTimeIndex, k: c_int) [*c]Concept;
pub const Stack = extern struct {
    items: [*c]?*anyopaque = @import("std").mem.zeroes([*c]?*anyopaque),
    stackpointer: c_int = @import("std").mem.zeroes(c_int),
    maxElements: c_int = @import("std").mem.zeroes(c_int),
};
pub extern fn Stack_INIT(stack: [*c]Stack, items: [*c]?*anyopaque, maxElements: c_int) void;
pub extern fn Stack_Push(stack: [*c]Stack, item: ?*anyopaque) void;
pub extern fn Stack_Pop(stack: [*c]Stack) ?*anyopaque;
pub extern fn Stack_IsEmpty(stack: [*c]Stack) bool;
pub const ConceptChainElement = extern struct {
    c: [*c]Concept = @import("std").mem.zeroes([*c]Concept),
    next: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub extern var conceptChainElementStoragePointers: [507904][*c]ConceptChainElement;
pub extern var conceptChainElementStorage: [507904]ConceptChainElement;
pub extern var conceptChainElementStack: Stack;
pub extern var invertedAtomIndex: [65536][*c]ConceptChainElement;
pub extern fn InvertedAtomIndex_INIT(...) void;
pub extern fn InvertedAtomIndex_AddConcept(term: Term, c: [*c]Concept) void;
pub extern fn InvertedAtomIndex_RemoveConcept(term: Term, c: [*c]Concept) void;
pub extern fn InvertedAtomIndex_Print(...) void;
pub extern fn InvertedAtomIndex_GetConceptChain(atom: c_ushort) [*c]ConceptChainElement;
pub const Item = extern struct {
    priority: f64 = @import("std").mem.zeroes(f64),
    address: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub const PriorityQueue = extern struct {
    items: [*c]Item = @import("std").mem.zeroes([*c]Item),
    itemsAmount: c_int = @import("std").mem.zeroes(c_int),
    maxElements: c_int = @import("std").mem.zeroes(c_int),
};
pub const PriorityQueue_Push_Feedback = extern struct {
    added: bool = @import("std").mem.zeroes(bool),
    addedItem: Item = @import("std").mem.zeroes(Item),
    evicted: bool = @import("std").mem.zeroes(bool),
    evictedItem: Item = @import("std").mem.zeroes(Item),
};
pub extern fn PriorityQueue_INIT(queue: [*c]PriorityQueue, items: [*c]Item, maxElements: c_int) void;
pub extern fn PriorityQueue_Push(queue: [*c]PriorityQueue, priority: f64) PriorityQueue_Push_Feedback;
pub extern fn PriorityQueue_PopAt(queue: [*c]PriorityQueue, i: c_int, returnItemAddress: [*c]?*anyopaque) bool;
pub extern fn PriorityQueue_Rebuild(queue: [*c]PriorityQueue) void;
pub extern fn PriorityQueue_PopMin(queue: [*c]PriorityQueue, returnItemAddress: [*c]?*anyopaque, returnItemPriority: [*c]f64) bool;
pub extern fn PriorityQueue_PopMax(queue: [*c]PriorityQueue, returnItemAddress: [*c]?*anyopaque, returnItemPriority: [*c]f64) bool;
pub const Equal = ?*const fn (?*anyopaque, ?*anyopaque) callconv(.C) bool;
pub const Hash = ?*const fn (?*anyopaque) callconv(.C) c_long;
pub const VMItem = extern struct {
    key: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    value: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    next: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub const HashTable = extern struct {
    storageptrs: [*c][*c]VMItem = @import("std").mem.zeroes([*c][*c]VMItem),
    storage: [*c]VMItem = @import("std").mem.zeroes([*c]VMItem),
    HT: [*c][*c]VMItem = @import("std").mem.zeroes([*c][*c]VMItem),
    VMStack: Stack = @import("std").mem.zeroes(Stack),
    buckets: c_int = @import("std").mem.zeroes(c_int),
    equal: Equal = @import("std").mem.zeroes(Equal),
    hash: Hash = @import("std").mem.zeroes(Hash),
};
pub extern fn HashTable_Get(hashtable: [*c]HashTable, key: ?*anyopaque) ?*anyopaque;
pub extern fn HashTable_Set(hashtable: [*c]HashTable, key: ?*anyopaque, value: ?*anyopaque) void;
pub extern fn HashTable_Delete(hashtable: [*c]HashTable, key: ?*anyopaque) void;
pub extern fn HashTable_INIT(hashtable: [*c]HashTable, storage: [*c]VMItem, storageptrs: [*c][*c]VMItem, HT: [*c][*c]VMItem, buckets: c_int, maxElements: c_int, equal: Equal, hash: Hash) void;
pub extern fn HashTable_MaximumChainLength(hashtable: [*c]HashTable) c_int;
pub extern var PROPAGATION_THRESHOLD: f64;
pub extern var PRINT_DERIVATIONS: bool;
pub extern var PRINT_INPUT: bool;
pub extern var conceptPriorityThreshold: f64;
pub const Feedback = extern struct {
    subs: Substitution = @import("std").mem.zeroes(Substitution),
    failed: bool = @import("std").mem.zeroes(bool),
};
pub const Action = ?*const fn (Term) callconv(.C) Feedback;
pub const Operation = extern struct {
    term: Term = @import("std").mem.zeroes(Term),
    action: Action = @import("std").mem.zeroes(Action),
    arguments: [10]Term = @import("std").mem.zeroes([10]Term),
    stdinOutput: bool = @import("std").mem.zeroes(bool),
};
pub extern var ontology_handling: bool;
pub extern var selectedBeliefs: [1]Event;
pub extern var selectedBeliefsPriority: [1]f64;
pub extern var beliefsSelectedCnt: c_int;
pub extern var selectedGoals: [1]Event;
pub extern var selectedGoalsPriority: [1]f64;
pub extern var goalsSelectedCnt: c_int;
pub extern var concept_id: c_int;
pub extern var concepts: PriorityQueue;
pub extern var cycling_belief_events: PriorityQueue;
pub extern var cycling_goal_events: [30]PriorityQueue;
pub extern var HTconcepts: HashTable;
pub extern var occurrenceTimeIndex: OccurrenceTimeIndex;
pub extern var operations: [10]Operation;
pub extern var PRINT_EVENTS_PRIORITY_THRESHOLD: f64;
pub extern fn Memory_INIT(...) void;
pub extern fn Memory_FindConceptByTerm(term: [*c]Term) [*c]Concept;
pub extern fn Memory_Conceptualize(term: [*c]Term, currentTime: c_long) [*c]Concept;
pub extern fn Memory_AddEvent(event: [*c]Event, currentTime: c_long, priority: f64, input: bool, derived: bool, revised: bool, layer: c_int) void;
pub extern fn Memory_AddInputEvent(event: [*c]Event, currentTime: c_long) void;
pub extern fn Memory_AddOperation(id: c_int, op: Operation) void;
pub extern fn Memory_ImplicationValid(imp: [*c]Implication) bool;
pub extern fn Memory_printAddedEvent(stamp: [*c]Stamp, event: [*c]Event, priority: f64, input: bool, derived: bool, revised: bool, controlInfo: bool, selected: bool) void;
pub extern fn Memory_printAddedImplication(stamp: [*c]Stamp, implication: [*c]Term, truth: [*c]Truth, occurrenceTimeOffset: f64, priority: f64, input: bool, revised: bool, controlInfo: bool) void;
pub extern fn Memory_getOperationID(term: [*c]Term) c_int;
pub extern var CONDITION_THRESHOLD: f64;
pub extern var DECISION_THRESHOLD: f64;
pub extern var ANTICIPATION_THRESHOLD: f64;
pub extern var ANTICIPATION_CONFIDENCE: f64;
pub extern var MOTOR_BABBLING_CHANCE: f64;
pub extern var BABBLING_OPS: c_int;
pub const Decision = extern struct {
    desire: f64 = @import("std").mem.zeroes(f64),
    execute: bool = @import("std").mem.zeroes(bool),
    operationTerm: Term = @import("std").mem.zeroes(Term),
    operationID: [1]c_int = @import("std").mem.zeroes([1]c_int),
    op: [1]Operation = @import("std").mem.zeroes([1]Operation),
    arguments: [1]Term = @import("std").mem.zeroes([1]Term),
    missing_specific_implication: Implication = @import("std").mem.zeroes(Implication),
    usedContingency: Implication = @import("std").mem.zeroes(Implication),
    reason: [*c]Event = @import("std").mem.zeroes([*c]Event),
};
pub extern fn Decision_INIT(...) void;
pub extern fn Decision_Execute(currentTime: c_long, decision: [*c]Decision) void;
pub extern fn Decision_Anticipate(operationID: c_int, op_term: Term, currentTime: c_long) void;
pub extern fn Decision_Suggest(goalconcept: [*c]Concept, goal: [*c]Event, currentTime: c_long) Decision;
pub extern fn Decision_BetterDecision(best_decision: Decision, decision: Decision) Decision;
pub extern fn NAL_GenerateRuleTable(...) void;
pub extern fn NAL_DerivedEvent(conclusionTerm: Term, conclusionOccurrence: c_long, conclusionTruth: Truth, stamp: Stamp, currentTime: c_long, parentPriority: f64, conceptPriority: f64, occurrenceTimeOffset: f64, validation_concept: [*c]Concept, validation_cid: c_long, varIntro: bool, allowOnlyExtVarIntroAndTwoIndependentVars: bool) void;
pub extern fn RuleTable_Apply(term1: Term, term2: Term, truth1: Truth, truth2: Truth, conclusionOccurrence: c_long, occurrenceTimeOffset: f64, conclusionStamp: Stamp, currentTime: c_long, parentPriority: f64, conceptPriority: f64, doublePremise: bool, validation_concept: [*c]Concept, validation_cid: c_long) void;
pub extern fn RuleTable_Reduce(term1: Term) Term;
pub extern var Stats_countConceptsMatchedTotal: c_long;
pub extern var Stats_countConceptsMatchedMax: c_long;
pub extern var HTatoms: HashTable;
pub extern fn Stats_Print(currentTime: c_long) void;
pub extern fn Cycle_Perform(currentTime: c_long) void;
pub extern fn Cycle_INIT(...) void;
pub extern var currentTime: c_long;
pub extern var QUESTION_PRIMING: f64;
pub extern fn NAR_INIT(...) void;
pub extern fn NAR_Cycles(cycles: c_int) void;
pub extern fn NAR_AddInput(term: Term, @"type": u8, truth: Truth, eternal: bool, occurrenceTimeOffset: f64) Event;
pub extern fn NAR_AddInputBelief(term: Term) Event;
pub extern fn NAR_AddInputGoal(term: Term) Event;
pub extern fn NAR_AddOperation(atomname: [*c]u8, procedure: Action) void;
pub extern fn NAR_AddInputNarsese(narsese_sentence: [*c]u8) void;
pub extern fn NAR_AddInputNarsese2(narsese_sentence: [*c]u8, queryCommand: bool, answerTruthExpThreshold: f64) void;
pub export fn Stamp_Test() void {
    _ = puts(">>Stamp test start");
    var stamp1: Stamp = Stamp{
        .evidentalBase = [2]c_long{
            1,
            2,
        } ++ [1]c_long{0} ** 8,
    };
    _ = &stamp1;
    Stamp_print(&stamp1);
    var stamp2: Stamp = Stamp{
        .evidentalBase = [3]c_long{
            2,
            3,
            4,
        } ++ [1]c_long{0} ** 7,
    };
    _ = &stamp2;
    Stamp_print(&stamp2);
    var stamp3: Stamp = Stamp_make(&stamp1, &stamp2);
    _ = &stamp3;
    _ = fputs("zipped:", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
    Stamp_print(&stamp3);
    Globals_assert(@as(c_int, @intFromBool(Stamp_checkOverlap(&stamp1, &stamp2))) == @as(c_int, 1), @as([*c]u8, @ptrCast(@volatileCast(@constCast("Stamp should overlap")))));
    _ = puts("<<Stamp test successful");
}
// src/./unit_tests/PriorityQueue_Test.h:30:10: warning: unsupported type: 'VariableArray'

// src/./unit_tests/PriorityQueue_Test.h:25:6: warning: unable to translate function, demoted to extern
pub extern fn PriorityQueue_Test() void;
pub export fn Memory_Test() void {
    NAR_INIT();
    _ = puts(">>Memory test start");
    var e: Event = Event_InputEvent(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a"))))), @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 2))))), Truth{
        .frequency = @as(f64, @floatFromInt(@as(c_int, 1))),
        .confidence = 0.9,
    }, @as(f64, @floatFromInt(@as(c_int, 0))), @as(c_long, @bitCast(@as(c_long, @as(c_int, 0)))));
    _ = &e;
    Memory_AddInputEvent(&e, @as(c_long, @bitCast(@as(c_long, @as(c_int, 0)))));
    _ = Memory_Conceptualize(&e.term, @as(c_long, @bitCast(@as(c_long, @as(c_int, 1)))));
    var c1: [*c]Concept = Memory_FindConceptByTerm(&e.term);
    _ = &c1;
    Globals_assert(c1 != @as([*c]Concept, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("Concept should have been created!")))));
    var e2: Event = Event_InputEvent(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b"))))), @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 2))))), Truth{
        .frequency = @as(f64, @floatFromInt(@as(c_int, 1))),
        .confidence = 0.9,
    }, @as(f64, @floatFromInt(@as(c_int, 0))), @as(c_long, @bitCast(@as(c_long, @as(c_int, 0)))));
    _ = &e2;
    Memory_AddInputEvent(&e2, @as(c_long, @bitCast(@as(c_long, @as(c_int, 0)))));
    _ = Memory_Conceptualize(&e2.term, @as(c_long, @bitCast(@as(c_long, @as(c_int, 1)))));
    var c2: [*c]Concept = Memory_FindConceptByTerm(&e2.term);
    _ = &c2;
    Globals_assert(c2 != @as([*c]Concept, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("Concept should have been created!")))));
    _ = puts("<<Memory test successful");
}
pub export fn OccurrenceTimeIndex_Test() void {
    _ = puts(">>OccurrenceTimeIndex test start");
    var fifo: OccurrenceTimeIndex = OccurrenceTimeIndex{
        .itemsAmount = @as(c_int, 0),
        .currentIndex = 0,
        .array = @import("std").mem.zeroes([512][*c]Concept),
    };
    _ = &fifo;
    var occurrence: c_int = 0;
    _ = &occurrence;
    {
        var i: c_int = @as(c_int, 512) * @as(c_int, 2);
        _ = &i;
        while (i >= @as(c_int, 1)) : (i -= 1) {
            var c1: [*c]Concept = @as([*c]Concept, @ptrFromInt(@as(c_long, @bitCast(@as(c_long, i)))));
            _ = &c1;
            OccurrenceTimeIndex_Add(c1, &fifo);
        }
    }
    {
        var i: c_int = 0;
        _ = &i;
        while (i < @as(c_int, 512)) : (i += 1) {
            Globals_assert(@as(c_long, @bitCast(@as(c_long, @as(c_int, 512) - i))) == @as(c_long, @intCast(@intFromPtr(fifo.array[@as(c_uint, @intCast(i))]))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("Item at OccurrenceTimeIndex position has to be right")))));
        }
    }
    Globals_assert(fifo.itemsAmount == @as(c_int, 512), @as([*c]u8, @ptrCast(@volatileCast(@constCast("OccurrenceTimeIndex size differs")))));
    _ = puts("<<OccurrenceTimeIndex Test successful");
}
pub export fn InvertedAtomIndex_Test() void {
    _ = puts(">>Inverted atom index test start");
    NAR_INIT();
    var term: Term = Narsese_Term(@as([*c]u8, @ptrCast(@volatileCast(@constCast("<a --> (b & c)>")))));
    _ = &term;
    var c: Concept = Concept{
        .id = 0,
        .usage = @import("std").mem.zeroes(Usage),
        .term = term,
        .belief = @import("std").mem.zeroes(Event),
        .belief_spike = @import("std").mem.zeroes(Event),
        .predicted_belief = @import("std").mem.zeroes(Event),
        .goal_spike = @import("std").mem.zeroes(Event),
        .precondition_beliefs = @import("std").mem.zeroes([11]Table),
        .priority = 0,
        .processID = 0,
        .processID2 = 0,
        .processID3 = 0,
        .lastSelectionTime = 0,
    };
    _ = &c;
    InvertedAtomIndex_AddConcept(term, &c);
    InvertedAtomIndex_Print();
    Globals_assert(invertedAtomIndex[@as(c_uint, @intCast(Narsese_AtomicTermIndex(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a")))))))].*.c == (&c), @as([*c]u8, @ptrCast(@volatileCast(@constCast("There was no concept reference added for key a!")))));
    Globals_assert(invertedAtomIndex[@as(c_uint, @intCast(Narsese_AtomicTermIndex(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b")))))))].*.c == (&c), @as([*c]u8, @ptrCast(@volatileCast(@constCast("There was no concept reference added for key b!")))));
    Globals_assert(invertedAtomIndex[@as(c_uint, @intCast(Narsese_AtomicTermIndex(@as([*c]u8, @ptrCast(@volatileCast(@constCast("c")))))))].*.c == (&c), @as([*c]u8, @ptrCast(@volatileCast(@constCast("There was no concept reference added for key c!")))));
    Globals_assert(invertedAtomIndex[@as(c_uint, @intCast(Narsese_AtomicTermIndex(@as([*c]u8, @ptrCast(@volatileCast(@constCast(":")))))))] == @as([*c]ConceptChainElement, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("There was a concept reference added for key inheritance!")))));
    InvertedAtomIndex_RemoveConcept(term, &c);
    InvertedAtomIndex_Print();
    Globals_assert(invertedAtomIndex[@as(c_uint, @intCast(Narsese_AtomicTermIndex(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a")))))))] == @as([*c]ConceptChainElement, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("Concept reference was not removed for key a!")))));
    Globals_assert(invertedAtomIndex[@as(c_uint, @intCast(Narsese_AtomicTermIndex(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b")))))))] == @as([*c]ConceptChainElement, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("Concept reference was not removed for key b!")))));
    Globals_assert(invertedAtomIndex[@as(c_uint, @intCast(Narsese_AtomicTermIndex(@as([*c]u8, @ptrCast(@volatileCast(@constCast("c")))))))] == @as([*c]ConceptChainElement, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("Concept reference was not removed for key c!")))));
    InvertedAtomIndex_AddConcept(term, &c);
    var term2: Term = Narsese_Term(@as([*c]u8, @ptrCast(@volatileCast(@constCast("<b --> d>")))));
    _ = &term2;
    var c2: Concept = Concept{
        .id = 0,
        .usage = @import("std").mem.zeroes(Usage),
        .term = term2,
        .belief = @import("std").mem.zeroes(Event),
        .belief_spike = @import("std").mem.zeroes(Event),
        .predicted_belief = @import("std").mem.zeroes(Event),
        .goal_spike = @import("std").mem.zeroes(Event),
        .precondition_beliefs = @import("std").mem.zeroes([11]Table),
        .priority = 0,
        .processID = 0,
        .processID2 = 0,
        .processID3 = 0,
        .lastSelectionTime = 0,
    };
    _ = &c2;
    InvertedAtomIndex_AddConcept(term2, &c2);
    InvertedAtomIndex_Print();
    Globals_assert(invertedAtomIndex[@as(c_uint, @intCast(Narsese_AtomicTermIndex(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a")))))))].*.c == (&c), @as([*c]u8, @ptrCast(@volatileCast(@constCast("There was no concept reference added for key a! (2)")))));
    Globals_assert(invertedAtomIndex[@as(c_uint, @intCast(Narsese_AtomicTermIndex(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b")))))))].*.c == (&c), @as([*c]u8, @ptrCast(@volatileCast(@constCast("There was no concept reference added for key b! (2)")))));
    Globals_assert(invertedAtomIndex[@as(c_uint, @intCast(Narsese_AtomicTermIndex(@as([*c]u8, @ptrCast(@volatileCast(@constCast("c")))))))].*.c == (&c), @as([*c]u8, @ptrCast(@volatileCast(@constCast("There was no concept reference added for key c! (2)")))));
    Globals_assert(@as([*c]ConceptChainElement, @ptrCast(@alignCast(invertedAtomIndex[@as(c_uint, @intCast(Narsese_AtomicTermIndex(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b")))))))].*.next))).*.c == (&c2), @as([*c]u8, @ptrCast(@volatileCast(@constCast("There was no concept2 reference added for key b! (2)")))));
    Globals_assert(invertedAtomIndex[@as(c_uint, @intCast(Narsese_AtomicTermIndex(@as([*c]u8, @ptrCast(@volatileCast(@constCast("d")))))))].*.c == (&c2), @as([*c]u8, @ptrCast(@volatileCast(@constCast("There was no concept2 reference added for key d! (2)")))));
    InvertedAtomIndex_RemoveConcept(term, &c);
    _ = puts("after removal");
    InvertedAtomIndex_Print();
    Globals_assert(invertedAtomIndex[@as(c_uint, @intCast(Narsese_AtomicTermIndex(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b")))))))].*.c == (&c2), @as([*c]u8, @ptrCast(@volatileCast(@constCast("There was no concept2 reference remaining for key b! (3)")))));
    Globals_assert(invertedAtomIndex[@as(c_uint, @intCast(Narsese_AtomicTermIndex(@as([*c]u8, @ptrCast(@volatileCast(@constCast("d")))))))].*.c == (&c2), @as([*c]u8, @ptrCast(@volatileCast(@constCast("There was no concept2 reference remaining for key d! (3)")))));
    Globals_assert(invertedAtomIndex[@as(c_uint, @intCast(Narsese_AtomicTermIndex(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a")))))))] == @as([*c]ConceptChainElement, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("Concept reference was not removed for key a! (3)")))));
    Globals_assert(invertedAtomIndex[@as(c_uint, @intCast(Narsese_AtomicTermIndex(@as([*c]u8, @ptrCast(@volatileCast(@constCast("c")))))))] == @as([*c]ConceptChainElement, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("Concept reference was not removed for key c! (3)")))));
    InvertedAtomIndex_RemoveConcept(term2, &c2);
    _ = puts("after removal2");
    InvertedAtomIndex_Print();
    Globals_assert(invertedAtomIndex[@as(c_uint, @intCast(Narsese_AtomicTermIndex(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a")))))))] == @as([*c]ConceptChainElement, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("Concept reference was not removed for key a! (4)")))));
    Globals_assert(invertedAtomIndex[@as(c_uint, @intCast(Narsese_AtomicTermIndex(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b")))))))] == @as([*c]ConceptChainElement, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("Concept reference was not removed for key b! (4)")))));
    Globals_assert(invertedAtomIndex[@as(c_uint, @intCast(Narsese_AtomicTermIndex(@as([*c]u8, @ptrCast(@volatileCast(@constCast("c")))))))] == @as([*c]ConceptChainElement, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("Concept reference was not removed for key c! (4)")))));
    Globals_assert(invertedAtomIndex[@as(c_uint, @intCast(Narsese_AtomicTermIndex(@as([*c]u8, @ptrCast(@volatileCast(@constCast("d")))))))] == @as([*c]ConceptChainElement, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("Concept reference was not removed for key d! (4)")))));
    _ = puts(">>Inverted atom index test successul");
}
pub export fn Narsese_Test() void {
    _ = puts(">>Narsese test start");
    var narsese: [*c]u8 = @as([*c]u8, @ptrCast(@volatileCast(@constCast("<<$sth --> (&,[furry,meowing],animal)> =/> <$sth --> [good]>>"))));
    _ = &narsese;
    _ = printf("Narsese: %s\n", narsese);
    var preprocessed: [*c]u8 = Narsese_Expand(narsese);
    _ = &preprocessed;
    _ = printf("Preprocessed: %s\n", preprocessed);
    var tokens: [*c][*c]u8 = Narsese_PrefixTransform(preprocessed);
    _ = &tokens;
    var k: c_int = 0;
    _ = &k;
    while ((blk: {
        const tmp = k;
        if (tmp >= 0) break :blk tokens + @as(usize, @intCast(tmp)) else break :blk tokens - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).* != @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) : (k += 1) {
        _ = printf("token: %s\n", (blk: {
            const tmp = k;
            if (tmp >= 0) break :blk tokens + @as(usize, @intCast(tmp)) else break :blk tokens - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*);
    }
    var ret: Term = Narsese_Term(narsese);
    _ = &ret;
    {
        var i: c_int = 0;
        _ = &i;
        while (i < @as(c_int, 64)) : (i += 1) {
            if (@as(c_int, @bitCast(@as(c_uint, ret.atoms[@as(c_uint, @intCast(i))]))) != @as(c_int, 0)) {
                _ = printf("Subterm: %i %d %s\n", i, @as(c_int, @bitCast(@as(c_uint, ret.atoms[@as(c_uint, @intCast(i))]))), @as([*c]u8, @ptrCast(@alignCast(&Narsese_atomNames[@as(c_uint, @intCast(@as(c_int, @bitCast(@as(c_uint, ret.atoms[@as(c_uint, @intCast(i))]))) - @as(c_int, 1)))]))));
            }
        }
    }
    _ = puts("Result:");
    Narsese_PrintTerm(&ret);
    _ = puts("");
    _ = puts(">>Narsese Test successul");
    Narsese_PrintTerm(&ret);
    _ = puts("");
}
pub export fn RuleTable_Test() void {
    _ = puts(">>RuleTable test start");
    NAR_INIT();
    _ = NAR_AddInput(Narsese_Term(@as([*c]u8, @ptrCast(@volatileCast(@constCast("<cat --> animal>"))))), @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 2))))), Truth{
        .frequency = 1.0,
        .confidence = 0.9,
    }, @as(c_int, 1) != 0, @as(f64, @floatFromInt(@as(c_int, 0))));
    _ = NAR_AddInput(Narsese_Term(@as([*c]u8, @ptrCast(@volatileCast(@constCast("<animal --> being>"))))), @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 2))))), Truth{
        .frequency = 1.0,
        .confidence = 0.9,
    }, @as(c_int, 1) != 0, @as(f64, @floatFromInt(@as(c_int, 0))));
    NAR_Cycles(@as(c_int, 1));
    _ = puts(">>RuleTable test successul");
}
pub export fn Stack_Test() void {
    _ = puts(">>Stack test start");
    var stack: Stack = Stack{
        .items = null,
        .stackpointer = 0,
        .maxElements = 0,
    };
    _ = &stack;
    var storageptrs: [5][*c]VMItem = undefined;
    _ = &storageptrs;
    Stack_INIT(&stack, @as([*c]?*anyopaque, @ptrCast(@alignCast(@as([*c][*c]VMItem, @ptrCast(@alignCast(&storageptrs)))))), @as(c_int, 5));
    var c1: Concept = Concept{
        .id = @as(c_long, @bitCast(@as(c_long, @as(c_int, 0)))),
        .usage = @import("std").mem.zeroes(Usage),
        .term = @import("std").mem.zeroes(Term),
        .belief = @import("std").mem.zeroes(Event),
        .belief_spike = @import("std").mem.zeroes(Event),
        .predicted_belief = @import("std").mem.zeroes(Event),
        .goal_spike = @import("std").mem.zeroes(Event),
        .precondition_beliefs = @import("std").mem.zeroes([11]Table),
        .priority = 0,
        .processID = 0,
        .processID2 = 0,
        .processID3 = 0,
        .lastSelectionTime = 0,
    };
    _ = &c1;
    var c2: Concept = Concept{
        .id = @as(c_long, @bitCast(@as(c_long, @as(c_int, 0)))),
        .usage = @import("std").mem.zeroes(Usage),
        .term = @import("std").mem.zeroes(Term),
        .belief = @import("std").mem.zeroes(Event),
        .belief_spike = @import("std").mem.zeroes(Event),
        .predicted_belief = @import("std").mem.zeroes(Event),
        .goal_spike = @import("std").mem.zeroes(Event),
        .precondition_beliefs = @import("std").mem.zeroes([11]Table),
        .priority = 0,
        .processID = 0,
        .processID2 = 0,
        .processID3 = 0,
        .lastSelectionTime = 0,
    };
    _ = &c2;
    var item1: VMItem = VMItem{
        .key = null,
        .value = @as(?*anyopaque, @ptrCast(&c1)),
        .next = null,
    };
    _ = &item1;
    var item2: VMItem = VMItem{
        .key = null,
        .value = @as(?*anyopaque, @ptrCast(&c2)),
        .next = null,
    };
    _ = &item2;
    Stack_Push(&stack, @as(?*anyopaque, @ptrCast(&item1)));
    Globals_assert(stack.stackpointer == @as(c_int, 1), @as([*c]u8, @ptrCast(@volatileCast(@constCast("Stackpointer wasn't incremented")))));
    Globals_assert(@as([*c][*c]VMItem, @ptrCast(@alignCast(stack.items)))[@as(c_uint, @intCast(@as(c_int, 0)))].*.value == @as(?*anyopaque, @ptrCast(&c1)), @as([*c]u8, @ptrCast(@volatileCast(@constCast("Item should point to c1")))));
    Globals_assert(!Stack_IsEmpty(&stack), @as([*c]u8, @ptrCast(@volatileCast(@constCast("Stack should not be empty")))));
    var item1_popped: [*c]VMItem = @as([*c]VMItem, @ptrCast(@alignCast(Stack_Pop(&stack))));
    _ = &item1_popped;
    Globals_assert(stack.stackpointer == @as(c_int, 0), @as([*c]u8, @ptrCast(@volatileCast(@constCast("Stackpointer wasn't decremented")))));
    Globals_assert(item1_popped.*.value == @as(?*anyopaque, @ptrCast(&c1)), @as([*c]u8, @ptrCast(@volatileCast(@constCast("Popped item1 should point to c1 (1)")))));
    Stack_Push(&stack, @as(?*anyopaque, @ptrCast(&item1)));
    Stack_Push(&stack, @as(?*anyopaque, @ptrCast(&item2)));
    Globals_assert(stack.stackpointer == @as(c_int, 2), @as([*c]u8, @ptrCast(@volatileCast(@constCast("Stackpointer wrong")))));
    var item2_popped: [*c]VMItem = @as([*c]VMItem, @ptrCast(@alignCast(Stack_Pop(&stack))));
    _ = &item2_popped;
    Globals_assert(item2_popped.*.value == @as(?*anyopaque, @ptrCast(&c2)), @as([*c]u8, @ptrCast(@volatileCast(@constCast("Popped item2 should point to c2")))));
    var item1_popped_again: [*c]VMItem = @as([*c]VMItem, @ptrCast(@alignCast(Stack_Pop(&stack))));
    _ = &item1_popped_again;
    Globals_assert(item1_popped_again.*.value == @as(?*anyopaque, @ptrCast(&c1)), @as([*c]u8, @ptrCast(@volatileCast(@constCast("Popped item1 should point to c1 (2)")))));
    Globals_assert(Stack_IsEmpty(&stack), @as([*c]u8, @ptrCast(@volatileCast(@constCast("Stack should be empty")))));
    _ = puts(">>Stack test successul");
}
pub export fn Table_Test() void {
    _ = puts(">>Table test start");
    var sourceConcept: Concept = Concept{
        .id = @as(c_long, @bitCast(@as(c_long, @as(c_int, 0)))),
        .usage = @import("std").mem.zeroes(Usage),
        .term = @import("std").mem.zeroes(Term),
        .belief = @import("std").mem.zeroes(Event),
        .belief_spike = @import("std").mem.zeroes(Event),
        .predicted_belief = @import("std").mem.zeroes(Event),
        .goal_spike = @import("std").mem.zeroes(Event),
        .precondition_beliefs = @import("std").mem.zeroes([11]Table),
        .priority = 0,
        .processID = 0,
        .processID2 = 0,
        .processID3 = 0,
        .lastSelectionTime = 0,
    };
    _ = &sourceConcept;
    var table: Table = Table{
        .array = [1]Implication{
            Implication{
                .term = Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
                .truth = @import("std").mem.zeroes(Truth),
                .stamp = @import("std").mem.zeroes(Stamp),
                .occurrenceTimeOffset = 0,
                .sourceConcept = null,
                .sourceConceptId = 0,
                .creationTime = 0,
            },
        } ++ [1]Implication{@import("std").mem.zeroes(Implication)} ** 19,
        .itemsAmount = 0,
    };
    _ = &table;
    {
        var i: c_int = @as(c_int, 20) * @as(c_int, 2);
        _ = &i;
        while (i >= @as(c_int, 1)) : (i -= 1) {
            var imp: Implication = Implication{
                .term = Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("test"))))),
                .truth = Truth{
                    .frequency = 1.0,
                    .confidence = 1.0 / @as(f64, @floatFromInt(i + @as(c_int, 1))),
                },
                .stamp = Stamp{
                    .evidentalBase = [1]c_long{
                        @as(c_long, @bitCast(@as(c_long, i))),
                    } ++ [1]c_long{0} ** 9,
                },
                .occurrenceTimeOffset = @as(f64, @floatFromInt(@as(c_int, 10))),
                .sourceConcept = @as(?*anyopaque, @ptrCast(&sourceConcept)),
                .sourceConceptId = 0,
                .creationTime = 0,
            };
            _ = &imp;
            _ = Table_Add(&table, &imp);
        }
    }
    {
        var i: c_int = 0;
        _ = &i;
        while (i < @as(c_int, 20)) : (i += 1) {
            Globals_assert(@as(c_long, @bitCast(@as(c_long, i + @as(c_int, 1)))) == table.array[@as(c_uint, @intCast(i))].stamp.evidentalBase[@as(c_uint, @intCast(@as(c_int, 0)))], @as([*c]u8, @ptrCast(@volatileCast(@constCast("Item at table position has to be right")))));
        }
    }
    var imp: Implication = Implication{
        .term = Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("test"))))),
        .truth = Truth{
            .frequency = 1.0,
            .confidence = 0.9,
        },
        .stamp = Stamp{
            .evidentalBase = [1]c_long{
                @as(c_long, @bitCast(@as(c_long, (@as(c_int, 20) * @as(c_int, 2)) + @as(c_int, 1)))),
            } ++ [1]c_long{0} ** 9,
        },
        .occurrenceTimeOffset = @as(f64, @floatFromInt(@as(c_int, 10))),
        .sourceConcept = @as(?*anyopaque, @ptrCast(&sourceConcept)),
        .sourceConceptId = 0,
        .creationTime = 0,
    };
    _ = &imp;
    Globals_assert(table.array[@as(c_uint, @intCast(@as(c_int, 0)))].truth.confidence == 0.5, @as([*c]u8, @ptrCast(@volatileCast(@constCast("The highest confidence one should be the first.")))));
    _ = Table_AddAndRevise(&table, &imp);
    Globals_assert(table.array[@as(c_uint, @intCast(@as(c_int, 0)))].truth.confidence > 0.5, @as([*c]u8, @ptrCast(@volatileCast(@constCast("The revision result should be more confident than the table element that existed.")))));
    _ = puts("<<Table test successful");
}
pub export fn HashTable_Test() void {
    var HTtest: HashTable = undefined;
    _ = &HTtest;
    var HTest_storageptrs: [10][*c]VMItem = undefined;
    _ = &HTest_storageptrs;
    var HTest_storage: [10]VMItem = undefined;
    _ = &HTest_storage;
    var HTest_HT: [10][*c]VMItem = undefined;
    _ = &HTest_HT;
    _ = puts(">>HashTable test start");
    HashTable_INIT(&HTtest, @as([*c]VMItem, @ptrCast(@alignCast(&HTest_storage))), @as([*c][*c]VMItem, @ptrCast(@alignCast(&HTest_storageptrs))), @as([*c][*c]VMItem, @ptrCast(@alignCast(&HTest_HT))), @as(c_int, 10), @as(c_int, 10), @as(Equal, @ptrCast(@alignCast(&Term_Equal))), @as(Hash, @ptrCast(@alignCast(&Term_Hash))));
    Globals_assert(HTtest.VMStack.stackpointer == @as(c_int, 10), @as([*c]u8, @ptrCast(@volatileCast(@constCast("The stack should be full!")))));
    var term1: Term = Narsese_Term(@as([*c]u8, @ptrCast(@volatileCast(@constCast("<a --> b>")))));
    _ = &term1;
    var c1: Concept = Concept{
        .id = @as(c_long, @bitCast(@as(c_long, @as(c_int, 1)))),
        .usage = @import("std").mem.zeroes(Usage),
        .term = term1,
        .belief = @import("std").mem.zeroes(Event),
        .belief_spike = @import("std").mem.zeroes(Event),
        .predicted_belief = @import("std").mem.zeroes(Event),
        .goal_spike = @import("std").mem.zeroes(Event),
        .precondition_beliefs = @import("std").mem.zeroes([11]Table),
        .priority = 0,
        .processID = 0,
        .processID2 = 0,
        .processID3 = 0,
        .lastSelectionTime = 0,
    };
    _ = &c1;
    HashTable_Set(&HTtest, @as(?*anyopaque, @ptrCast(&term1)), @as(?*anyopaque, @ptrCast(&c1)));
    Globals_assert(HTtest.VMStack.stackpointer == (@as(c_int, 10) - @as(c_int, 1)), @as([*c]u8, @ptrCast(@volatileCast(@constCast("One item should be taken off of the stack")))));
    Globals_assert((blk: {
        const tmp = @import("std").zig.c_translation.signedRemainder(c1.term.hash, @as(c_long, @bitCast(@as(c_long, @as(c_int, 10)))));
        if (tmp >= 0) break :blk HTtest.HT + @as(usize, @intCast(tmp)) else break :blk HTtest.HT - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).* != @as([*c]VMItem, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("Item didn't go in right place")))));
    var c1_returned: [*c]Concept = @as([*c]Concept, @ptrCast(@alignCast(HashTable_Get(&HTtest, @as(?*anyopaque, @ptrCast(&term1))))));
    _ = &c1_returned;
    Globals_assert(c1_returned != @as([*c]Concept, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("Returned item is null (1)")))));
    Globals_assert(Term_Equal(&c1.term, &c1_returned.*.term), @as([*c]u8, @ptrCast(@volatileCast(@constCast("Hashtable Get led to different term than we put into (1)")))));
    var term2: Term = Narsese_Term(@as([*c]u8, @ptrCast(@volatileCast(@constCast("<c --> d>")))));
    _ = &term2;
    term2.hash = c1.term.hash;
    var c2: Concept = Concept{
        .id = @as(c_long, @bitCast(@as(c_long, @as(c_int, 2)))),
        .usage = @import("std").mem.zeroes(Usage),
        .term = term2,
        .belief = @import("std").mem.zeroes(Event),
        .belief_spike = @import("std").mem.zeroes(Event),
        .predicted_belief = @import("std").mem.zeroes(Event),
        .goal_spike = @import("std").mem.zeroes(Event),
        .precondition_beliefs = @import("std").mem.zeroes([11]Table),
        .priority = 0,
        .processID = 0,
        .processID2 = 0,
        .processID3 = 0,
        .lastSelectionTime = 0,
    };
    _ = &c2;
    HashTable_Set(&HTtest, @as(?*anyopaque, @ptrCast(&term2)), @as(?*anyopaque, @ptrCast(&c2)));
    var c1_returned_again: [*c]Concept = @as([*c]Concept, @ptrCast(@alignCast(HashTable_Get(&HTtest, @as(?*anyopaque, @ptrCast(&term1))))));
    _ = &c1_returned_again;
    Globals_assert(c1_returned_again != @as([*c]Concept, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("Returned item is null (2)")))));
    Globals_assert(Term_Equal(&c1.term, &c1_returned_again.*.term), @as([*c]u8, @ptrCast(@volatileCast(@constCast("Hashtable Get led to different term than we put into (2)")))));
    var term3: Term = Narsese_Term(@as([*c]u8, @ptrCast(@volatileCast(@constCast("<e --> f>")))));
    _ = &term3;
    term3.hash = c1.term.hash;
    var c3: Concept = Concept{
        .id = @as(c_long, @bitCast(@as(c_long, @as(c_int, 3)))),
        .usage = @import("std").mem.zeroes(Usage),
        .term = term3,
        .belief = @import("std").mem.zeroes(Event),
        .belief_spike = @import("std").mem.zeroes(Event),
        .predicted_belief = @import("std").mem.zeroes(Event),
        .goal_spike = @import("std").mem.zeroes(Event),
        .precondition_beliefs = @import("std").mem.zeroes([11]Table),
        .priority = 0,
        .processID = 0,
        .processID2 = 0,
        .processID3 = 0,
        .lastSelectionTime = 0,
    };
    _ = &c3;
    HashTable_Set(&HTtest, @as(?*anyopaque, @ptrCast(&term3)), @as(?*anyopaque, @ptrCast(&c3)));
    Globals_assert(Term_Equal(@as([*c]Term, @ptrCast(@alignCast((blk: {
        const tmp = @import("std").zig.c_translation.signedRemainder(c1.term.hash, @as(c_long, @bitCast(@as(c_long, @as(c_int, 10)))));
        if (tmp >= 0) break :blk HTtest.HT + @as(usize, @intCast(tmp)) else break :blk HTtest.HT - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*.*.key))), &c1.term), @as([*c]u8, @ptrCast(@volatileCast(@constCast("c1 not there! (1)")))));
    Globals_assert(Term_Equal(@as([*c]Term, @ptrCast(@alignCast(@as([*c]VMItem, @ptrCast(@alignCast((blk: {
        const tmp = @import("std").zig.c_translation.signedRemainder(c1.term.hash, @as(c_long, @bitCast(@as(c_long, @as(c_int, 10)))));
        if (tmp >= 0) break :blk HTtest.HT + @as(usize, @intCast(tmp)) else break :blk HTtest.HT - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*.*.next))).*.key))), &c2.term), @as([*c]u8, @ptrCast(@volatileCast(@constCast("c2 not there! (1)")))));
    Globals_assert(Term_Equal(@as([*c]Term, @ptrCast(@alignCast(@as([*c]VMItem, @ptrCast(@alignCast(@as([*c]VMItem, @ptrCast(@alignCast((blk: {
        const tmp = @import("std").zig.c_translation.signedRemainder(c1.term.hash, @as(c_long, @bitCast(@as(c_long, @as(c_int, 10)))));
        if (tmp >= 0) break :blk HTtest.HT + @as(usize, @intCast(tmp)) else break :blk HTtest.HT - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*.*.next))).*.next))).*.key))), &c3.term), @as([*c]u8, @ptrCast(@volatileCast(@constCast("c3 not there! (1)")))));
    HashTable_Delete(&HTtest, @as(?*anyopaque, @ptrCast(&term2)));
    Globals_assert(@as([*c]Concept, @ptrCast(@alignCast(@as([*c]VMItem, @ptrCast(@alignCast((blk: {
        const tmp = @import("std").zig.c_translation.signedRemainder(c1.term.hash, @as(c_long, @bitCast(@as(c_long, @as(c_int, 10)))));
        if (tmp >= 0) break :blk HTtest.HT + @as(usize, @intCast(tmp)) else break :blk HTtest.HT - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*.*.next))).*.value))).*.id == @as(c_long, @bitCast(@as(c_long, @as(c_int, 3)))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("c3 not there according to id! (2)")))));
    Globals_assert(Term_Equal(@as([*c]Term, @ptrCast(@alignCast((blk: {
        const tmp = @import("std").zig.c_translation.signedRemainder(c1.term.hash, @as(c_long, @bitCast(@as(c_long, @as(c_int, 10)))));
        if (tmp >= 0) break :blk HTtest.HT + @as(usize, @intCast(tmp)) else break :blk HTtest.HT - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*.*.key))), &c1.term), @as([*c]u8, @ptrCast(@volatileCast(@constCast("c1 not there! (2)")))));
    Globals_assert(Term_Equal(@as([*c]Term, @ptrCast(@alignCast(@as([*c]VMItem, @ptrCast(@alignCast((blk: {
        const tmp = @import("std").zig.c_translation.signedRemainder(c1.term.hash, @as(c_long, @bitCast(@as(c_long, @as(c_int, 10)))));
        if (tmp >= 0) break :blk HTtest.HT + @as(usize, @intCast(tmp)) else break :blk HTtest.HT - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*.*.next))).*.key))), &c3.term), @as([*c]u8, @ptrCast(@volatileCast(@constCast("c3 not there! (2)")))));
    HashTable_Delete(&HTtest, @as(?*anyopaque, @ptrCast(&term3)));
    Globals_assert(Term_Equal(@as([*c]Term, @ptrCast(@alignCast((blk: {
        const tmp = @import("std").zig.c_translation.signedRemainder(c1.term.hash, @as(c_long, @bitCast(@as(c_long, @as(c_int, 10)))));
        if (tmp >= 0) break :blk HTtest.HT + @as(usize, @intCast(tmp)) else break :blk HTtest.HT - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*.*.key))), &c1.term), @as([*c]u8, @ptrCast(@volatileCast(@constCast("c1 not there! (3)")))));
    HashTable_Delete(&HTtest, @as(?*anyopaque, @ptrCast(&term1)));
    Globals_assert((blk: {
        const tmp = @import("std").zig.c_translation.signedRemainder(c1.term.hash, @as(c_long, @bitCast(@as(c_long, @as(c_int, 10)))));
        if (tmp >= 0) break :blk HTtest.HT + @as(usize, @intCast(tmp)) else break :blk HTtest.HT - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).* == @as([*c]VMItem, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("Hash table at hash position must be null")))));
    Globals_assert(HTtest.VMStack.stackpointer == @as(c_int, 10), @as([*c]u8, @ptrCast(@volatileCast(@constCast("All elements should be free now")))));
    var HTtest2: HashTable = undefined;
    _ = &HTtest2;
    var HTtest2_storageptrs: [10][*c]VMItem = undefined;
    _ = &HTtest2_storageptrs;
    var HTtest2_storage: [10]VMItem = undefined;
    _ = &HTtest2_storage;
    var HTtest2_HT: [10][*c]VMItem = undefined;
    _ = &HTtest2_HT;
    HashTable_INIT(&HTtest2, @as([*c]VMItem, @ptrCast(@alignCast(&HTtest2_storage))), @as([*c][*c]VMItem, @ptrCast(@alignCast(&HTtest2_storageptrs))), @as([*c][*c]VMItem, @ptrCast(@alignCast(&HTtest2_HT))), @as(c_int, 10), @as(c_int, 10), @as(Equal, @ptrCast(@alignCast(&Narsese_StringEqual))), @as(Hash, @ptrCast(@alignCast(&Narsese_StringHash))));
    var testname: [*c]u8 = @as([*c]u8, @ptrCast(@volatileCast(@constCast("test"))));
    _ = &testname;
    var blockname: [10]u8 = [1]u8{
        0,
    } ++ [1]u8{0} ** 9;
    _ = &blockname;
    _ = strncpy(@as([*c]u8, @ptrCast(@alignCast(&blockname))), testname, @as(c_ulonglong, @bitCast(@as(c_longlong, @as(c_int, 10) - @as(c_int, 1)))));
    HashTable_Set(&HTtest2, @as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&blockname))))), @as(?*anyopaque, @ptrFromInt(@as(c_int, 42))));
    var res: c_long = @as(c_long, @intCast(@intFromPtr(HashTable_Get(&HTtest2, @as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&blockname)))))))));
    _ = &res;
    Globals_assert(res == @as(c_long, @bitCast(@as(c_long, @as(c_int, 42)))), @as([*c]u8, @ptrCast(@volatileCast(@constCast("Result is not right!")))));
    _ = puts(">>HashTable test successul");
}
pub export fn Run_Unit_Tests() void {
    Stamp_Test();
    PriorityQueue_Test();
    Table_Test();
    Memory_Test();
    OccurrenceTimeIndex_Test();
    InvertedAtomIndex_Test();
    Narsese_Test();
    RuleTable_Test();
    Stack_Test();
    HashTable_Test();
}
pub export fn DRAW_LINE(arg_x: f64, arg_y: f64, arg_angle_1: f64, arg_len: c_int, arg_canvas: [*c]u8, arg_symbol: u8) void {
    var x = arg_x;
    _ = &x;
    var y = arg_y;
    _ = &y;
    var angle_1 = arg_angle_1;
    _ = &angle_1;
    var len = arg_len;
    _ = &len;
    var canvas = arg_canvas;
    _ = &canvas;
    var symbol = arg_symbol;
    _ = &symbol;
    var maxX: c_int = 0;
    _ = &maxX;
    while ((@as(c_int, @bitCast(@as(c_uint, (blk: {
        const tmp = maxX;
        if (tmp >= 0) break :blk canvas + @as(usize, @intCast(tmp)) else break :blk canvas - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*))) != @as(c_int, '\n')) and (@as(c_int, @bitCast(@as(c_uint, (blk: {
        const tmp = maxX;
        if (tmp >= 0) break :blk canvas + @as(usize, @intCast(tmp)) else break :blk canvas - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*))) != @as(c_int, 0))) : (maxX += 1) {}
    var maxY: c_int = 0;
    _ = &maxY;
    {
        var k: c_int = maxX;
        _ = &k;
        while (@as(c_int, @bitCast(@as(c_uint, (blk: {
            const tmp = k;
            if (tmp >= 0) break :blk canvas + @as(usize, @intCast(tmp)) else break :blk canvas - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*))) != @as(c_int, 0)) : (k += 1) {
            if (@as(c_int, @bitCast(@as(c_uint, (blk: {
                const tmp = k;
                if (tmp >= 0) break :blk canvas + @as(usize, @intCast(tmp)) else break :blk canvas - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*))) == @as(c_int, '\n')) {
                maxY += 1;
            }
        }
    }
    var dx: f64 = cos(angle_1);
    _ = &dx;
    var dy: f64 = sin(angle_1);
    _ = &dy;
    while ((len > @as(c_int, 0)) and !((((round(x) < @as(f64, @floatFromInt(@as(c_int, 0)))) or (round(x) >= @as(f64, @floatFromInt(maxX)))) or (round(y) < @as(f64, @floatFromInt(@as(c_int, 0))))) or (round(y) >= @as(f64, @floatFromInt(maxY))))) {
        (blk: {
            const tmp = @as(c_int, @intFromFloat((round(y) * @as(f64, @floatFromInt(@as(c_int, 1) + maxX))) + round(x)));
            if (tmp >= 0) break :blk canvas + @as(usize, @intCast(tmp)) else break :blk canvas - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).* = symbol;
        x += dx;
        y += dy * 0.5;
        len -= 1;
    }
}
pub export fn NAR_Alphabet_Test() void {
    NAR_INIT();
    _ = puts(">>NAR Alphabet test start");
    _ = NAR_AddInput(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a"))))), @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 2))))), Truth{
        .frequency = 1.0,
        .confidence = 0.9,
    }, @as(c_int, 0) != 0, @as(f64, @floatFromInt(@as(c_int, 0))));
    {
        var i: c_int = 0;
        _ = &i;
        while (i < @as(c_int, 50)) : (i += 1) {
            var k: c_int = @import("std").zig.c_translation.signedRemainder(i, @as(c_int, 10));
            _ = &k;
            if (@import("std").zig.c_translation.signedRemainder(i, @as(c_int, 3)) == @as(c_int, 0)) {
                var c: [2]u8 = [2]u8{
                    @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 'a') + k)))),
                    0,
                };
                _ = &c;
                _ = NAR_AddInput(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@alignCast(&c)))), @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 2))))), Truth{
                    .frequency = 1.0,
                    .confidence = 0.9,
                }, @as(c_int, 0) != 0, @as(f64, @floatFromInt(@as(c_int, 0))));
            }
            NAR_Cycles(@as(c_int, 1));
            _ = puts("TICK");
        }
    }
    _ = puts("<<NAR Alphabet test successful");
}
pub export var NAR_Procedure_Test_Op_executed: bool = @as(c_int, 0) != 0;
pub export fn NAR_Procedure_Test_Op() Feedback {
    _ = puts("op executed by NAR");
    NAR_Procedure_Test_Op_executed = @as(c_int, 1) != 0;
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub export fn NAR_Procedure_Test() void {
    NAR_INIT();
    _ = puts(">>NAR Procedure test start");
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^op")))), @as(Action, @ptrCast(@alignCast(&NAR_Procedure_Test_Op))));
    _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a"))))));
    NAR_Cycles(@as(c_int, 1));
    _ = puts("---------------");
    _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^op"))))));
    NAR_Cycles(@as(c_int, 1));
    _ = puts("---------------");
    _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("result"))))));
    NAR_Cycles(@as(c_int, 1));
    _ = puts("---------------");
    _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a"))))));
    NAR_Cycles(@as(c_int, 1));
    _ = puts("---------------");
    _ = NAR_AddInputGoal(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("result"))))));
    NAR_Cycles(@as(c_int, 1));
    _ = puts("---------------");
    Globals_assert(NAR_Procedure_Test_Op_executed, @as([*c]u8, @ptrCast(@volatileCast(@constCast("NAR should have executed op!")))));
    _ = puts("<<NAR Procedure test successful");
}
pub export var NAR_Follow_Test_Left_executed: bool = @as(c_int, 0) != 0;
pub export fn NAR_Follow_Test_Left() Feedback {
    _ = puts("left executed by NAR");
    NAR_Follow_Test_Left_executed = @as(c_int, 1) != 0;
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub export var NAR_Follow_Test_Right_executed: bool = @as(c_int, 0) != 0;
pub export fn NAR_Follow_Test_Right() Feedback {
    _ = puts("right executed by NAR");
    NAR_Follow_Test_Right_executed = @as(c_int, 1) != 0;
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub export fn NAR_Follow_Test() void {
    NAR_INIT();
    _ = puts(">>NAR Follow test start");
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^left")))), @as(Action, @ptrCast(@alignCast(&NAR_Follow_Test_Left))));
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^right")))), @as(Action, @ptrCast(@alignCast(&NAR_Follow_Test_Right))));
    var simsteps: c_int = 1000000;
    _ = &simsteps;
    var LEFT: c_int = 0;
    _ = &LEFT;
    var RIGHT: c_int = 1;
    _ = &RIGHT;
    var BALL: c_int = RIGHT;
    _ = &BALL;
    var score: c_int = 0;
    _ = &score;
    var goods: c_int = 0;
    _ = &goods;
    var bads: c_int = 0;
    _ = &bads;
    {
        var i: c_int = 0;
        _ = &i;
        while (i < simsteps) : (i += 1) {
            _ = puts(if (BALL == LEFT) "LEFT" else "RIGHT");
            _ = NAR_AddInputBelief(if (BALL == LEFT) Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("ball_left"))))) else Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("ball_right"))))));
            _ = NAR_AddInputGoal(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("good_nar"))))));
            if (NAR_Follow_Test_Right_executed) {
                if (BALL == RIGHT) {
                    _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("good_nar"))))));
                    _ = printf("(ball=%d) good\n", BALL);
                    score += 1;
                    goods += 1;
                } else {
                    _ = printf("(ball=%d) bad\n", BALL);
                    score -= 1;
                    bads += 1;
                }
                NAR_Follow_Test_Right_executed = @as(c_int, 0) != 0;
            }
            if (NAR_Follow_Test_Left_executed) {
                if (BALL == LEFT) {
                    _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("good_nar"))))));
                    _ = printf("(ball=%d) good\n", BALL);
                    score += 1;
                    goods += 1;
                } else {
                    _ = printf("(ball=%d) bad\n", BALL);
                    score -= 1;
                    bads += 1;
                }
                NAR_Follow_Test_Left_executed = @as(c_int, 0) != 0;
            }
            BALL = @import("std").zig.c_translation.signedRemainder(myrand(), @as(c_int, 2));
            _ = printf("Score %i step%d=\n", score, i);
            Globals_assert(score > -@as(c_int, 100), @as([*c]u8, @ptrCast(@volatileCast(@constCast("too bad score")))));
            Globals_assert(bads < @as(c_int, 500), @as([*c]u8, @ptrCast(@volatileCast(@constCast("too many wrong trials")))));
            if (score >= @as(c_int, 500)) break;
            NAR_Cycles(@as(c_int, 10));
        }
    }
    _ = printf("<<NAR Follow test successful goods=%d bads=%d ratio=%f\n", goods, bads, @as(f64, @floatCast(@as(f32, @floatFromInt(goods)) / (@as(f32, @floatFromInt(goods)) + @as(f32, @floatFromInt(bads))))));
}
pub export var pX: c_int = 5;
pub export var pY: c_int = 5;
pub export var direction: u8 = '>';
pub export var allowAction: bool = @as(c_int, 0) != 0;
pub export fn NAR_Robot_Left() Feedback {
    if (!allowAction) return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
    if (@as(c_int, @bitCast(@as(c_uint, direction))) == @as(c_int, '>')) {
        direction = 'q';
    } else if (@as(c_int, @bitCast(@as(c_uint, direction))) == @as(c_int, 'q')) {
        direction = 'v';
    } else if (@as(c_int, @bitCast(@as(c_uint, direction))) == @as(c_int, 'v')) {
        direction = 'p';
    } else if (@as(c_int, @bitCast(@as(c_uint, direction))) == @as(c_int, 'p')) {
        direction = '<';
    } else if (@as(c_int, @bitCast(@as(c_uint, direction))) == @as(c_int, '<')) {
        direction = 'b';
    } else if (@as(c_int, @bitCast(@as(c_uint, direction))) == @as(c_int, 'b')) {
        direction = '^';
    } else if (@as(c_int, @bitCast(@as(c_uint, direction))) == @as(c_int, '^')) {
        direction = 'd';
    } else if (@as(c_int, @bitCast(@as(c_uint, direction))) == @as(c_int, 'd')) {
        direction = '>';
    }
    allowAction = @as(c_int, 0) != 0;
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub export fn NAR_Robot_Right() Feedback {
    if (!allowAction) return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
    if (@as(c_int, @bitCast(@as(c_uint, direction))) == @as(c_int, '>')) {
        direction = 'd';
    } else if (@as(c_int, @bitCast(@as(c_uint, direction))) == @as(c_int, 'd')) {
        direction = '^';
    } else if (@as(c_int, @bitCast(@as(c_uint, direction))) == @as(c_int, '^')) {
        direction = 'b';
    } else if (@as(c_int, @bitCast(@as(c_uint, direction))) == @as(c_int, 'b')) {
        direction = '<';
    } else if (@as(c_int, @bitCast(@as(c_uint, direction))) == @as(c_int, '<')) {
        direction = 'p';
    } else if (@as(c_int, @bitCast(@as(c_uint, direction))) == @as(c_int, 'p')) {
        direction = 'v';
    } else if (@as(c_int, @bitCast(@as(c_uint, direction))) == @as(c_int, 'v')) {
        direction = 'q';
    } else if (@as(c_int, @bitCast(@as(c_uint, direction))) == @as(c_int, 'q')) {
        direction = '>';
    }
    allowAction = @as(c_int, 0) != 0;
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub const Cell = extern struct {
    wall: bool = @import("std").mem.zeroes(bool),
    food: bool = @import("std").mem.zeroes(bool),
};
pub export var world: [41][21]Cell = [1][21]Cell{
    [1]Cell{
        Cell{
            .wall = @as(c_int, 0) != 0,
            .food = false,
        },
    } ++ [1]Cell{@import("std").mem.zeroes(Cell)} ** 20,
} ++ [1][21]Cell{@import("std").mem.zeroes([21]Cell)} ** 40;
pub export fn Cell_Draw(arg_cell: [*c]Cell) void {
    var cell = arg_cell;
    _ = &cell;
    if (cell.*.wall) {
        _ = fputs("\x1b[97;47m#\x1b[0m", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
    } else {
        if (cell.*.food) {
            _ = fputs("\x1b[32;43m+\x1b[0m", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
        } else {
            _ = fputs("\x1b[30;43m \x1b[0m", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
        }
    }
}
pub export fn Cell_State(arg_i: c_int, arg_j: c_int) u8 {
    var i = arg_i;
    _ = &i;
    var j = arg_j;
    _ = &j;
    if ((((i < @as(c_int, 0)) or (j < @as(c_int, 0))) or (i >= @as(c_int, 41))) or (j >= @as(c_int, 21))) {
        return 'w';
    }
    var cell: [*c]Cell = &world[@as(c_uint, @intCast(i))][@as(c_uint, @intCast(j))];
    _ = &cell;
    if (cell.*.wall) {
        return 'w';
    } else {
        if (cell.*.food) {
            return 'f';
        } else {
            return 'o';
        }
    }
    return 0;
}
pub export fn World_Draw() void {
    {
        var i: c_int = 0;
        _ = &i;
        while (i < @as(c_int, 21)) : (i += 1) {
            {
                var j: c_int = 0;
                _ = &j;
                while (j < @as(c_int, 41)) : (j += 1) {
                    if ((j == pX) and (i == pY)) {
                        var sdir: [2]u8 = [2]u8{
                            direction,
                            0,
                        };
                        _ = &sdir;
                        _ = fputs("\x1b[31;43;1m", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
                        _ = fputs(@as([*c]u8, @ptrCast(@alignCast(&sdir))), __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
                        _ = fputs("\x1b[0m", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
                    } else {
                        Cell_Draw(&world[@as(c_uint, @intCast(j))][@as(c_uint, @intCast(i))]);
                    }
                }
            }
            _ = puts("");
        }
    }
}
pub const Perception = extern struct {
    forward_pX: c_int = @import("std").mem.zeroes(c_int),
    forward_pY: c_int = @import("std").mem.zeroes(c_int),
    viewfield: [3]u8 = @import("std").mem.zeroes([3]u8),
    collision: bool = @import("std").mem.zeroes(bool),
    reward: bool = @import("std").mem.zeroes(bool),
    moved: bool = @import("std").mem.zeroes(bool),
};
pub export fn irand(arg_n: c_int) c_int {
    var n = arg_n;
    _ = &n;
    var r: c_int = undefined;
    _ = &r;
    var rmax: c_int = n * @divTrunc(@as(c_int, 32767), n);
    _ = &rmax;
    while ((blk: {
        const tmp = myrand();
        r = tmp;
        break :blk tmp;
    }) >= rmax) {}
    return @divTrunc(r, @divTrunc(@as(c_int, 32767), n));
}
pub export fn spawnFood(arg_good: bool) void {
    var good = arg_good;
    _ = &good;
    var x: c_int = undefined;
    _ = &x;
    var y: c_int = undefined;
    _ = &y;
    while (true) {
        x = irand(@as(c_int, 41));
        y = irand(@as(c_int, 21));
        if (!world[@as(c_uint, @intCast(x))][@as(c_uint, @intCast(y))].wall and !world[@as(c_uint, @intCast(x))][@as(c_uint, @intCast(y))].food) {
            if (good) {
                world[@as(c_uint, @intCast(x))][@as(c_uint, @intCast(y))].food = @as(c_int, 1) != 0;
            }
            if (!good) {
                world[@as(c_uint, @intCast(x))][@as(c_uint, @intCast(y))].wall = @as(c_int, 1) != 0;
            }
            break;
        }
    }
}
pub export fn overwriteViewfield(arg_distance: c_int, arg_collided_1: [*c]bool, arg_original: [*c]u8, arg_newval: u8) void {
    var distance = arg_distance;
    _ = &distance;
    var collided_1 = arg_collided_1;
    _ = &collided_1;
    var original = arg_original;
    _ = &original;
    var newval = arg_newval;
    _ = &newval;
    if ((@as(c_int, @bitCast(@as(c_uint, newval))) == @as(c_int, 'o')) or (@as(c_int, @intFromBool(collided_1.*)) != 0)) {
        return;
    }
    collided_1.* = @as(c_int, 1) != 0;
    if ((distance > @as(c_int, 2)) and (@as(c_int, @bitCast(@as(c_uint, newval))) == @as(c_int, 'w'))) {
        return;
    }
    original.* = newval;
}
pub export fn Agent_View() Perception {
    var ret: Perception = Perception{
        .forward_pX = 0,
        .forward_pY = 0,
        .viewfield = [3]u8{
            'o',
            'o',
            'o',
        },
        .collision = false,
        .reward = false,
        .moved = false,
    };
    _ = &ret;
    var viewdist: c_int = 50;
    _ = &viewdist;
    var collided_1: [3]bool = [1]bool{
        @as(c_int, 0) != 0,
    } ++ [1]bool{false} ** 2;
    _ = &collided_1;
    {
        var i: c_int = 1;
        _ = &i;
        while (i <= viewdist) : (i += 1) {
            if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                break;
            }
            if (@as(c_int, @bitCast(@as(c_uint, direction))) == @as(c_int, '>')) {
                ret.forward_pX = pX + @as(c_int, 1);
                ret.forward_pY = pY;
                {
                    var I: c_int = 1;
                    _ = &I;
                    while (I <= i) : (I += 1) {
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 0)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))], Cell_State(pX + I, pY + i));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 0)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))], Cell_State(pX + i, pY + I));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 1)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))], Cell_State(pX + i, pY));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 2)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))], Cell_State(pX + i, pY - I));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 2)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))], Cell_State(pX + I, pY - i));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                    }
                }
            }
            if (@as(c_int, @bitCast(@as(c_uint, direction))) == @as(c_int, 'q')) {
                ret.forward_pX = pX + @as(c_int, 1);
                ret.forward_pY = pY + @as(c_int, 1);
                {
                    var I: c_int = 0;
                    _ = &I;
                    while (I < i) : (I += 1) {
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 0)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))], Cell_State(pX - I, pY + i));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 0)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))], Cell_State(pX + I, pY + i));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 1)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))], Cell_State(pX + i, pY + i));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 2)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))], Cell_State(pX + i, pY + I));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 2)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))], Cell_State(pX + i, pY - I));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                    }
                }
            }
            if (@as(c_int, @bitCast(@as(c_uint, direction))) == @as(c_int, 'v')) {
                ret.forward_pX = pX;
                ret.forward_pY = pY + @as(c_int, 1);
                {
                    var I: c_int = 1;
                    _ = &I;
                    while (I <= i) : (I += 1) {
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 0)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))], Cell_State(pX - i, pY + I));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 0)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))], Cell_State(pX - I, pY + i));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 1)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))], Cell_State(pX, pY + i));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 2)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))], Cell_State(pX + I, pY + i));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 2)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))], Cell_State(pX + i, pY + I));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                    }
                }
            }
            if (@as(c_int, @bitCast(@as(c_uint, direction))) == @as(c_int, 'p')) {
                ret.forward_pX = pX - @as(c_int, 1);
                ret.forward_pY = pY + @as(c_int, 1);
                {
                    var I: c_int = 0;
                    _ = &I;
                    while (I < i) : (I += 1) {
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 0)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))], Cell_State(pX - i, pY - I));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 0)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))], Cell_State(pX - i, pY + I));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 1)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))], Cell_State(pX - i, pY + i));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 2)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))], Cell_State(pX - I, pY + i));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 2)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))], Cell_State(pX + I, pY + i));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                    }
                }
            }
            if (@as(c_int, @bitCast(@as(c_uint, direction))) == @as(c_int, '<')) {
                ret.forward_pX = pX - @as(c_int, 1);
                ret.forward_pY = pY;
                {
                    var I: c_int = 1;
                    _ = &I;
                    while (I <= i) : (I += 1) {
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 0)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))], Cell_State(pX - I, pY - i));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 0)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))], Cell_State(pX - i, pY - I));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 1)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))], Cell_State(pX - i, pY));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 2)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))], Cell_State(pX - i, pY + I));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 2)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))], Cell_State(pX - I, pY + i));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                    }
                }
            }
            if (@as(c_int, @bitCast(@as(c_uint, direction))) == @as(c_int, 'b')) {
                ret.forward_pX = pX - @as(c_int, 1);
                ret.forward_pY = pY - @as(c_int, 1);
                {
                    var I: c_int = 0;
                    _ = &I;
                    while (I < i) : (I += 1) {
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 0)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))], Cell_State(pX + I, pY - i));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 0)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))], Cell_State(pX - I, pY - i));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 1)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))], Cell_State(pX - i, pY - i));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 2)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))], Cell_State(pX - i, pY - I));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 2)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))], Cell_State(pX - i, pY + I));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                    }
                }
            }
            if (@as(c_int, @bitCast(@as(c_uint, direction))) == @as(c_int, '^')) {
                ret.forward_pX = pX;
                ret.forward_pY = pY - @as(c_int, 1);
                {
                    var I: c_int = 1;
                    _ = &I;
                    while (I <= i) : (I += 1) {
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 0)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))], Cell_State(pX + i, pY - I));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 0)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))], Cell_State(pX + I, pY - i));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 1)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))], Cell_State(pX, pY - i));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 2)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))], Cell_State(pX - I, pY - i));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 2)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))], Cell_State(pX - i, pY - I));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                    }
                }
            }
            if (@as(c_int, @bitCast(@as(c_uint, direction))) == @as(c_int, 'd')) {
                ret.forward_pX = pX + @as(c_int, 1);
                ret.forward_pY = pY - @as(c_int, 1);
                {
                    var I: c_int = 0;
                    _ = &I;
                    while (I < i) : (I += 1) {
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 0)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))], Cell_State(pX + i, pY + I));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 0)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))], Cell_State(pX + i, pY - I));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 1)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))], Cell_State(pX + i, pY - i));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 2)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))], Cell_State(pX + I, pY - i));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                        overwriteViewfield(i, &collided_1[@as(c_uint, @intCast(@as(c_int, 2)))], &ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))], Cell_State(pX - I, pY - i));
                        if (((@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, 'f')) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'f'))) or (@as(c_int, @bitCast(@as(c_uint, ret.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) == @as(c_int, 'f'))) {
                            break;
                        }
                    }
                }
            }
        }
    }
    var outside: bool = (((ret.forward_pX < @as(c_int, 0)) or (ret.forward_pX >= @as(c_int, 41))) or (ret.forward_pY < @as(c_int, 0))) or (ret.forward_pY >= @as(c_int, 21));
    _ = &outside;
    if ((@as(c_int, @intFromBool(outside)) != 0) or (@as(c_int, @intFromBool(world[@as(c_uint, @intCast(ret.forward_pX))][@as(c_uint, @intCast(ret.forward_pY))].wall)) != 0)) {
        if ((ret.forward_pX != pX) or (ret.forward_pY != pY)) {
            ret.collision = @as(c_int, 1) != 0;
        }
        ret.forward_pX = pX;
        ret.forward_pY = pY;
    }
    if (world[@as(c_uint, @intCast(pX))][@as(c_uint, @intCast(pY))].food) {
        ret.reward = @as(c_int, 1) != 0;
        world[@as(c_uint, @intCast(pX))][@as(c_uint, @intCast(pY))].food = @as(c_int, 0) != 0;
        spawnFood(@as(c_int, 1) != 0);
    }
    if ((ret.forward_pX != pX) or (ret.forward_pY != pY)) {
        ret.moved = @as(c_int, 1) != 0;
    }
    return ret;
}
pub export var eaten: c_int = 0;
pub export var moves: c_int = 0;
pub export fn NAR_Robot_Forward() Feedback {
    if (!allowAction) return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
    var percept: Perception = Agent_View();
    _ = &percept;
    if ((pX != percept.forward_pX) or (pY != percept.forward_pY)) {
        moves += 1;
    }
    pX = percept.forward_pX;
    pY = percept.forward_pY;
    allowAction = @as(c_int, 0) != 0;
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub export fn buildRooms() void {
    var roomsize: c_int = 20;
    _ = &roomsize;
    {
        var x: c_int = 0;
        _ = &x;
        while (x < @as(c_int, 41)) : (x += 1) {
            {
                var y: c_int = 0;
                _ = &y;
                while (y < @as(c_int, 21)) : (y += 1) {
                    if ((@import("std").zig.c_translation.signedRemainder(x, roomsize) == @as(c_int, 0)) or (@import("std").zig.c_translation.signedRemainder(y, roomsize) == @as(c_int, 0))) {
                        world[@as(c_uint, @intCast(x))][@as(c_uint, @intCast(y))].wall = @as(c_int, 1) != 0;
                    }
                    if ((@import("std").zig.c_translation.signedRemainder(x, roomsize) == @as(c_int, 0)) and (@import("std").zig.c_translation.signedRemainder(y, roomsize) == @as(c_int, 0))) {
                        {
                            var k: c_int = -@as(c_int, 2);
                            _ = &k;
                            while (k <= @as(c_int, 2)) : (k += 1) {
                                if ((((((x - @divTrunc(roomsize, @as(c_int, 2))) + k) >= @as(c_int, 0)) and (((y - @divTrunc(roomsize, @as(c_int, 2))) + k) >= @as(c_int, 0))) and (((x - @divTrunc(roomsize, @as(c_int, 2))) + k) < @as(c_int, 41))) and (((y - @divTrunc(roomsize, @as(c_int, 2))) + k) < @as(c_int, 21))) {
                                    world[@as(c_uint, @intCast((x - @divTrunc(roomsize, @as(c_int, 2))) + k))][@as(c_uint, @intCast(y))].wall = @as(c_int, 0) != 0;
                                    world[@as(c_uint, @intCast(x))][@as(c_uint, @intCast((y - @divTrunc(roomsize, @as(c_int, 2))) + k))].wall = @as(c_int, 0) != 0;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
pub export var collided: bool = @as(c_int, 0) != 0;
pub export fn Agent_Invoke() void {
    var percept: Perception = Agent_View();
    _ = &percept;
    var narseseL: [16]u8 = "l_. :|:"[0..7].* ++ [1]u8{0} ** 9;
    _ = &narseseL;
    var narseseM: [16]u8 = "m_. :|:"[0..7].* ++ [1]u8{0} ** 9;
    _ = &narseseM;
    var narseseR: [16]u8 = "r_. :|:"[0..7].* ++ [1]u8{0} ** 9;
    _ = &narseseR;
    narseseL[@as(c_uint, @intCast(@as(c_int, 1)))] = percept.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))];
    narseseM[@as(c_uint, @intCast(@as(c_int, 1)))] = percept.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))];
    narseseR[@as(c_uint, @intCast(@as(c_int, 1)))] = percept.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))];
    if (@as(c_int, @bitCast(@as(c_uint, percept.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) != @as(c_int, 'o')) {
        NAR_AddInputNarsese(@as([*c]u8, @ptrCast(@alignCast(&narseseM))));
    } else if (@as(c_int, @bitCast(@as(c_uint, percept.viewfield[@as(c_uint, @intCast(@as(c_int, 0)))]))) != @as(c_int, 'o')) {
        NAR_AddInputNarsese(@as([*c]u8, @ptrCast(@alignCast(&narseseL))));
    } else if (@as(c_int, @bitCast(@as(c_uint, percept.viewfield[@as(c_uint, @intCast(@as(c_int, 2)))]))) != @as(c_int, 'o')) {
        NAR_AddInputNarsese(@as([*c]u8, @ptrCast(@alignCast(&narseseR))));
    }
    if ((@as(c_int, @intFromBool(percept.moved)) != 0) and (@as(c_int, @intFromBool(collided)) != 0)) {
        collided = @as(c_int, 0) != 0;
        NAR_AddInputNarsese(@as([*c]u8, @ptrCast(@volatileCast(@constCast("(! collision). :|:")))));
    }
    if (@as(c_int, @bitCast(@as(c_uint, percept.viewfield[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, 'w')) {
        collided = @as(c_int, 1) != 0;
    }
    if (percept.reward) {
        eaten += 1;
        NAR_AddInputNarsese(@as([*c]u8, @ptrCast(@volatileCast(@constCast("eaten. :|:")))));
    }
    allowAction = @as(c_int, 1) != 0;
    if (collided) {
        NAR_AddInputNarsese(@as([*c]u8, @ptrCast(@volatileCast(@constCast("(! collision)! :|:")))));
    } else {
        NAR_AddInputNarsese(@as([*c]u8, @ptrCast(@volatileCast(@constCast("eaten! :|:")))));
    }
}
pub export fn NAR_Robot(arg_iterations: c_long) void {
    var iterations = arg_iterations;
    _ = &iterations;
    MOTOR_BABBLING_CHANCE = 0.3;
    _ = puts(">>NAR Robot start");
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^left")))), @as(Action, @ptrCast(@alignCast(&NAR_Robot_Left))));
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^right")))), @as(Action, @ptrCast(@alignCast(&NAR_Robot_Right))));
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^forward")))), @as(Action, @ptrCast(@alignCast(&NAR_Robot_Forward))));
    buildRooms();
    {
        var i: c_int = 0;
        _ = &i;
        while (i < @as(c_int, 23)) : (i += 1) {
            spawnFood(@as(c_int, 1) != 0);
        }
    }
    {
        var i: c_int = 0;
        _ = &i;
        while (i < @as(c_int, 23)) : (i += 1) {
            spawnFood(@as(c_int, 0) != 0);
        }
    }
    var t: c_long = 0;
    _ = &t;
    while (true) {
        t += 1;
        if ((iterations != @as(c_long, @bitCast(@as(c_long, -@as(c_int, 1))))) and (t > iterations)) {
            break;
        }
        _ = fputs("\x1b[1;1H\x1b[2J", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
        World_Draw();
        _ = printf("time=%ld moves=%d move_success_ratio=%f eaten=%d reasonerStep=%ld\n", t, moves, @as(f64, @floatCast(@as(f32, @floatFromInt(moves)) / @as(f32, @floatFromInt(t)))), eaten, currentTime);
        Agent_Invoke();
        if (iterations == @as(c_long, @bitCast(@as(c_long, -@as(c_int, 1))))) {}
    }
}
pub export var NAR_Pong_Left_executed: bool = @as(c_int, 0) != 0;
pub export fn NAR_Pong_Left() Feedback {
    NAR_Pong_Left_executed = @as(c_int, 1) != 0;
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub export var NAR_Pong_Right_executed: bool = @as(c_int, 0) != 0;
pub export fn NAR_Pong_Right() Feedback {
    NAR_Pong_Right_executed = @as(c_int, 1) != 0;
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub export var NAR_Pong_Stop_executed: bool = @as(c_int, 0) != 0;
pub export fn NAR_Pong_Stop() Feedback {
    NAR_Pong_Stop_executed = @as(c_int, 1) != 0;
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub export fn NAR_Pong2(arg_iterations: c_long) void {
    var iterations = arg_iterations;
    _ = &iterations;
    _ = puts(">>NAR Pong start");
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^left")))), @as(Action, @ptrCast(@alignCast(&NAR_Pong_Left))));
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^right")))), @as(Action, @ptrCast(@alignCast(&NAR_Pong_Right))));
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^stop")))), @as(Action, @ptrCast(@alignCast(&NAR_Pong_Stop))));
    var szX: c_int = 50;
    _ = &szX;
    var szY: c_int = 20;
    _ = &szY;
    var ballX: c_int = @divTrunc(szX, @as(c_int, 2));
    _ = &ballX;
    var ballY: c_int = @divTrunc(szY, @as(c_int, 5));
    _ = &ballY;
    var batX: c_int = 20;
    _ = &batX;
    var batVX: c_int = 0;
    _ = &batVX;
    var batWidth: c_int = 6;
    _ = &batWidth;
    var vX: c_int = 1;
    _ = &vX;
    var vY: c_int = 1;
    _ = &vY;
    var hits: c_int = 0;
    _ = &hits;
    var misses: c_int = 0;
    _ = &misses;
    var t: c_int = 0;
    _ = &t;
    while (true) {
        if ((@as(c_long, @bitCast(@as(c_long, blk: {
            const ref = &t;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }))) > iterations) and (iterations != @as(c_long, @bitCast(@as(c_long, -@as(c_int, 1)))))) {
            break;
        }
        while (true) {
            _ = fputs("\x1b[1;1H\x1b[2J", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
            if (!false) break;
        }
        {
            var i: c_int = 0;
            _ = &i;
            while (i < ((batX - batWidth) + @as(c_int, 1))) : (i += 1) {
                _ = fputs(" ", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
            }
        }
        {
            var i: c_int = 0;
            _ = &i;
            while (i < (((batWidth * @as(c_int, 2)) - @as(c_int, 1)) + (if (@as(c_int, 0) < batX) @as(c_int, 0) else batX))) : (i += 1) {
                _ = fputs("@", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
            }
        }
        _ = puts("");
        {
            var i: c_int = 0;
            _ = &i;
            while (i < ballY) : (i += 1) {
                {
                    var k: c_int = 0;
                    _ = &k;
                    while (k < szX) : (k += 1) {
                        _ = fputs(" ", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
                    }
                }
                _ = puts("|");
            }
        }
        {
            var i: c_int = 0;
            _ = &i;
            while (i < ballX) : (i += 1) {
                _ = fputs(" ", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
            }
        }
        _ = fputs("#", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
        {
            var i: c_int = ballX + @as(c_int, 1);
            _ = &i;
            while (i < szX) : (i += 1) {
                _ = fputs(" ", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
            }
        }
        _ = puts("|");
        {
            var i: c_int = ballY + @as(c_int, 1);
            _ = &i;
            while (i < szY) : (i += 1) {
                {
                    var k: c_int = 0;
                    _ = &k;
                    while (k < szX) : (k += 1) {
                        _ = fputs(" ", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
                    }
                }
                _ = puts("|");
            }
        }
        if (batX <= (ballX - batWidth)) {
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("ball_right"))))));
        } else if ((ballX + batWidth) < batX) {
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("ball_left"))))));
        } else {
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("ball_equal"))))));
        }
        _ = NAR_AddInputGoal(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("good_nar"))))));
        if (ballX <= @as(c_int, 0)) {
            vX = 1;
        }
        if (ballX >= (szX - @as(c_int, 1))) {
            vX = -@as(c_int, 1);
        }
        if (ballY <= @as(c_int, 0)) {
            vY = 1;
        }
        if (ballY >= (szY - @as(c_int, 1))) {
            vY = -@as(c_int, 1);
        }
        if (@import("std").zig.c_translation.signedRemainder(t, @as(c_int, 2)) == -@as(c_int, 1)) {
            ballX += vX;
        }
        ballY += vY;
        if (ballY == @as(c_int, 0)) {
            if (abs(ballX - batX) <= batWidth) {
                _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("good_nar"))))));
                _ = puts("good");
                hits += 1;
            } else {
                _ = puts("bad");
                misses += 1;
            }
        }
        if (((ballY == @as(c_int, 0)) or (ballX == @as(c_int, 0))) or (ballX >= (szX - @as(c_int, 1)))) {
            ballY = @divTrunc(szY, @as(c_int, 2)) + @import("std").zig.c_translation.signedRemainder(myrand(), @divTrunc(szY, @as(c_int, 2)));
            ballX = @import("std").zig.c_translation.signedRemainder(myrand(), szX);
            vX = if (@import("std").zig.c_translation.signedRemainder(myrand(), @as(c_int, 2)) == @as(c_int, 0)) @as(c_int, 1) else -@as(c_int, 1);
        }
        if (NAR_Pong_Left_executed) {
            NAR_Pong_Left_executed = @as(c_int, 0) != 0;
            _ = puts("Exec: op_left");
            batVX = -@as(c_int, 3);
        }
        if (NAR_Pong_Right_executed) {
            NAR_Pong_Right_executed = @as(c_int, 0) != 0;
            _ = puts("Exec: op_right");
            batVX = 3;
        }
        if (NAR_Pong_Stop_executed) {
            NAR_Pong_Stop_executed = @as(c_int, 0) != 0;
            _ = puts("Exec: op_stop");
            batVX = 0;
        }
        batX = if ((-batWidth * @as(c_int, 2)) > (if (((szX - @as(c_int, 1)) + batWidth) < (batX + @divTrunc(batVX * batWidth, @as(c_int, 2)))) (szX - @as(c_int, 1)) + batWidth else batX + @divTrunc(batVX * batWidth, @as(c_int, 2)))) -batWidth * @as(c_int, 2) else if (((szX - @as(c_int, 1)) + batWidth) < (batX + @divTrunc(batVX * batWidth, @as(c_int, 2)))) (szX - @as(c_int, 1)) + batWidth else batX + @divTrunc(batVX * batWidth, @as(c_int, 2));
        _ = printf("Hits=%d misses=%d ratio=%f time=%d\n", hits, misses, @as(f64, @floatCast(@as(f32, @floatFromInt(hits)) / (@as(f32, @floatFromInt(hits)) + @as(f32, @floatFromInt(misses))))), t);
        if (iterations == @as(c_long, @bitCast(@as(c_long, -@as(c_int, 1))))) {}
        NAR_Cycles(@as(c_int, 5));
    }
}
pub export fn NAR_Pong(arg_iterations: c_long) void {
    var iterations = arg_iterations;
    _ = &iterations;
    _ = puts(">>NAR Pong start");
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^left")))), @as(Action, @ptrCast(@alignCast(&NAR_Pong_Left))));
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^right")))), @as(Action, @ptrCast(@alignCast(&NAR_Pong_Right))));
    var szX: c_int = 50;
    _ = &szX;
    var szY: c_int = 20;
    _ = &szY;
    var ballX: c_int = @divTrunc(szX, @as(c_int, 2));
    _ = &ballX;
    var ballY: c_int = @divTrunc(szY, @as(c_int, 5));
    _ = &ballY;
    var batX: c_int = 20;
    _ = &batX;
    var batVX: c_int = 0;
    _ = &batVX;
    var batWidth: c_int = 4;
    _ = &batWidth;
    var vX: c_int = 1;
    _ = &vX;
    var vY: c_int = 1;
    _ = &vY;
    var hits: c_int = 0;
    _ = &hits;
    var misses: c_int = 0;
    _ = &misses;
    var t: c_int = 0;
    _ = &t;
    while (true) {
        if ((@as(c_long, @bitCast(@as(c_long, blk: {
            const ref = &t;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }))) > iterations) and (iterations != @as(c_long, @bitCast(@as(c_long, -@as(c_int, 1)))))) {
            break;
        }
        while (true) {
            _ = fputs("\x1b[1;1H\x1b[2J", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
            if (!false) break;
        }
        {
            var i: c_int = 0;
            _ = &i;
            while (i < ((batX - batWidth) + @as(c_int, 1))) : (i += 1) {
                _ = fputs(" ", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
            }
        }
        {
            var i: c_int = 0;
            _ = &i;
            while (i < ((batWidth * @as(c_int, 2)) - @as(c_int, 1))) : (i += 1) {
                _ = fputs("@", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
            }
        }
        _ = puts("");
        {
            var i: c_int = 0;
            _ = &i;
            while (i < ballY) : (i += 1) {
                {
                    var k: c_int = 0;
                    _ = &k;
                    while (k < szX) : (k += 1) {
                        _ = fputs(" ", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
                    }
                }
                _ = puts("|");
            }
        }
        {
            var i: c_int = 0;
            _ = &i;
            while (i < ballX) : (i += 1) {
                _ = fputs(" ", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
            }
        }
        _ = fputs("#", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
        {
            var i: c_int = ballX + @as(c_int, 1);
            _ = &i;
            while (i < szX) : (i += 1) {
                _ = fputs(" ", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
            }
        }
        _ = puts("|");
        {
            var i: c_int = ballY + @as(c_int, 1);
            _ = &i;
            while (i < szY) : (i += 1) {
                {
                    var k: c_int = 0;
                    _ = &k;
                    while (k < szX) : (k += 1) {
                        _ = fputs(" ", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
                    }
                }
                _ = puts("|");
            }
        }
        if (batX < ballX) {
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("ball_right"))))));
        }
        if (ballX < batX) {
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("ball_left"))))));
        }
        _ = NAR_AddInputGoal(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("good_nar"))))));
        if (ballX <= @as(c_int, 0)) {
            vX = 1;
        }
        if (ballX >= (szX - @as(c_int, 1))) {
            vX = -@as(c_int, 1);
        }
        if (ballY <= @as(c_int, 0)) {
            vY = 1;
        }
        if (ballY >= (szY - @as(c_int, 1))) {
            vY = -@as(c_int, 1);
        }
        ballX += vX;
        ballY += vY;
        if (ballY == @as(c_int, 0)) {
            if (abs(ballX - batX) <= batWidth) {
                _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("good_nar"))))));
                _ = puts("good");
                hits += 1;
            } else {
                _ = puts("bad");
                misses += 1;
            }
        }
        if (((ballY == @as(c_int, 0)) or (ballX == @as(c_int, 0))) or (ballX >= (szX - @as(c_int, 1)))) {
            ballY = @divTrunc(szY, @as(c_int, 2)) + @import("std").zig.c_translation.signedRemainder(myrand(), @divTrunc(szY, @as(c_int, 2)));
            ballX = @import("std").zig.c_translation.signedRemainder(myrand(), szX);
            vX = if (@import("std").zig.c_translation.signedRemainder(myrand(), @as(c_int, 2)) == @as(c_int, 0)) @as(c_int, 1) else -@as(c_int, 1);
        }
        if (NAR_Pong_Left_executed) {
            NAR_Pong_Left_executed = @as(c_int, 0) != 0;
            _ = puts("Exec: op_left");
            batVX = -@as(c_int, 2);
        }
        if (NAR_Pong_Right_executed) {
            NAR_Pong_Right_executed = @as(c_int, 0) != 0;
            _ = puts("Exec: op_right");
            batVX = 2;
        }
        batX = if (@as(c_int, 0) > (if ((szX - @as(c_int, 1)) < (batX + @divTrunc(batVX * batWidth, @as(c_int, 2)))) szX - @as(c_int, 1) else batX + @divTrunc(batVX * batWidth, @as(c_int, 2)))) @as(c_int, 0) else if ((szX - @as(c_int, 1)) < (batX + @divTrunc(batVX * batWidth, @as(c_int, 2)))) szX - @as(c_int, 1) else batX + @divTrunc(batVX * batWidth, @as(c_int, 2));
        _ = printf("Hits=%d misses=%d ratio=%f time=%d\n", hits, misses, @as(f64, @floatCast(@as(f32, @floatFromInt(hits)) / (@as(f32, @floatFromInt(hits)) + @as(f32, @floatFromInt(misses))))), t);
        if (iterations == @as(c_long, @bitCast(@as(c_long, -@as(c_int, 1))))) {}
        NAR_Cycles(@as(c_int, 5));
    }
}
pub var velocity: f64 = 0.0;
pub var angle: f64 = -3.1415 / 2.0;
pub var angle_velocity: f64 = 0.0;
pub var position: f64 = 0.0;
pub var max_angle_velocity: f64 = 0.3;
pub fn NAR_CP_Left() callconv(.C) Feedback {
    var reverse: f64 = @as(f64, @floatFromInt(if (angle > @as(f64, @floatFromInt(@as(c_int, 0)))) @as(c_int, 1) else -@as(c_int, 1)));
    _ = &reverse;
    {
        angle_velocity -= reverse * 0.2;
    }
    velocity -= 0.1;
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub fn NAR_CP_Right() callconv(.C) Feedback {
    var reverse: f64 = @as(f64, @floatFromInt(if (angle > @as(f64, @floatFromInt(@as(c_int, 0)))) @as(c_int, 1) else -@as(c_int, 1)));
    _ = &reverse;
    {
        angle_velocity += reverse * 0.2;
    }
    velocity += 0.1;
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub var successes: f64 = 0;
pub var failures: f64 = 0;
pub export fn NAR_Cartpole(arg_iterations: c_long) void {
    var iterations = arg_iterations;
    _ = &iterations;
    var initial: [115:0]u8 = "                     |\n                     |\n     -----------     |\n                     |\n                     |\n".*;
    _ = &initial;
    var t: c_int = 0;
    _ = &t;
    _ = puts(">>NAR CP start");
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^left")))), @as(Action, @ptrCast(@alignCast(&NAR_CP_Left))));
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^right")))), @as(Action, @ptrCast(@alignCast(&NAR_CP_Right))));
    while (true) {
        position += velocity;
        position = if (0.0 > (if (1.0 < position) 1.0 else position)) 0.0 else if (1.0 < position) 1.0 else position;
        angle += angle_velocity;
        while (true) {
            _ = fputs("\x1b[1;1H\x1b[2J", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
            if (!false) break;
        }
        var world_1: [116]u8 = undefined;
        _ = &world_1;
        _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&world_1))))), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&initial))))), @sizeOf([116]u8));
        DRAW_LINE(@as(f64, @floatFromInt(@as(c_int, 10))) + (position * @as(f64, @floatFromInt(@as(c_int, 5)))), @as(f64, @floatFromInt(@as(c_int, 2))), angle, @as(c_int, 5), @as([*c]u8, @ptrCast(@alignCast(&world_1))), @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 'o'))))));
        _ = puts(@as([*c]u8, @ptrCast(@alignCast(&world_1))));
        angle_velocity += 0.2 * cos(angle);
        if (angle_velocity > max_angle_velocity) {
            angle_velocity = max_angle_velocity;
        }
        if (angle_velocity < -max_angle_velocity) {
            angle_velocity = -max_angle_velocity;
        }
        var PI: f64 = 3.1415;
        _ = &PI;
        if (angle > PI) {
            angle = -PI;
        }
        if (angle < -PI) {
            angle = PI;
        }
        if ((@as(c_long, @bitCast(@as(c_long, blk: {
            const ref = &t;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }))) > iterations) and (iterations != @as(c_long, @bitCast(@as(c_long, -@as(c_int, 1)))))) {
            break;
        }
        _ = printf("position=%f, velocity=%f, angle=%f, angleV=%f\nsuccesses=%f, failures=%f, ratio=%f, time=%d\n", position, velocity, angle, angle_velocity, successes, failures, successes / (successes + failures), t);
        velocity = 0.0;
        if (fabs(angle - (-PI / 2.0)) <= 0.5) {
            NAR_AddInputNarsese(@as([*c]u8, @ptrCast(@volatileCast(@constCast("good. :|:")))));
            successes += 1.0;
        } else if ((angle >= @as(f64, @floatFromInt(@as(c_int, 0)))) and (angle <= PI)) {
            failures += 1.0;
        }
        var str: [20]u8 = [1]u8{
            0,
        } ++ [1]u8{0} ** 19;
        _ = &str;
        var encodingInt: c_int = @as(c_int, @intFromFloat(((angle + PI) / (@as(f64, @floatFromInt(@as(c_int, 2))) * PI)) * @as(f64, @floatFromInt(@as(c_int, 8)))));
        _ = &encodingInt;
        _ = sprintf(@as([*c]u8, @ptrCast(@alignCast(&str))), "%d. :|:", encodingInt);
        NAR_AddInputNarsese(@as([*c]u8, @ptrCast(@alignCast(&str))));
        NAR_AddInputNarsese(@as([*c]u8, @ptrCast(@volatileCast(@constCast("good! :|:")))));
        NAR_Cycles(@as(c_int, 3));
        _ = fflush(__acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
        if (iterations == @as(c_long, @bitCast(@as(c_long, -@as(c_int, 1))))) {}
    }
}
pub export var NAR_Lightswitch_GotoSwitch_executed: bool = @as(c_int, 0) != 0;
pub export fn NAR_Lightswitch_GotoSwitch() Feedback {
    NAR_Lightswitch_GotoSwitch_executed = @as(c_int, 1) != 0;
    _ = puts("NAR invoked goto switch");
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub export var NAR_Lightswitch_ActivateSwitch_executed: bool = @as(c_int, 0) != 0;
pub export fn NAR_Lightswitch_ActivateSwitch() Feedback {
    NAR_Lightswitch_ActivateSwitch_executed = @as(c_int, 1) != 0;
    _ = puts("NAR invoked activate switch");
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub export fn NAR_Multistep_Test() void {
    MOTOR_BABBLING_CHANCE = 0;
    _ = puts(">>NAR Multistep test start");
    NAR_INIT();
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^goto_switch")))), @as(Action, @ptrCast(@alignCast(&NAR_Lightswitch_GotoSwitch))));
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^activate_switch")))), @as(Action, @ptrCast(@alignCast(&NAR_Lightswitch_ActivateSwitch))));
    {
        var i: c_int = 0;
        _ = &i;
        while (i < @as(c_int, 5)) : (i += 1) {
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("start_at"))))));
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^goto_switch"))))));
            NAR_Cycles(@as(c_int, 1));
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("switch_at"))))));
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^activate_switch"))))));
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("switch_active"))))));
            NAR_Cycles(@as(c_int, 1));
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("light_active"))))));
            NAR_Cycles(@as(c_int, 10));
        }
    }
    NAR_Cycles(@as(c_int, 10));
    _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("start_at"))))));
    _ = NAR_AddInputGoal(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("light_active"))))));
    NAR_Cycles(@as(c_int, 10));
    Globals_assert((@as(c_int, @intFromBool(NAR_Lightswitch_GotoSwitch_executed)) != 0) and !NAR_Lightswitch_ActivateSwitch_executed, @as([*c]u8, @ptrCast(@volatileCast(@constCast("NAR needs to go to the switch first")))));
    NAR_Lightswitch_GotoSwitch_executed = @as(c_int, 0) != 0;
    _ = puts("NAR arrived at the switch");
    _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("switch_at"))))));
    _ = NAR_AddInputGoal(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("light_active"))))));
    Globals_assert(!NAR_Lightswitch_GotoSwitch_executed and (@as(c_int, @intFromBool(NAR_Lightswitch_ActivateSwitch_executed)) != 0), @as([*c]u8, @ptrCast(@volatileCast(@constCast("NAR needs to activate the switch")))));
    NAR_Lightswitch_ActivateSwitch_executed = @as(c_int, 0) != 0;
    _ = puts("<<NAR Multistep test successful");
}
pub export fn NAR_Multistep2_Test() void {
    MOTOR_BABBLING_CHANCE = 0;
    _ = puts(">>NAR Multistep2 test start");
    NAR_INIT();
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^goto_switch")))), @as(Action, @ptrCast(@alignCast(&NAR_Lightswitch_GotoSwitch))));
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^activate_switch")))), @as(Action, @ptrCast(@alignCast(&NAR_Lightswitch_ActivateSwitch))));
    {
        var i: c_int = 0;
        _ = &i;
        while (i < @as(c_int, 5)) : (i += 1) {
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("start_at"))))));
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^goto_switch"))))));
            NAR_Cycles(@as(c_int, 1));
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("switch_at"))))));
            NAR_Cycles(@as(c_int, 10));
        }
    }
    NAR_Cycles(@as(c_int, 1000));
    {
        var i: c_int = 0;
        _ = &i;
        while (i < @as(c_int, 5)) : (i += 1) {
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("switch_at"))))));
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^activate_switch"))))));
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("switch_active"))))));
            NAR_Cycles(@as(c_int, 1));
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("light_active"))))));
            NAR_Cycles(@as(c_int, 10));
        }
    }
    NAR_Cycles(@as(c_int, 10));
    _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("start_at"))))));
    _ = NAR_AddInputGoal(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("light_active"))))));
    NAR_Cycles(@as(c_int, 10));
    Globals_assert((@as(c_int, @intFromBool(NAR_Lightswitch_GotoSwitch_executed)) != 0) and !NAR_Lightswitch_ActivateSwitch_executed, @as([*c]u8, @ptrCast(@volatileCast(@constCast("NAR needs to go to the switch first (2)")))));
    NAR_Lightswitch_GotoSwitch_executed = @as(c_int, 0) != 0;
    _ = puts("NAR arrived at the switch");
    _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("switch_at"))))));
    _ = NAR_AddInputGoal(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("light_active"))))));
    Globals_assert(!NAR_Lightswitch_GotoSwitch_executed and (@as(c_int, @intFromBool(NAR_Lightswitch_ActivateSwitch_executed)) != 0), @as([*c]u8, @ptrCast(@volatileCast(@constCast("NAR needs to activate the switch (2)")))));
    NAR_Lightswitch_ActivateSwitch_executed = @as(c_int, 0) != 0;
    _ = puts("<<NAR Multistep2 test successful");
}
pub var goto_s0: bool = @as(c_int, 0) != 0;
pub var goto_s1: bool = @as(c_int, 0) != 0;
pub var goto_s2: bool = @as(c_int, 0) != 0;
pub var goto_s3: bool = @as(c_int, 0) != 0;
pub var goto_l0: bool = @as(c_int, 0) != 0;
pub var goto_l1: bool = @as(c_int, 0) != 0;
pub var activate: bool = @as(c_int, 0) != 0;
pub var deactivate: bool = @as(c_int, 0) != 0;
pub export fn NAR_TestChamber_goto_s0() Feedback {
    goto_s0 = @as(c_int, 1) != 0;
    _ = puts("NAR goto s0");
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub export fn NAR_TestChamber_goto_s1() Feedback {
    goto_s1 = @as(c_int, 1) != 0;
    _ = puts("NAR goto s1");
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub export fn NAR_TestChamber_goto_s2() Feedback {
    goto_s2 = @as(c_int, 1) != 0;
    _ = puts("NAR goto s2");
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub export fn NAR_TestChamber_goto_s3() Feedback {
    goto_s3 = @as(c_int, 1) != 0;
    _ = puts("NAR goto s3");
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub export fn NAR_TestChamber_goto_l0() Feedback {
    goto_l0 = @as(c_int, 1) != 0;
    _ = puts("NAR goto l0");
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub export fn NAR_TestChamber_goto_l1() Feedback {
    goto_l1 = @as(c_int, 1) != 0;
    _ = puts("NAR goto l1");
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub export fn NAR_TestChamber_activate() Feedback {
    activate = @as(c_int, 1) != 0;
    _ = puts("NAR activate");
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub export fn NAR_TestChamber_deactivate() Feedback {
    deactivate = @as(c_int, 1) != 0;
    _ = puts("NAR deactivate");
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub export fn NAR_TestChamber() void {
    MOTOR_BABBLING_CHANCE = 0;
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^goto_s0")))), @as(Action, @ptrCast(@alignCast(&NAR_TestChamber_goto_s0))));
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^goto_s1")))), @as(Action, @ptrCast(@alignCast(&NAR_TestChamber_goto_s1))));
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^goto_s2")))), @as(Action, @ptrCast(@alignCast(&NAR_TestChamber_goto_s2))));
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^goto_s3")))), @as(Action, @ptrCast(@alignCast(&NAR_TestChamber_goto_s3))));
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^goto_l0")))), @as(Action, @ptrCast(@alignCast(&NAR_TestChamber_goto_l0))));
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^goto_l1")))), @as(Action, @ptrCast(@alignCast(&NAR_TestChamber_goto_l1))));
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^activate")))), @as(Action, @ptrCast(@alignCast(&NAR_TestChamber_activate))));
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^deactivate")))), @as(Action, @ptrCast(@alignCast(&NAR_TestChamber_deactivate))));
    var goals: c_int = 0;
    _ = &goals;
    var reached: c_int = 0;
    _ = &reached;
    var size: c_int = 7;
    _ = &size;
    var world_1: [7][13]u8 = [7][13]u8{
        "_________    ",
        "| l0  s2| s1 ",
        "| (0)-0 |-0  ",
        "|_______|    ",
        "          s0 ",
        " l1  s3   .< ",
        " (0)-0       ",
    };
    _ = &world_1;
    const pos_s0: c_int = 0;
    _ = &pos_s0;
    const pos_s1: c_int = 1;
    _ = &pos_s1;
    const pos_s2: c_int = 2;
    _ = &pos_s2;
    const pos_s3: c_int = 3;
    _ = &pos_s3;
    const pos_l0: c_int = 4;
    _ = &pos_l0;
    const pos_l1: c_int = 5;
    _ = &pos_l1;
    var pos: c_int = pos_s0;
    _ = &pos;
    var s1: bool = @as(c_int, 0) != 0;
    _ = &s1;
    var s2: bool = @as(c_int, 0) != 0;
    _ = &s2;
    var s3: bool = @as(c_int, 0) != 0;
    _ = &s3;
    var l0: bool = @as(c_int, 0) != 0;
    _ = &l0;
    var l1: bool = @as(c_int, 0) != 0;
    _ = &l1;
    var door: bool = @as(c_int, 0) != 0;
    _ = &door;
    var lastcommand: u8 = 'a';
    _ = &lastcommand;
    var c: u8 = ' ';
    _ = &c;
    var nongoal: [*c]u8 = @as([*c]u8, @ptrCast(@volatileCast(@constCast("none"))));
    _ = &nongoal;
    var goal: [*c]u8 = nongoal;
    _ = &goal;
    while (true) {
        if (goto_s0) {
            goto_s0 = @as(c_int, 0) != 0;
            pos = pos_s0;
        } else if (goto_s1) {
            goto_s1 = @as(c_int, 0) != 0;
            pos = pos_s1;
        } else if (goto_s3) {
            goto_s3 = @as(c_int, 0) != 0;
            pos = pos_s3;
        } else if (goto_l1) {
            goto_l1 = @as(c_int, 0) != 0;
            pos = pos_l1;
        } else if (goto_l0) {
            goto_l0 = @as(c_int, 0) != 0;
            if (door) {
                pos = pos_l0;
            }
        } else if (goto_s2) {
            goto_s2 = @as(c_int, 0) != 0;
            if (door) {
                pos = pos_s2;
            }
        }
        if (!((@as(c_int, @intFromBool(activate)) != 0) or (@as(c_int, @intFromBool(deactivate)) != 0))) {
            if (pos == pos_s0) {
                _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("at_s0"))))));
                if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) == @as(c_int, 'u')) {
                    reached += 1;
                }
            }
            if (pos == pos_s1) {
                _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("at_s1"))))));
                if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) == @as(c_int, 'v')) {
                    reached += 1;
                }
            }
            if (pos == pos_s2) {
                _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("at_s2"))))));
                if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) == @as(c_int, 'w')) {
                    reached += 1;
                }
            }
            if (pos == pos_s3) {
                _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("at_s3"))))));
                if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) == @as(c_int, 'x')) {
                    reached += 1;
                }
            }
            if (pos == pos_l0) {
                _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("at_l0"))))));
                if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) == @as(c_int, 'y')) {
                    reached += 1;
                }
            }
            if (pos == pos_l1) {
                _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("at_l1"))))));
                if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) == @as(c_int, 'z')) {
                    reached += 1;
                }
            }
        }
        var deactivated: bool = deactivate;
        _ = &deactivated;
        var activated: bool = activate;
        _ = &activated;
        deactivate = blk: {
            const tmp = @as(c_int, 0) != 0;
            activate = tmp;
            break :blk tmp;
        };
        if ((pos == pos_s1) and ((@as(c_int, @intFromBool(deactivated)) != 0) or (!s1 and !activated))) {
            s1 = @as(c_int, 0) != 0;
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("s1_is_0"))))));
            if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) == @as(c_int, 'l')) {
                reached += 1;
            }
            door = @as(c_int, 0) != 0;
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("door_is_closed"))))));
            if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) == @as(c_int, 'j')) {
                reached += 1;
            }
        } else if ((pos == pos_s2) and ((@as(c_int, @intFromBool(deactivated)) != 0) or (!s2 and !activated))) {
            s2 = @as(c_int, 0) != 0;
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("s2_is_0"))))));
            if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) == @as(c_int, 'n')) {
                reached += 1;
            }
            l0 = @as(c_int, 0) != 0;
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("l0_is_0"))))));
            if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) == @as(c_int, 'r')) {
                reached += 1;
            }
        } else if ((pos == pos_s3) and ((@as(c_int, @intFromBool(deactivated)) != 0) or (!s3 and !activated))) {
            s3 = @as(c_int, 0) != 0;
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("s3_is_0"))))));
            if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) == @as(c_int, 'p')) {
                reached += 1;
            }
            l1 = @as(c_int, 0) != 0;
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("l1_is_0"))))));
            if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) == @as(c_int, 't')) {
                reached += 1;
            }
        } else if ((pos == pos_s1) and ((@as(c_int, @intFromBool(activated)) != 0) or (@as(c_int, @intFromBool(s1)) != 0))) {
            s1 = @as(c_int, 1) != 0;
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("s1_is_1"))))));
            if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) == @as(c_int, 'k')) {
                reached += 1;
            }
            door = @as(c_int, 1) != 0;
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("door_is_open"))))));
            if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) == @as(c_int, 'i')) {
                reached += 1;
            }
        } else if ((pos == pos_s2) and ((@as(c_int, @intFromBool(activated)) != 0) or (@as(c_int, @intFromBool(s2)) != 0))) {
            s2 = @as(c_int, 1) != 0;
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("s2_is_1"))))));
            if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) == @as(c_int, 'm')) {
                reached += 1;
            }
            l0 = @as(c_int, 1) != 0;
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("l0_is_1"))))));
            if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) == @as(c_int, 'q')) {
                reached += 1;
            }
        } else if ((pos == pos_s3) and ((@as(c_int, @intFromBool(activated)) != 0) or (@as(c_int, @intFromBool(s3)) != 0))) {
            s3 = @as(c_int, 1) != 0;
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("s3_is_1"))))));
            if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) == @as(c_int, 'o')) {
                reached += 1;
            }
            l1 = @as(c_int, 1) != 0;
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("l1_is_1"))))));
            if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) == @as(c_int, 's')) {
                reached += 1;
            }
        }
        world_1[@as(c_uint, @intCast(@as(c_int, 6)))][@as(c_uint, @intCast(@as(c_int, 6)))] = blk: {
            const tmp = blk_1: {
                const tmp_2 = blk_2: {
                    const tmp_3 = blk_3: {
                        const tmp_4 = blk_4: {
                            const tmp_5 = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, ' ')))));
                            world_1[@as(c_uint, @intCast(@as(c_int, 2)))][@as(c_uint, @intCast(@as(c_int, 1)))] = tmp_5;
                            break :blk_4 tmp_5;
                        };
                        world_1[@as(c_uint, @intCast(@as(c_int, 2)))][@as(c_uint, @intCast(@as(c_int, 7)))] = tmp_4;
                        break :blk_3 tmp_4;
                    };
                    world_1[@as(c_uint, @intCast(@as(c_int, 2)))][@as(c_uint, @intCast(@as(c_int, 11)))] = tmp_3;
                    break :blk_2 tmp_3;
                };
                world_1[@as(c_uint, @intCast(@as(c_int, 5)))][@as(c_uint, @intCast(@as(c_int, 11)))] = tmp_2;
                break :blk_1 tmp_2;
            };
            world_1[@as(c_uint, @intCast(@as(c_int, 6)))][@as(c_uint, @intCast(@as(c_int, 0)))] = tmp;
            break :blk tmp;
        };
        if (pos == pos_s3) {
            world_1[@as(c_uint, @intCast(@as(c_int, 6)))][@as(c_uint, @intCast(@as(c_int, 6)))] = '<';
        }
        if (pos == pos_l1) {
            world_1[@as(c_uint, @intCast(@as(c_int, 6)))][@as(c_uint, @intCast(@as(c_int, 0)))] = '<';
        }
        if (pos == pos_s0) {
            world_1[@as(c_uint, @intCast(@as(c_int, 5)))][@as(c_uint, @intCast(@as(c_int, 11)))] = '<';
        }
        if (pos == pos_s1) {
            world_1[@as(c_uint, @intCast(@as(c_int, 2)))][@as(c_uint, @intCast(@as(c_int, 11)))] = '<';
        }
        if (pos == pos_s2) {
            world_1[@as(c_uint, @intCast(@as(c_int, 2)))][@as(c_uint, @intCast(@as(c_int, 7)))] = '<';
        }
        if (pos == pos_l0) {
            world_1[@as(c_uint, @intCast(@as(c_int, 2)))][@as(c_uint, @intCast(@as(c_int, 1)))] = '<';
        }
        if (l0) {
            world_1[@as(c_uint, @intCast(@as(c_int, 2)))][@as(c_uint, @intCast(@as(c_int, 3)))] = '1';
        } else {
            world_1[@as(c_uint, @intCast(@as(c_int, 2)))][@as(c_uint, @intCast(@as(c_int, 3)))] = '0';
        }
        if (s2) {
            world_1[@as(c_uint, @intCast(@as(c_int, 2)))][@as(c_uint, @intCast(@as(c_int, 6)))] = '1';
        } else {
            world_1[@as(c_uint, @intCast(@as(c_int, 2)))][@as(c_uint, @intCast(@as(c_int, 6)))] = '0';
        }
        if (s1) {
            world_1[@as(c_uint, @intCast(@as(c_int, 2)))][@as(c_uint, @intCast(@as(c_int, 10)))] = '1';
        } else {
            world_1[@as(c_uint, @intCast(@as(c_int, 2)))][@as(c_uint, @intCast(@as(c_int, 10)))] = '0';
        }
        if (l1) {
            world_1[@as(c_uint, @intCast(@as(c_int, 6)))][@as(c_uint, @intCast(@as(c_int, 2)))] = '1';
        } else {
            world_1[@as(c_uint, @intCast(@as(c_int, 6)))][@as(c_uint, @intCast(@as(c_int, 2)))] = '0';
        }
        if (s3) {
            world_1[@as(c_uint, @intCast(@as(c_int, 6)))][@as(c_uint, @intCast(@as(c_int, 5)))] = '1';
        } else {
            world_1[@as(c_uint, @intCast(@as(c_int, 6)))][@as(c_uint, @intCast(@as(c_int, 5)))] = '0';
        }
        if (door) {
            world_1[@as(c_uint, @intCast(@as(c_int, 2)))][@as(c_uint, @intCast(@as(c_int, 8)))] = ' ';
        } else {
            world_1[@as(c_uint, @intCast(@as(c_int, 2)))][@as(c_uint, @intCast(@as(c_int, 8)))] = '|';
        }
        while (true) {
            _ = fputs("\x1b[1;1H\x1b[2J", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
            if (!false) break;
        }
        _ = puts("\n---------------\nNew iteration\nCommands:");
        _ = puts("a ... goto s0");
        _ = puts("b ... goto s1");
        _ = puts("c ... goto s2");
        _ = puts("d ... goto s3");
        _ = puts("e ... goto l0");
        _ = puts("f ... goto l1");
        _ = puts("g ... activate");
        _ = puts("h ... deactivate");
        _ = puts("i ... door should be open!");
        _ = puts("j ... door should be closed!");
        _ = puts("k ... s1 should be 1!");
        _ = puts("l ... s1 should be 0!");
        _ = puts("m ... s2 should be 1!");
        _ = puts("n ... s2 should be 0!");
        _ = puts("o ... s3 should be 1!");
        _ = puts("p ... s3 should be 0!");
        _ = puts("q ... l0 should be 1!");
        _ = puts("r ... l0 should be 0!");
        _ = puts("s ... l1 should be 1!");
        _ = puts("t ... l1 should be 0!");
        _ = puts("u ... you should be at s0!");
        _ = puts("v ... you should be at s1!");
        _ = puts("w ... you should be at s2!");
        _ = puts("x ... you should be at s3!");
        _ = puts("y ... you should be at l0!");
        _ = puts("z ... you should be at l1!");
        _ = puts("other ... Next timestep (same command)\n");
        {
            var i: c_int = 0;
            _ = &i;
            while (i < size) : (i += 1) {
                {
                    var j: c_int = 0;
                    _ = &j;
                    while (j < @as(c_int, 13)) : (j += 1) {
                        _ = putchar(@as(c_int, @bitCast(@as(c_uint, world_1[@as(c_uint, @intCast(i))][@as(c_uint, @intCast(j))]))));
                    }
                }
                _ = puts("");
            }
        }
        _ = printf("\nCurrent goal: %s", goal);
        _ = printf("\ngoals=%d, reached=%d, ratio=%f \n", goals, reached, @as(f64, @floatCast(@as(f32, @floatFromInt(reached)) / @as(f32, @floatFromInt(goals)))));
        _ = puts("\nCommand:");
        var probe: u8 = '\n';
        _ = &probe;
        if ((@as(c_int, @bitCast(@as(c_uint, c))) >= @as(c_int, 'a')) and (@as(c_int, @bitCast(@as(c_uint, c))) <= @as(c_int, 'z'))) {
            probe = @as(u8, @bitCast(@as(i8, @truncate(getchar()))));
            if (@as(c_int, @bitCast(@as(c_uint, c))) == @as(c_int, 'Q')) {
                exit(@as(c_int, 0));
            }
        }
        if ((@as(c_int, @bitCast(@as(c_uint, probe))) >= @as(c_int, 'a')) and (@as(c_int, @bitCast(@as(c_uint, probe))) <= @as(c_int, 'z'))) {
            c = probe;
        } else {
            c = @as(u8, @bitCast(@as(i8, @truncate(getchar()))));
            if (@as(c_int, @bitCast(@as(c_uint, c))) == @as(c_int, 'Q')) {
                exit(@as(c_int, 0));
            }
        }
        var command: u8 = c;
        _ = &command;
        if (!((@as(c_int, @bitCast(@as(c_uint, c))) >= @as(c_int, 'a')) and (@as(c_int, @bitCast(@as(c_uint, c))) <= @as(c_int, 'z')))) {
            if ((@as(c_int, @bitCast(@as(c_uint, lastcommand))) >= @as(c_int, 'i')) and (@as(c_int, @bitCast(@as(c_uint, lastcommand))) <= @as(c_int, 'z'))) {
                command = lastcommand;
            }
        }
        if (@as(c_int, @bitCast(@as(c_uint, command))) == @as(c_int, 'a')) {
            goto_s0 = @as(c_int, 1) != 0;
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^goto_s0"))))));
        }
        if (@as(c_int, @bitCast(@as(c_uint, command))) == @as(c_int, 'b')) {
            goto_s1 = @as(c_int, 1) != 0;
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^goto_s1"))))));
        }
        if (@as(c_int, @bitCast(@as(c_uint, command))) == @as(c_int, 'c')) {
            goto_s2 = @as(c_int, 1) != 0;
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^goto_s2"))))));
        }
        if (@as(c_int, @bitCast(@as(c_uint, command))) == @as(c_int, 'd')) {
            goto_s3 = @as(c_int, 1) != 0;
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^goto_s3"))))));
        }
        if (@as(c_int, @bitCast(@as(c_uint, command))) == @as(c_int, 'e')) {
            goto_l0 = @as(c_int, 1) != 0;
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^goto_l0"))))));
        }
        if (@as(c_int, @bitCast(@as(c_uint, command))) == @as(c_int, 'f')) {
            goto_l1 = @as(c_int, 1) != 0;
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^goto_l1"))))));
        }
        if (@as(c_int, @bitCast(@as(c_uint, command))) == @as(c_int, 'g')) {
            activate = @as(c_int, 1) != 0;
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^activate"))))));
        }
        if (@as(c_int, @bitCast(@as(c_uint, command))) == @as(c_int, 'h')) {
            deactivate = @as(c_int, 1) != 0;
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^deactivate"))))));
        }
        goal = nongoal;
        if (@as(c_int, @bitCast(@as(c_uint, command))) == @as(c_int, 'i')) {
            _ = NAR_AddInputGoal(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("door_is_open"))))));
            goal = "door should be open!";
            if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) != @as(c_int, 'i')) {
                goals += 1;
            }
        }
        if (@as(c_int, @bitCast(@as(c_uint, command))) == @as(c_int, 'j')) {
            _ = NAR_AddInputGoal(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("door_is_closed"))))));
            goal = "door should be closed!";
            if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) != @as(c_int, 'j')) {
                goals += 1;
            }
        }
        if (@as(c_int, @bitCast(@as(c_uint, command))) == @as(c_int, 'k')) {
            _ = NAR_AddInputGoal(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("s1_is_1"))))));
            goal = "s1 should be 1!";
            if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) != @as(c_int, 'k')) {
                goals += 1;
            }
        }
        if (@as(c_int, @bitCast(@as(c_uint, command))) == @as(c_int, 'l')) {
            _ = NAR_AddInputGoal(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("s1_is_0"))))));
            goal = "s1 should be 0!";
            if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) != @as(c_int, 'l')) {
                goals += 1;
            }
        }
        if (@as(c_int, @bitCast(@as(c_uint, command))) == @as(c_int, 'm')) {
            _ = NAR_AddInputGoal(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("s2_is_1"))))));
            goal = "s2 should be 1!";
            if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) != @as(c_int, 'm')) {
                goals += 1;
            }
        }
        if (@as(c_int, @bitCast(@as(c_uint, command))) == @as(c_int, 'n')) {
            _ = NAR_AddInputGoal(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("s2_is_0"))))));
            goal = "s2 should be 0!";
            if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) != @as(c_int, 'n')) {
                goals += 1;
            }
        }
        if (@as(c_int, @bitCast(@as(c_uint, command))) == @as(c_int, 'o')) {
            _ = NAR_AddInputGoal(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("s3_is_1"))))));
            goal = "s3 should be 1!";
            if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) != @as(c_int, 'o')) {
                goals += 1;
            }
        }
        if (@as(c_int, @bitCast(@as(c_uint, command))) == @as(c_int, 'p')) {
            _ = NAR_AddInputGoal(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("s3_is_0"))))));
            goal = "s3 should be 0!";
            if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) != @as(c_int, 'p')) {
                goals += 1;
            }
        }
        if (@as(c_int, @bitCast(@as(c_uint, command))) == @as(c_int, 'q')) {
            _ = NAR_AddInputGoal(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("l0_is_1"))))));
            goal = "l0 should be 1!";
            if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) != @as(c_int, 'q')) {
                goals += 1;
            }
        }
        if (@as(c_int, @bitCast(@as(c_uint, command))) == @as(c_int, 'r')) {
            _ = NAR_AddInputGoal(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("l0_is_0"))))));
            goal = "l0 should be 0!";
            if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) != @as(c_int, 'r')) {
                goals += 1;
            }
        }
        if (@as(c_int, @bitCast(@as(c_uint, command))) == @as(c_int, 's')) {
            _ = NAR_AddInputGoal(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("l1_is_1"))))));
            goal = "l1 should be 1!";
            if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) != @as(c_int, 's')) {
                goals += 1;
            }
        }
        if (@as(c_int, @bitCast(@as(c_uint, command))) == @as(c_int, 't')) {
            _ = NAR_AddInputGoal(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("l1_is_0"))))));
            goal = "l1 should be 0!";
            if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) != @as(c_int, 't')) {
                goals += 1;
            }
        }
        if (@as(c_int, @bitCast(@as(c_uint, command))) == @as(c_int, 'u')) {
            _ = NAR_AddInputGoal(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("at_s0"))))));
            goal = "you should be at s0!";
            if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) != @as(c_int, 'u')) {
                goals += 1;
            }
        }
        if (@as(c_int, @bitCast(@as(c_uint, command))) == @as(c_int, 'v')) {
            _ = NAR_AddInputGoal(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("at_s1"))))));
            goal = "you should be at s1!";
            if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) != @as(c_int, 'v')) {
                goals += 1;
            }
        }
        if (@as(c_int, @bitCast(@as(c_uint, command))) == @as(c_int, 'w')) {
            _ = NAR_AddInputGoal(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("at_s2"))))));
            goal = "you should be at s2!";
            if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) != @as(c_int, 'w')) {
                goals += 1;
            }
        }
        if (@as(c_int, @bitCast(@as(c_uint, command))) == @as(c_int, 'x')) {
            _ = NAR_AddInputGoal(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("at_s3"))))));
            goal = "you should be at s3!";
            if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) != @as(c_int, 'x')) {
                goals += 1;
            }
        }
        if (@as(c_int, @bitCast(@as(c_uint, command))) == @as(c_int, 'y')) {
            _ = NAR_AddInputGoal(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("at_l0"))))));
            goal = "you should be at l0!";
            if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) != @as(c_int, 'y')) {
                goals += 1;
            }
        }
        if (@as(c_int, @bitCast(@as(c_uint, command))) == @as(c_int, 'z')) {
            _ = NAR_AddInputGoal(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("at_l1"))))));
            goal = "you should be at l1!";
            if (@as(c_int, @bitCast(@as(c_uint, lastcommand))) != @as(c_int, 'z')) {
                goals += 1;
            }
        }
        lastcommand = command;
    }
}
pub export var op_1_executed: bool = @as(c_int, 0) != 0;
pub export fn op_1() Feedback {
    op_1_executed = @as(c_int, 1) != 0;
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub export var op_2_executed: bool = @as(c_int, 0) != 0;
pub export fn op_2() Feedback {
    op_2_executed = @as(c_int, 1) != 0;
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub export var op_3_executed: bool = @as(c_int, 0) != 0;
pub export fn op_3() Feedback {
    op_3_executed = @as(c_int, 1) != 0;
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub export fn NAR_Sequence_Test() void {
    NAR_INIT();
    MOTOR_BABBLING_CHANCE = 0;
    _ = puts(">>Sequence test start");
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^1")))), @as(Action, @ptrCast(@alignCast(&op_1))));
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^2")))), @as(Action, @ptrCast(@alignCast(&op_2))));
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^3")))), @as(Action, @ptrCast(@alignCast(&op_3))));
    {
        var i: c_int = 0;
        _ = &i;
        while (i < @as(c_int, 5)) : (i += 1) {
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a"))))));
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b"))))));
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^1"))))));
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("g"))))));
            NAR_Cycles(@as(c_int, 100));
        }
    }
    {
        var i: c_int = 0;
        _ = &i;
        while (i < @as(c_int, 100)) : (i += 1) {
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a"))))));
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^1"))))));
            NAR_Cycles(@as(c_int, 100));
        }
    }
    {
        var i: c_int = 0;
        _ = &i;
        while (i < @as(c_int, 100)) : (i += 1) {
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b"))))));
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^1"))))));
            NAR_Cycles(@as(c_int, 100));
        }
    }
    {
        var i: c_int = 0;
        _ = &i;
        while (i < @as(c_int, 2)) : (i += 1) {
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b"))))));
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^2"))))));
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("g"))))));
            NAR_Cycles(@as(c_int, 100));
        }
    }
    {
        var i: c_int = 0;
        _ = &i;
        while (i < @as(c_int, 2)) : (i += 1) {
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a"))))));
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^3"))))));
            _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("g"))))));
            NAR_Cycles(@as(c_int, 100));
        }
    }
    _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a"))))));
    _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b"))))));
    _ = NAR_AddInputGoal(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("g"))))));
    Globals_assert(((@as(c_int, @intFromBool(op_1_executed)) != 0) and !op_2_executed) and !op_3_executed, @as([*c]u8, @ptrCast(@volatileCast(@constCast("Expected op1 execution")))));
    op_1_executed = blk: {
        const tmp = blk_1: {
            const tmp_2 = @as(c_int, 0) != 0;
            op_3_executed = tmp_2;
            break :blk_1 tmp_2;
        };
        op_2_executed = tmp;
        break :blk tmp;
    };
    NAR_Cycles(@as(c_int, 100));
    _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("b"))))));
    _ = NAR_AddInputGoal(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("g"))))));
    Globals_assert((!op_1_executed and (@as(c_int, @intFromBool(op_2_executed)) != 0)) and !op_3_executed, @as([*c]u8, @ptrCast(@volatileCast(@constCast("Expected op2 execution")))));
    op_1_executed = blk: {
        const tmp = blk_1: {
            const tmp_2 = @as(c_int, 0) != 0;
            op_3_executed = tmp_2;
            break :blk_1 tmp_2;
        };
        op_2_executed = tmp;
        break :blk tmp;
    };
    NAR_Cycles(@as(c_int, 100));
    _ = NAR_AddInputBelief(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("a"))))));
    _ = NAR_AddInputGoal(Narsese_AtomicTerm(@as([*c]u8, @ptrCast(@volatileCast(@constCast("g"))))));
    Globals_assert((!op_1_executed and !op_2_executed) and (@as(c_int, @intFromBool(op_3_executed)) != 0), @as([*c]u8, @ptrCast(@volatileCast(@constCast("Expected op3 execution")))));
    op_1_executed = blk: {
        const tmp = blk_1: {
            const tmp_2 = @as(c_int, 0) != 0;
            op_3_executed = tmp_2;
            break :blk_1 tmp_2;
        };
        op_2_executed = tmp;
        break :blk tmp;
    };
    MOTOR_BABBLING_CHANCE = 0.2;
    _ = puts(">>Sequence Test successul");
}
pub export var NAR_Alien_Left_executed: bool = @as(c_int, 0) != 0;
pub export fn NAR_Alien_Left() Feedback {
    _ = puts("NAR invoked left");
    NAR_Alien_Left_executed = @as(c_int, 1) != 0;
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub export var NAR_Alien_Right_executed: bool = @as(c_int, 0) != 0;
pub export fn NAR_Alien_Right() Feedback {
    _ = puts("NAR invoked right");
    NAR_Alien_Right_executed = @as(c_int, 1) != 0;
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub export var NAR_Alien_Shoot_executed: bool = @as(c_int, 0) != 0;
pub export fn NAR_Alien_Shoot() Feedback {
    _ = puts("NAR invoked shoot");
    NAR_Alien_Shoot_executed = @as(c_int, 1) != 0;
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub export fn NAR_Alien(arg_iterations: c_long) void {
    var iterations = arg_iterations;
    _ = &iterations;
    _ = puts(">>NAR Alien1 start");
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^left")))), @as(Action, @ptrCast(@alignCast(&NAR_Alien_Left))));
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^right")))), @as(Action, @ptrCast(@alignCast(&NAR_Alien_Right))));
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^shoot")))), @as(Action, @ptrCast(@alignCast(&NAR_Alien_Shoot))));
    var alien0X: f64 = 0.5;
    _ = &alien0X;
    var defenderX: f64 = 0.5;
    _ = &defenderX;
    var alienWidth: f64 = 0.18;
    _ = &alienWidth;
    var batWidth: c_int = 1;
    _ = &batWidth;
    var szX: c_int = 20;
    _ = &szX;
    var szY: c_int = 6;
    _ = &szY;
    var hits: c_int = 0;
    _ = &hits;
    var shots: c_int = 0;
    _ = &shots;
    var t: c_int = 0;
    _ = &t;
    while (true) {
        var shot: bool = @as(c_int, 0) != 0;
        _ = &shot;
        var hit: bool = @as(c_int, 0) != 0;
        _ = &hit;
        var cond1: bool = defenderX <= (alien0X - alienWidth);
        _ = &cond1;
        var cond2: bool = defenderX > (alien0X + alienWidth);
        _ = &cond2;
        if (cond1) {
            _ = NAR_AddInputBelief(Narsese_Term(@as([*c]u8, @ptrCast(@volatileCast(@constCast("r0"))))));
        } else if (cond2) {
            _ = NAR_AddInputBelief(Narsese_Term(@as([*c]u8, @ptrCast(@volatileCast(@constCast("l0"))))));
        } else {
            _ = NAR_AddInputBelief(Narsese_Term(@as([*c]u8, @ptrCast(@volatileCast(@constCast("c0"))))));
        }
        _ = NAR_AddInputGoal(Narsese_Term(@as([*c]u8, @ptrCast(@volatileCast(@constCast("s0"))))));
        if (NAR_Alien_Shoot_executed) {
            shot = @as(c_int, 1) != 0;
            NAR_Alien_Shoot_executed = @as(c_int, 0) != 0;
            shots += 1;
            if (!cond1 and !cond2) {
                hit = @as(c_int, 1) != 0;
                hits += 1;
                _ = NAR_AddInputBelief(Narsese_Term(@as([*c]u8, @ptrCast(@volatileCast(@constCast("s0"))))));
                alien0X = @as(f64, @floatFromInt(@import("std").zig.c_translation.signedRemainder(myrand(), @as(c_int, 1000)))) / 1000.0;
            }
        }
        if (NAR_Alien_Left_executed) {
            NAR_Alien_Left_executed = @as(c_int, 0) != 0;
            defenderX = if (0.0 > (defenderX - 0.1)) 0.0 else defenderX - 0.1;
        }
        if (NAR_Alien_Right_executed) {
            NAR_Alien_Right_executed = @as(c_int, 0) != 0;
            defenderX = if (1.0 < (defenderX + 0.1)) 1.0 else defenderX + 0.1;
        }
        var batX: c_int = @as(c_int, @intFromFloat(defenderX * @as(f64, @floatFromInt(@as(c_int, 10)))));
        _ = &batX;
        var ballY: c_int = 5;
        _ = &ballY;
        var ballX: c_int = @as(c_int, @intFromFloat(alien0X * @as(f64, @floatFromInt(@as(c_int, 10)))));
        _ = &ballX;
        if ((@as(c_long, @bitCast(@as(c_long, blk: {
            const ref = &t;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }))) > iterations) and (iterations != @as(c_long, @bitCast(@as(c_long, -@as(c_int, 1)))))) {
            break;
        }
        if ((iterations == @as(c_long, @bitCast(@as(c_long, -@as(c_int, 1))))) and (@import("std").zig.c_translation.signedRemainder(t, @as(c_int, 10000)) == @as(c_int, 0))) {
            _ = getchar();
        }
        while (true) {
            _ = fputs("\x1b[1;1H\x1b[2J", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
            if (!false) break;
        }
        {
            var i: c_int = 0;
            _ = &i;
            while (i < ((batX - batWidth) + @as(c_int, 1))) : (i += 1) {
                _ = fputs(" ", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
            }
        }
        {
            var i: c_int = 0;
            _ = &i;
            while (i < ((batWidth * @as(c_int, 2)) - @as(c_int, 1))) : (i += 1) {
                _ = fputs(if (@as(c_int, @intFromBool(shot)) != 0) ":" else "'", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
            }
        }
        _ = puts("");
        {
            var i: c_int = 0;
            _ = &i;
            while (i < ballY) : (i += 1) {
                {
                    var k: c_int = 0;
                    _ = &k;
                    while (k < szX) : (k += 1) {
                        _ = fputs(" ", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
                    }
                }
                _ = puts("|");
            }
        }
        {
            var i: c_int = 0;
            _ = &i;
            while (i < ballX) : (i += 1) {
                _ = fputs(" ", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
            }
        }
        _ = fputs(if (@as(c_int, @intFromBool(hit)) != 0) "_" else "o", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
        {
            var i: c_int = ballX + @as(c_int, 1);
            _ = &i;
            while (i < szX) : (i += 1) {
                _ = fputs(" ", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
            }
        }
        _ = puts("|");
        {
            var i: c_int = ballY + @as(c_int, 1);
            _ = &i;
            while (i < szY) : (i += 1) {
                {
                    var k: c_int = 0;
                    _ = &k;
                    while (k < szX) : (k += 1) {
                        _ = fputs(" ", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
                    }
                }
                _ = puts("|");
            }
        }
        _ = printf("shots=%d hits=%d ratio=%f time=%d\n", shots, hits, @as(f64, @floatCast(@as(f32, @floatFromInt(hits)) / @as(f32, @floatFromInt(shots)))), t);
        if (iterations == @as(c_long, @bitCast(@as(c_long, -@as(c_int, 1))))) {}
    }
}
pub extern fn Shell_Start(...) void;
pub extern fn Shell_NARInit(...) void;
pub extern fn Shell_ProcessInput(line: [*c]u8) c_int;
pub export var NAR_Bandrobot_Left_executed: bool = @as(c_int, 0) != 0;
pub export var NAR_Bandrobot_amount: f64 = @import("std").mem.zeroes(f64);
pub export fn NAR_Bandrobot_Left(arg_args: Term) Feedback {
    var args = arg_args;
    _ = &args;
    NAR_Bandrobot_Left_executed = @as(c_int, 1) != 0;
    NAR_Bandrobot_amount = 1.0;
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub export var NAR_Bandrobot_Right_executed: bool = @as(c_int, 0) != 0;
pub export fn NAR_Bandrobot_Right(arg_args: Term) Feedback {
    var args = arg_args;
    _ = &args;
    NAR_Bandrobot_Right_executed = @as(c_int, 1) != 0;
    NAR_Bandrobot_amount = 1.0;
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub export var NAR_Bandrobot_Pick_executed: bool = @as(c_int, 0) != 0;
pub export fn NAR_Bandrobot_Pick() Feedback {
    NAR_Bandrobot_Pick_executed = @as(c_int, 1) != 0;
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub export var NAR_Bandrobot_Drop_executed: bool = @as(c_int, 0) != 0;
pub export fn NAR_Bandrobot_Drop() Feedback {
    NAR_Bandrobot_Drop_executed = @as(c_int, 1) != 0;
    return Feedback{
        .subs = Substitution{
            .map = [1]Term{
                Term{
                    .hashed = @as(c_int, 0) != 0,
                    .hash = 0,
                    .atoms = @import("std").mem.zeroes([64]c_ushort),
                },
            } ++ [1]Term{@import("std").mem.zeroes(Term)} ** 27,
            .success = false,
            .truth = @import("std").mem.zeroes(Truth),
        },
        .failed = false,
    };
}
pub export fn NAR_Bandrobot(arg_iterations: c_long) void {
    var iterations = arg_iterations;
    _ = &iterations;
    var initial: [138:0]u8 = "+++++++++++++++++++++|\n---------------------|\n                     |\n                     |\n                     |\n'''''''''''''''''''''|\n".*;
    _ = &initial;
    _ = puts(">>NAR Bandrobot start");
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^left")))), &NAR_Bandrobot_Left);
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^right")))), &NAR_Bandrobot_Right);
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^pick")))), @as(Action, @ptrCast(@alignCast(&NAR_Bandrobot_Pick))));
    NAR_AddOperation(@as([*c]u8, @ptrCast(@volatileCast(@constCast("^drop")))), @as(Action, @ptrCast(@alignCast(&NAR_Bandrobot_Drop))));
    _ = Shell_ProcessInput(@as([*c]u8, @ptrCast(@volatileCast(@constCast("*questionpriming=0.0")))));
    var t: c_long = 0;
    _ = &t;
    var minpos: c_int = @as(c_int, @intFromFloat(0.0));
    _ = &minpos;
    var maxpos: c_int = @as(c_int, @intFromFloat(20.0));
    _ = &maxpos;
    var position_1: c_int = 0;
    _ = &position_1;
    var targetposition: c_int = 1;
    _ = &targetposition;
    var goalposition: c_int = 3;
    _ = &goalposition;
    var picked: bool = @as(c_int, 0) != 0;
    _ = &picked;
    var lastpicked: bool = @as(c_int, 0) != 0;
    _ = &lastpicked;
    var hasObj: bool = @as(c_int, 0) != 0;
    _ = &hasObj;
    var successes_2: c_int = 0;
    _ = &successes_2;
    while (true) {
        if (((blk: {
            const ref = &t;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }) > iterations) and (iterations != @as(c_long, @bitCast(@as(c_long, -@as(c_int, 1)))))) {
            break;
        }
        if (NAR_Bandrobot_Left_executed) {
            NAR_Bandrobot_Left_executed = @as(c_int, 0) != 0;
            position_1 -= @as(c_int, @intFromFloat(NAR_Bandrobot_amount));
        }
        if (NAR_Bandrobot_Right_executed) {
            NAR_Bandrobot_Right_executed = @as(c_int, 0) != 0;
            position_1 += @as(c_int, @intFromFloat(NAR_Bandrobot_amount));
        }
        position_1 = if (maxpos < (if (minpos > position_1) minpos else position_1)) maxpos else if (minpos > position_1) minpos else position_1;
        if (picked) {
            targetposition = position_1;
        }
        if (NAR_Bandrobot_Pick_executed) {
            NAR_Bandrobot_Pick_executed = @as(c_int, 0) != 0;
            if (position_1 == targetposition) {
                picked = @as(c_int, 1) != 0;
                hasObj = @as(c_int, 1) != 0;
            }
        }
        if (NAR_Bandrobot_Drop_executed) {
            NAR_Bandrobot_Drop_executed = @as(c_int, 0) != 0;
            picked = @as(c_int, 0) != 0;
            hasObj = @as(c_int, 0) != 0;
        }
        while (true) {
            _ = fputs("\x1b[1;1H\x1b[2J", __acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
            if (!false) break;
        }
        var world_1: [139]u8 = undefined;
        _ = &world_1;
        _ = memcpy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&world_1))))), @as(?*const anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&initial))))), @sizeOf([139]u8));
        DRAW_LINE(@as(f64, @floatFromInt(position_1)), @as(f64, @floatFromInt(@as(c_int, 2))), @as(f64, @floatFromInt(@as(c_int, 0))), @as(c_int, 1), @as([*c]u8, @ptrCast(@alignCast(&world_1))), @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 'A'))))));
        DRAW_LINE(@as(f64, @floatFromInt(targetposition)), @as(f64, @floatFromInt(if (@as(c_int, @intFromBool(picked)) != 0) @as(c_int, 3) else @as(c_int, 4))), @as(f64, @floatFromInt(@as(c_int, 0))), @as(c_int, 1), @as([*c]u8, @ptrCast(@alignCast(&world_1))), @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 'o'))))));
        DRAW_LINE(@as(f64, @floatFromInt(goalposition)), @as(f64, @floatFromInt(@as(c_int, 5))), @as(f64, @floatFromInt(@as(c_int, 0))), @as(c_int, 1), @as([*c]u8, @ptrCast(@alignCast(&world_1))), @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, 'U'))))));
        var propname: [*c]const u8 = if (@as(c_int, @intFromBool(hasObj)) != 0) "dropPosX" else "pickPosX";
        _ = &propname;
        var questionStr: [2148]u8 = [1]u8{
            0,
        } ++ [1]u8{0} ** 2147;
        _ = &questionStr;
        _ = sprintf(@as([*c]u8, @ptrCast(@alignCast(&questionStr))), "%s%s%s", "<({?1} * {?2}) --> (+ ", propname, ")>? :\\:\x00");
        NAR_AddInputNarsese(@as([*c]u8, @ptrCast(@alignCast(&questionStr))));
        _ = puts(@as([*c]u8, @ptrCast(@alignCast(&world_1))));
        var positionStr: [2148]u8 = [1]u8{
            0,
        } ++ [1]u8{0} ** 2147;
        _ = &positionStr;
        var v_position: f32 = @as(f32, @floatCast(if (1.0 < (if (0.0 > @as(f64, @floatCast(@as(f32, @floatFromInt(position_1 - minpos)) / @as(f32, @floatFromInt(maxpos - minpos))))) 0.0 else @as(f64, @floatCast(@as(f32, @floatFromInt(position_1 - minpos)) / @as(f32, @floatFromInt(maxpos - minpos)))))) 1.0 else if (0.0 > @as(f64, @floatCast(@as(f32, @floatFromInt(position_1 - minpos)) / @as(f32, @floatFromInt(maxpos - minpos))))) 0.0 else @as(f64, @floatCast(@as(f32, @floatFromInt(position_1 - minpos)) / @as(f32, @floatFromInt(maxpos - minpos))))));
        _ = &v_position;
        _ = sprintf(@as([*c]u8, @ptrCast(@alignCast(&positionStr))), "%s%s%s%f%s", "<{position} |-> [", propname, "]>. :|: %", @as(f64, @floatCast(v_position)), "%\x00");
        NAR_AddInputNarsese(@as([*c]u8, @ptrCast(@alignCast(&positionStr))));
        var targetpositionStr: [2148]u8 = [1]u8{
            0,
        } ++ [1]u8{0} ** 2147;
        _ = &targetpositionStr;
        var used_position: f64 = @as(f64, @floatFromInt(if (@as(c_int, @intFromBool(hasObj)) != 0) goalposition else targetposition));
        _ = &used_position;
        var v_usedposition: f32 = @as(f32, @floatCast(if (1.0 < (if (0.0 > @as(f64, @floatCast(@as(f32, @floatCast(used_position - @as(f64, @floatFromInt(minpos)))) / @as(f32, @floatFromInt(maxpos - minpos))))) 0.0 else @as(f64, @floatCast(@as(f32, @floatCast(used_position - @as(f64, @floatFromInt(minpos)))) / @as(f32, @floatFromInt(maxpos - minpos)))))) 1.0 else if (0.0 > @as(f64, @floatCast(@as(f32, @floatCast(used_position - @as(f64, @floatFromInt(minpos)))) / @as(f32, @floatFromInt(maxpos - minpos))))) 0.0 else @as(f64, @floatCast(@as(f32, @floatCast(used_position - @as(f64, @floatFromInt(minpos)))) / @as(f32, @floatFromInt(maxpos - minpos))))));
        _ = &v_usedposition;
        _ = sprintf(@as([*c]u8, @ptrCast(@alignCast(&targetpositionStr))), "%s%s%s%f%s", "<{targetposition} |-> [", propname, "]>. :|: %", @as(f64, @floatCast(v_usedposition)), "%\x00");
        NAR_AddInputNarsese(@as([*c]u8, @ptrCast(@alignCast(&targetpositionStr))));
        if ((@as(c_int, @intFromBool(picked)) != 0) and !lastpicked) {
            NAR_AddInputNarsese(@as([*c]u8, @ptrCast(@volatileCast(@constCast("picked. :|:")))));
        } else if (!picked and (@as(c_int, @intFromBool(lastpicked)) != 0)) {
            if (position_1 == goalposition) {
                NAR_AddInputNarsese(@as([*c]u8, @ptrCast(@volatileCast(@constCast("delivered. :|:")))));
                targetposition = @as(c_int, @intFromFloat((@as(f64, @floatFromInt(myrand())) / @as(f64, @floatFromInt(@as(c_int, 32767)))) * @as(f64, @floatFromInt(maxpos))));
                goalposition = @as(c_int, @intFromFloat((@as(f64, @floatFromInt(myrand())) / @as(f64, @floatFromInt(@as(c_int, 32767)))) * @as(f64, @floatFromInt(maxpos))));
                successes_2 += 1;
                if (iterations == @as(c_long, @bitCast(@as(c_long, -@as(c_int, 1))))) {
                    {
                        var k: c_int = 0;
                        _ = &k;
                        while (k < @as(c_int, 10)) : (k += 1) {}
                    }
                }
            }
        }
        lastpicked = picked;
        NAR_AddInputNarsese(@as([*c]u8, @ptrCast(@volatileCast(@constCast("delivered! :|:")))));
        var t_includeSleep: c_int = 100;
        _ = &t_includeSleep;
        var user_viz_sleep: bool = iterations == @as(c_long, @bitCast(@as(c_long, -@as(c_int, 1))));
        _ = &user_viz_sleep;
        _ = printf("ratio=%d sleepInVisualization=%s time=%ld\n", successes_2, if (@as(c_int, @intFromBool(user_viz_sleep)) != 0) "true" else "false", t);
        _ = fflush(__acrt_iob_func(@as(c_uint, @bitCast(@as(c_int, 1)))));
        if (currentTime > @as(c_long, @bitCast(@as(c_long, @as(c_int, 10500))))) {}
    }
}
pub export fn Run_System_Tests() void {
    NAR_Alphabet_Test();
    NAR_Procedure_Test();
    NAR_Follow_Test();
    NAR_Multistep_Test();
    NAR_Multistep2_Test();
    NAR_Sequence_Test();
}
pub export fn Process_Args(arg_argc: c_int, arg_argv: [*c][*c]u8) void {
    var argc = arg_argc;
    _ = &argc;
    var argv = arg_argv;
    _ = &argv;
    var inspectionOnExit: bool = @as(c_int, 0) != 0;
    _ = &inspectionOnExit;
    var iterations: c_long = @as(c_long, @bitCast(@as(c_long, -@as(c_int, 1))));
    _ = &iterations;
    if (argc >= @as(c_int, 4)) {
        if (!(strcmp(argv[@as(c_uint, @intCast(@as(c_int, 3)))], "InspectionOnExit") != 0)) {
            inspectionOnExit = @as(c_int, 1) != 0;
        }
    }
    if (argc >= @as(c_int, 3)) {
        if (!(strcmp(argv[@as(c_uint, @intCast(@as(c_int, 2)))], "InspectionOnExit") != 0)) {
            inspectionOnExit = @as(c_int, 1) != 0;
        }
    }
    if (argc >= @as(c_int, 2)) {
        NAR_INIT();
        if (!(strcmp(argv[@as(c_uint, @intCast(@as(c_int, 1)))], "NAL_GenerateRuleTable") != 0)) {
            NAL_GenerateRuleTable();
            exit(@as(c_int, 0));
        }
        if (!(strcmp(argv[@as(c_uint, @intCast(@as(c_int, 1)))], "shell") != 0)) {
            Shell_Start();
        }
        {
            var i: c_int = 1;
            _ = &i;
            while (i < argc) : (i += 1) {
                iterations = if ((i + @as(c_int, 1)) < argc) atol((blk: {
                    const tmp = i + @as(c_int, 1);
                    if (tmp >= 0) break :blk argv + @as(usize, @intCast(tmp)) else break :blk argv - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*) else @as(c_long, @bitCast(@as(c_long, -@as(c_int, 1))));
                if (!(strcmp((blk: {
                    const tmp = i;
                    if (tmp >= 0) break :blk argv + @as(usize, @intCast(tmp)) else break :blk argv - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*, "pong") != 0)) {
                    NAR_Pong(iterations);
                } else if (!(strcmp((blk: {
                    const tmp = i;
                    if (tmp >= 0) break :blk argv + @as(usize, @intCast(tmp)) else break :blk argv - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*, "pong2") != 0)) {
                    NAR_Pong2(iterations);
                } else if (!(strcmp((blk: {
                    const tmp = i;
                    if (tmp >= 0) break :blk argv + @as(usize, @intCast(tmp)) else break :blk argv - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*, "testchamber") != 0)) {
                    NAR_TestChamber();
                } else if (!(strcmp((blk: {
                    const tmp = i;
                    if (tmp >= 0) break :blk argv + @as(usize, @intCast(tmp)) else break :blk argv - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*, "alien") != 0)) {
                    NAR_Alien(iterations);
                } else if (!(strcmp((blk: {
                    const tmp = i;
                    if (tmp >= 0) break :blk argv + @as(usize, @intCast(tmp)) else break :blk argv - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*, "cartpole") != 0)) {
                    NAR_Cartpole(iterations);
                } else if (!(strcmp((blk: {
                    const tmp = i;
                    if (tmp >= 0) break :blk argv + @as(usize, @intCast(tmp)) else break :blk argv - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*, "robot") != 0)) {
                    NAR_Robot(iterations);
                } else if (!(strcmp((blk: {
                    const tmp = i;
                    if (tmp >= 0) break :blk argv + @as(usize, @intCast(tmp)) else break :blk argv - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*, "bandrobot") != 0)) {
                    NAR_Bandrobot(iterations);
                }
            }
        }
    }
    if (inspectionOnExit) {
        _ = Shell_ProcessInput(@as([*c]u8, @ptrCast(@volatileCast(@constCast("*opconfig")))));
        _ = Shell_ProcessInput(@as([*c]u8, @ptrCast(@volatileCast(@constCast("*concepts")))));
        _ = Shell_ProcessInput(@as([*c]u8, @ptrCast(@volatileCast(@constCast("*cycling_belief_events")))));
        _ = Shell_ProcessInput(@as([*c]u8, @ptrCast(@volatileCast(@constCast("*cycling_goal_events")))));
        _ = Shell_ProcessInput(@as([*c]u8, @ptrCast(@volatileCast(@constCast("*stats")))));
    }
}
pub export fn Display_Help() void {
    _ = puts("\nAll C tests ran successfully, run python3 evaluation.py for more comprehensive evaluation!");
    _ = puts("");
    _ = puts("Welcome to `OpenNARS for Applications`!");
    _ = puts("```````````````````````````````````````");
    _ = puts(" __        ");
    _ = puts("/ \\`-+-.__ ");
    _ = puts("```  |  /o\\");
    _ = puts("     |  ```");
    _ = puts("  __/ \\__  ");
    _ = puts("  ```````  ");
    _ = puts("If you wish to run examples now, just pass the corresponding parameter:");
    _ = puts("NAR pong (starts Pong example)");
    _ = puts("NAR pong2 (starts Pong2 example)");
    _ = puts("NAR testchamber (starts Test Chamber multistep procedure learning example)");
    _ = puts("NAR alien (starts the alien example)");
    _ = puts("NAR cartpole (starts the cartpole example)");
    _ = puts("NAR bandrobot (starts the band robot example)");
    _ = puts("NAR robot (starts the grid robot example)");
    _ = puts("NAR shell (starts the interactive NAL shell)");
}
pub const __llvm__ = @as(c_int, 1);
pub const __clang__ = @as(c_int, 1);
pub const __clang_major__ = @as(c_int, 18);
pub const __clang_minor__ = @as(c_int, 1);
pub const __clang_patchlevel__ = @as(c_int, 6);
pub const __clang_version__ = "18.1.6 (https://github.com/ziglang/zig-bootstrap 2bc5272f25942648e3c11df1c76e8b0972a1877c)";
pub const __GNUC__ = @as(c_int, 4);
pub const __GNUC_MINOR__ = @as(c_int, 2);
pub const __GNUC_PATCHLEVEL__ = @as(c_int, 1);
pub const __GXX_ABI_VERSION = @as(c_int, 1002);
pub const __ATOMIC_RELAXED = @as(c_int, 0);
pub const __ATOMIC_CONSUME = @as(c_int, 1);
pub const __ATOMIC_ACQUIRE = @as(c_int, 2);
pub const __ATOMIC_RELEASE = @as(c_int, 3);
pub const __ATOMIC_ACQ_REL = @as(c_int, 4);
pub const __ATOMIC_SEQ_CST = @as(c_int, 5);
pub const __MEMORY_SCOPE_SYSTEM = @as(c_int, 0);
pub const __MEMORY_SCOPE_DEVICE = @as(c_int, 1);
pub const __MEMORY_SCOPE_WRKGRP = @as(c_int, 2);
pub const __MEMORY_SCOPE_WVFRNT = @as(c_int, 3);
pub const __MEMORY_SCOPE_SINGLE = @as(c_int, 4);
pub const __OPENCL_MEMORY_SCOPE_WORK_ITEM = @as(c_int, 0);
pub const __OPENCL_MEMORY_SCOPE_WORK_GROUP = @as(c_int, 1);
pub const __OPENCL_MEMORY_SCOPE_DEVICE = @as(c_int, 2);
pub const __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES = @as(c_int, 3);
pub const __OPENCL_MEMORY_SCOPE_SUB_GROUP = @as(c_int, 4);
pub const __FPCLASS_SNAN = @as(c_int, 0x0001);
pub const __FPCLASS_QNAN = @as(c_int, 0x0002);
pub const __FPCLASS_NEGINF = @as(c_int, 0x0004);
pub const __FPCLASS_NEGNORMAL = @as(c_int, 0x0008);
pub const __FPCLASS_NEGSUBNORMAL = @as(c_int, 0x0010);
pub const __FPCLASS_NEGZERO = @as(c_int, 0x0020);
pub const __FPCLASS_POSZERO = @as(c_int, 0x0040);
pub const __FPCLASS_POSSUBNORMAL = @as(c_int, 0x0080);
pub const __FPCLASS_POSNORMAL = @as(c_int, 0x0100);
pub const __FPCLASS_POSINF = @as(c_int, 0x0200);
pub const __PRAGMA_REDEFINE_EXTNAME = @as(c_int, 1);
pub const __VERSION__ = "Clang 18.1.6 (https://github.com/ziglang/zig-bootstrap 2bc5272f25942648e3c11df1c76e8b0972a1877c)";
pub const __OBJC_BOOL_IS_BOOL = @as(c_int, 0);
pub const __CONSTANT_CFSTRINGS__ = @as(c_int, 1);
pub const __SEH__ = @as(c_int, 1);
pub const __clang_literal_encoding__ = "UTF-8";
pub const __clang_wide_literal_encoding__ = "UTF-16";
pub const __ORDER_LITTLE_ENDIAN__ = @as(c_int, 1234);
pub const __ORDER_BIG_ENDIAN__ = @as(c_int, 4321);
pub const __ORDER_PDP_ENDIAN__ = @as(c_int, 3412);
pub const __BYTE_ORDER__ = __ORDER_LITTLE_ENDIAN__;
pub const __LITTLE_ENDIAN__ = @as(c_int, 1);
pub const __CHAR_BIT__ = @as(c_int, 8);
pub const __BOOL_WIDTH__ = @as(c_int, 8);
pub const __SHRT_WIDTH__ = @as(c_int, 16);
pub const __INT_WIDTH__ = @as(c_int, 32);
pub const __LONG_WIDTH__ = @as(c_int, 32);
pub const __LLONG_WIDTH__ = @as(c_int, 64);
pub const __BITINT_MAXWIDTH__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 8388608, .decimal);
pub const __SCHAR_MAX__ = @as(c_int, 127);
pub const __SHRT_MAX__ = @as(c_int, 32767);
pub const __INT_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __LONG_MAX__ = @as(c_long, 2147483647);
pub const __LONG_LONG_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __WCHAR_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __WCHAR_WIDTH__ = @as(c_int, 16);
pub const __WINT_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __WINT_WIDTH__ = @as(c_int, 16);
pub const __INTMAX_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __INTMAX_WIDTH__ = @as(c_int, 64);
pub const __SIZE_MAX__ = @as(c_ulonglong, 18446744073709551615);
pub const __SIZE_WIDTH__ = @as(c_int, 64);
pub const __UINTMAX_MAX__ = @as(c_ulonglong, 18446744073709551615);
pub const __UINTMAX_WIDTH__ = @as(c_int, 64);
pub const __PTRDIFF_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __PTRDIFF_WIDTH__ = @as(c_int, 64);
pub const __INTPTR_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __INTPTR_WIDTH__ = @as(c_int, 64);
pub const __UINTPTR_MAX__ = @as(c_ulonglong, 18446744073709551615);
pub const __UINTPTR_WIDTH__ = @as(c_int, 64);
pub const __SIZEOF_DOUBLE__ = @as(c_int, 8);
pub const __SIZEOF_FLOAT__ = @as(c_int, 4);
pub const __SIZEOF_INT__ = @as(c_int, 4);
pub const __SIZEOF_LONG__ = @as(c_int, 4);
pub const __SIZEOF_LONG_DOUBLE__ = @as(c_int, 16);
pub const __SIZEOF_LONG_LONG__ = @as(c_int, 8);
pub const __SIZEOF_POINTER__ = @as(c_int, 8);
pub const __SIZEOF_SHORT__ = @as(c_int, 2);
pub const __SIZEOF_PTRDIFF_T__ = @as(c_int, 8);
pub const __SIZEOF_SIZE_T__ = @as(c_int, 8);
pub const __SIZEOF_WCHAR_T__ = @as(c_int, 2);
pub const __SIZEOF_WINT_T__ = @as(c_int, 2);
pub const __SIZEOF_INT128__ = @as(c_int, 16);
pub const __INTMAX_TYPE__ = c_longlong;
pub const __INTMAX_FMTd__ = "lld";
pub const __INTMAX_FMTi__ = "lli";
pub const __INTMAX_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `LL`");
// (no file):94:9
pub const __UINTMAX_TYPE__ = c_ulonglong;
pub const __UINTMAX_FMTo__ = "llo";
pub const __UINTMAX_FMTu__ = "llu";
pub const __UINTMAX_FMTx__ = "llx";
pub const __UINTMAX_FMTX__ = "llX";
pub const __UINTMAX_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `ULL`");
// (no file):100:9
pub const __PTRDIFF_TYPE__ = c_longlong;
pub const __PTRDIFF_FMTd__ = "lld";
pub const __PTRDIFF_FMTi__ = "lli";
pub const __INTPTR_TYPE__ = c_longlong;
pub const __INTPTR_FMTd__ = "lld";
pub const __INTPTR_FMTi__ = "lli";
pub const __SIZE_TYPE__ = c_ulonglong;
pub const __SIZE_FMTo__ = "llo";
pub const __SIZE_FMTu__ = "llu";
pub const __SIZE_FMTx__ = "llx";
pub const __SIZE_FMTX__ = "llX";
pub const __WCHAR_TYPE__ = c_ushort;
pub const __WINT_TYPE__ = c_ushort;
pub const __SIG_ATOMIC_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __SIG_ATOMIC_WIDTH__ = @as(c_int, 32);
pub const __CHAR16_TYPE__ = c_ushort;
pub const __CHAR32_TYPE__ = c_uint;
pub const __UINTPTR_TYPE__ = c_ulonglong;
pub const __UINTPTR_FMTo__ = "llo";
pub const __UINTPTR_FMTu__ = "llu";
pub const __UINTPTR_FMTx__ = "llx";
pub const __UINTPTR_FMTX__ = "llX";
pub const __FLT16_DENORM_MIN__ = @as(f16, 5.9604644775390625e-8);
pub const __FLT16_HAS_DENORM__ = @as(c_int, 1);
pub const __FLT16_DIG__ = @as(c_int, 3);
pub const __FLT16_DECIMAL_DIG__ = @as(c_int, 5);
pub const __FLT16_EPSILON__ = @as(f16, 9.765625e-4);
pub const __FLT16_HAS_INFINITY__ = @as(c_int, 1);
pub const __FLT16_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __FLT16_MANT_DIG__ = @as(c_int, 11);
pub const __FLT16_MAX_10_EXP__ = @as(c_int, 4);
pub const __FLT16_MAX_EXP__ = @as(c_int, 16);
pub const __FLT16_MAX__ = @as(f16, 6.5504e+4);
pub const __FLT16_MIN_10_EXP__ = -@as(c_int, 4);
pub const __FLT16_MIN_EXP__ = -@as(c_int, 13);
pub const __FLT16_MIN__ = @as(f16, 6.103515625e-5);
pub const __FLT_DENORM_MIN__ = @as(f32, 1.40129846e-45);
pub const __FLT_HAS_DENORM__ = @as(c_int, 1);
pub const __FLT_DIG__ = @as(c_int, 6);
pub const __FLT_DECIMAL_DIG__ = @as(c_int, 9);
pub const __FLT_EPSILON__ = @as(f32, 1.19209290e-7);
pub const __FLT_HAS_INFINITY__ = @as(c_int, 1);
pub const __FLT_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __FLT_MANT_DIG__ = @as(c_int, 24);
pub const __FLT_MAX_10_EXP__ = @as(c_int, 38);
pub const __FLT_MAX_EXP__ = @as(c_int, 128);
pub const __FLT_MAX__ = @as(f32, 3.40282347e+38);
pub const __FLT_MIN_10_EXP__ = -@as(c_int, 37);
pub const __FLT_MIN_EXP__ = -@as(c_int, 125);
pub const __FLT_MIN__ = @as(f32, 1.17549435e-38);
pub const __DBL_DENORM_MIN__ = @as(f64, 4.9406564584124654e-324);
pub const __DBL_HAS_DENORM__ = @as(c_int, 1);
pub const __DBL_DIG__ = @as(c_int, 15);
pub const __DBL_DECIMAL_DIG__ = @as(c_int, 17);
pub const __DBL_EPSILON__ = @as(f64, 2.2204460492503131e-16);
pub const __DBL_HAS_INFINITY__ = @as(c_int, 1);
pub const __DBL_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __DBL_MANT_DIG__ = @as(c_int, 53);
pub const __DBL_MAX_10_EXP__ = @as(c_int, 308);
pub const __DBL_MAX_EXP__ = @as(c_int, 1024);
pub const __DBL_MAX__ = @as(f64, 1.7976931348623157e+308);
pub const __DBL_MIN_10_EXP__ = -@as(c_int, 307);
pub const __DBL_MIN_EXP__ = -@as(c_int, 1021);
pub const __DBL_MIN__ = @as(f64, 2.2250738585072014e-308);
pub const __LDBL_DENORM_MIN__ = @as(c_longdouble, 3.64519953188247460253e-4951);
pub const __LDBL_HAS_DENORM__ = @as(c_int, 1);
pub const __LDBL_DIG__ = @as(c_int, 18);
pub const __LDBL_DECIMAL_DIG__ = @as(c_int, 21);
pub const __LDBL_EPSILON__ = @as(c_longdouble, 1.08420217248550443401e-19);
pub const __LDBL_HAS_INFINITY__ = @as(c_int, 1);
pub const __LDBL_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __LDBL_MANT_DIG__ = @as(c_int, 64);
pub const __LDBL_MAX_10_EXP__ = @as(c_int, 4932);
pub const __LDBL_MAX_EXP__ = @as(c_int, 16384);
pub const __LDBL_MAX__ = @as(c_longdouble, 1.18973149535723176502e+4932);
pub const __LDBL_MIN_10_EXP__ = -@as(c_int, 4931);
pub const __LDBL_MIN_EXP__ = -@as(c_int, 16381);
pub const __LDBL_MIN__ = @as(c_longdouble, 3.36210314311209350626e-4932);
pub const __POINTER_WIDTH__ = @as(c_int, 64);
pub const __BIGGEST_ALIGNMENT__ = @as(c_int, 16);
pub const __WCHAR_UNSIGNED__ = @as(c_int, 1);
pub const __WINT_UNSIGNED__ = @as(c_int, 1);
pub const __INT8_TYPE__ = i8;
pub const __INT8_FMTd__ = "hhd";
pub const __INT8_FMTi__ = "hhi";
pub const __INT8_C_SUFFIX__ = "";
pub const __INT16_TYPE__ = c_short;
pub const __INT16_FMTd__ = "hd";
pub const __INT16_FMTi__ = "hi";
pub const __INT16_C_SUFFIX__ = "";
pub const __INT32_TYPE__ = c_int;
pub const __INT32_FMTd__ = "d";
pub const __INT32_FMTi__ = "i";
pub const __INT32_C_SUFFIX__ = "";
pub const __INT64_TYPE__ = c_longlong;
pub const __INT64_FMTd__ = "lld";
pub const __INT64_FMTi__ = "lli";
pub const __INT64_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `LL`");
// (no file):198:9
pub const __UINT8_TYPE__ = u8;
pub const __UINT8_FMTo__ = "hho";
pub const __UINT8_FMTu__ = "hhu";
pub const __UINT8_FMTx__ = "hhx";
pub const __UINT8_FMTX__ = "hhX";
pub const __UINT8_C_SUFFIX__ = "";
pub const __UINT8_MAX__ = @as(c_int, 255);
pub const __INT8_MAX__ = @as(c_int, 127);
pub const __UINT16_TYPE__ = c_ushort;
pub const __UINT16_FMTo__ = "ho";
pub const __UINT16_FMTu__ = "hu";
pub const __UINT16_FMTx__ = "hx";
pub const __UINT16_FMTX__ = "hX";
pub const __UINT16_C_SUFFIX__ = "";
pub const __UINT16_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __INT16_MAX__ = @as(c_int, 32767);
pub const __UINT32_TYPE__ = c_uint;
pub const __UINT32_FMTo__ = "o";
pub const __UINT32_FMTu__ = "u";
pub const __UINT32_FMTx__ = "x";
pub const __UINT32_FMTX__ = "X";
pub const __UINT32_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `U`");
// (no file):220:9
pub const __UINT32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __INT32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __UINT64_TYPE__ = c_ulonglong;
pub const __UINT64_FMTo__ = "llo";
pub const __UINT64_FMTu__ = "llu";
pub const __UINT64_FMTx__ = "llx";
pub const __UINT64_FMTX__ = "llX";
pub const __UINT64_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `ULL`");
// (no file):228:9
pub const __UINT64_MAX__ = @as(c_ulonglong, 18446744073709551615);
pub const __INT64_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __INT_LEAST8_TYPE__ = i8;
pub const __INT_LEAST8_MAX__ = @as(c_int, 127);
pub const __INT_LEAST8_WIDTH__ = @as(c_int, 8);
pub const __INT_LEAST8_FMTd__ = "hhd";
pub const __INT_LEAST8_FMTi__ = "hhi";
pub const __UINT_LEAST8_TYPE__ = u8;
pub const __UINT_LEAST8_MAX__ = @as(c_int, 255);
pub const __UINT_LEAST8_FMTo__ = "hho";
pub const __UINT_LEAST8_FMTu__ = "hhu";
pub const __UINT_LEAST8_FMTx__ = "hhx";
pub const __UINT_LEAST8_FMTX__ = "hhX";
pub const __INT_LEAST16_TYPE__ = c_short;
pub const __INT_LEAST16_MAX__ = @as(c_int, 32767);
pub const __INT_LEAST16_WIDTH__ = @as(c_int, 16);
pub const __INT_LEAST16_FMTd__ = "hd";
pub const __INT_LEAST16_FMTi__ = "hi";
pub const __UINT_LEAST16_TYPE__ = c_ushort;
pub const __UINT_LEAST16_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __UINT_LEAST16_FMTo__ = "ho";
pub const __UINT_LEAST16_FMTu__ = "hu";
pub const __UINT_LEAST16_FMTx__ = "hx";
pub const __UINT_LEAST16_FMTX__ = "hX";
pub const __INT_LEAST32_TYPE__ = c_int;
pub const __INT_LEAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __INT_LEAST32_WIDTH__ = @as(c_int, 32);
pub const __INT_LEAST32_FMTd__ = "d";
pub const __INT_LEAST32_FMTi__ = "i";
pub const __UINT_LEAST32_TYPE__ = c_uint;
pub const __UINT_LEAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __UINT_LEAST32_FMTo__ = "o";
pub const __UINT_LEAST32_FMTu__ = "u";
pub const __UINT_LEAST32_FMTx__ = "x";
pub const __UINT_LEAST32_FMTX__ = "X";
pub const __INT_LEAST64_TYPE__ = c_longlong;
pub const __INT_LEAST64_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __INT_LEAST64_WIDTH__ = @as(c_int, 64);
pub const __INT_LEAST64_FMTd__ = "lld";
pub const __INT_LEAST64_FMTi__ = "lli";
pub const __UINT_LEAST64_TYPE__ = c_ulonglong;
pub const __UINT_LEAST64_MAX__ = @as(c_ulonglong, 18446744073709551615);
pub const __UINT_LEAST64_FMTo__ = "llo";
pub const __UINT_LEAST64_FMTu__ = "llu";
pub const __UINT_LEAST64_FMTx__ = "llx";
pub const __UINT_LEAST64_FMTX__ = "llX";
pub const __INT_FAST8_TYPE__ = i8;
pub const __INT_FAST8_MAX__ = @as(c_int, 127);
pub const __INT_FAST8_WIDTH__ = @as(c_int, 8);
pub const __INT_FAST8_FMTd__ = "hhd";
pub const __INT_FAST8_FMTi__ = "hhi";
pub const __UINT_FAST8_TYPE__ = u8;
pub const __UINT_FAST8_MAX__ = @as(c_int, 255);
pub const __UINT_FAST8_FMTo__ = "hho";
pub const __UINT_FAST8_FMTu__ = "hhu";
pub const __UINT_FAST8_FMTx__ = "hhx";
pub const __UINT_FAST8_FMTX__ = "hhX";
pub const __INT_FAST16_TYPE__ = c_short;
pub const __INT_FAST16_MAX__ = @as(c_int, 32767);
pub const __INT_FAST16_WIDTH__ = @as(c_int, 16);
pub const __INT_FAST16_FMTd__ = "hd";
pub const __INT_FAST16_FMTi__ = "hi";
pub const __UINT_FAST16_TYPE__ = c_ushort;
pub const __UINT_FAST16_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __UINT_FAST16_FMTo__ = "ho";
pub const __UINT_FAST16_FMTu__ = "hu";
pub const __UINT_FAST16_FMTx__ = "hx";
pub const __UINT_FAST16_FMTX__ = "hX";
pub const __INT_FAST32_TYPE__ = c_int;
pub const __INT_FAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __INT_FAST32_WIDTH__ = @as(c_int, 32);
pub const __INT_FAST32_FMTd__ = "d";
pub const __INT_FAST32_FMTi__ = "i";
pub const __UINT_FAST32_TYPE__ = c_uint;
pub const __UINT_FAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __UINT_FAST32_FMTo__ = "o";
pub const __UINT_FAST32_FMTu__ = "u";
pub const __UINT_FAST32_FMTx__ = "x";
pub const __UINT_FAST32_FMTX__ = "X";
pub const __INT_FAST64_TYPE__ = c_longlong;
pub const __INT_FAST64_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __INT_FAST64_WIDTH__ = @as(c_int, 64);
pub const __INT_FAST64_FMTd__ = "lld";
pub const __INT_FAST64_FMTi__ = "lli";
pub const __UINT_FAST64_TYPE__ = c_ulonglong;
pub const __UINT_FAST64_MAX__ = @as(c_ulonglong, 18446744073709551615);
pub const __UINT_FAST64_FMTo__ = "llo";
pub const __UINT_FAST64_FMTu__ = "llu";
pub const __UINT_FAST64_FMTx__ = "llx";
pub const __UINT_FAST64_FMTX__ = "llX";
pub const __USER_LABEL_PREFIX__ = "";
pub const __FINITE_MATH_ONLY__ = @as(c_int, 0);
pub const __GNUC_STDC_INLINE__ = @as(c_int, 1);
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL = @as(c_int, 1);
pub const __CLANG_ATOMIC_BOOL_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_CHAR_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_CHAR16_T_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_CHAR32_T_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_WCHAR_T_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_SHORT_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_INT_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_LONG_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_LLONG_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_POINTER_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_BOOL_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_CHAR_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_SHORT_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_INT_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_LONG_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_LLONG_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_POINTER_LOCK_FREE = @as(c_int, 2);
pub const __NO_INLINE__ = @as(c_int, 1);
pub const __PIC__ = @as(c_int, 2);
pub const __pic__ = @as(c_int, 2);
pub const __FLT_RADIX__ = @as(c_int, 2);
pub const __DECIMAL_DIG__ = __LDBL_DECIMAL_DIG__;
pub const __SSP_STRONG__ = @as(c_int, 2);
pub const __GCC_ASM_FLAG_OUTPUTS__ = @as(c_int, 1);
pub const __code_model_small__ = @as(c_int, 1);
pub const __amd64__ = @as(c_int, 1);
pub const __amd64 = @as(c_int, 1);
pub const __x86_64 = @as(c_int, 1);
pub const __x86_64__ = @as(c_int, 1);
pub const __SEG_GS = @as(c_int, 1);
pub const __SEG_FS = @as(c_int, 1);
pub const __seg_gs = @compileError("unable to translate macro: undefined identifier `address_space`");
// (no file):357:9
pub const __seg_fs = @compileError("unable to translate macro: undefined identifier `address_space`");
// (no file):358:9
pub const __znver3 = @as(c_int, 1);
pub const __znver3__ = @as(c_int, 1);
pub const __tune_znver3__ = @as(c_int, 1);
pub const __REGISTER_PREFIX__ = "";
pub const __NO_MATH_INLINES = @as(c_int, 1);
pub const __AES__ = @as(c_int, 1);
pub const __VAES__ = @as(c_int, 1);
pub const __PCLMUL__ = @as(c_int, 1);
pub const __VPCLMULQDQ__ = @as(c_int, 1);
pub const __LAHF_SAHF__ = @as(c_int, 1);
pub const __LZCNT__ = @as(c_int, 1);
pub const __RDRND__ = @as(c_int, 1);
pub const __FSGSBASE__ = @as(c_int, 1);
pub const __BMI__ = @as(c_int, 1);
pub const __BMI2__ = @as(c_int, 1);
pub const __POPCNT__ = @as(c_int, 1);
pub const __PRFCHW__ = @as(c_int, 1);
pub const __RDSEED__ = @as(c_int, 1);
pub const __ADX__ = @as(c_int, 1);
pub const __MWAITX__ = @as(c_int, 1);
pub const __MOVBE__ = @as(c_int, 1);
pub const __SSE4A__ = @as(c_int, 1);
pub const __FMA__ = @as(c_int, 1);
pub const __F16C__ = @as(c_int, 1);
pub const __SHA__ = @as(c_int, 1);
pub const __FXSR__ = @as(c_int, 1);
pub const __XSAVE__ = @as(c_int, 1);
pub const __XSAVEOPT__ = @as(c_int, 1);
pub const __XSAVEC__ = @as(c_int, 1);
pub const __XSAVES__ = @as(c_int, 1);
pub const __CLFLUSHOPT__ = @as(c_int, 1);
pub const __CLWB__ = @as(c_int, 1);
pub const __WBNOINVD__ = @as(c_int, 1);
pub const __SHSTK__ = @as(c_int, 1);
pub const __CLZERO__ = @as(c_int, 1);
pub const __RDPID__ = @as(c_int, 1);
pub const __RDPRU__ = @as(c_int, 1);
pub const __INVPCID__ = @as(c_int, 1);
pub const __CRC32__ = @as(c_int, 1);
pub const __AVX2__ = @as(c_int, 1);
pub const __AVX__ = @as(c_int, 1);
pub const __SSE4_2__ = @as(c_int, 1);
pub const __SSE4_1__ = @as(c_int, 1);
pub const __SSSE3__ = @as(c_int, 1);
pub const __SSE3__ = @as(c_int, 1);
pub const __SSE2__ = @as(c_int, 1);
pub const __SSE2_MATH__ = @as(c_int, 1);
pub const __SSE__ = @as(c_int, 1);
pub const __SSE_MATH__ = @as(c_int, 1);
pub const __MMX__ = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_16 = @as(c_int, 1);
pub const __SIZEOF_FLOAT128__ = @as(c_int, 16);
pub const _WIN32 = @as(c_int, 1);
pub const _WIN64 = @as(c_int, 1);
pub const WIN32 = @as(c_int, 1);
pub const __WIN32 = @as(c_int, 1);
pub const __WIN32__ = @as(c_int, 1);
pub const WINNT = @as(c_int, 1);
pub const __WINNT = @as(c_int, 1);
pub const __WINNT__ = @as(c_int, 1);
pub const WIN64 = @as(c_int, 1);
pub const __WIN64 = @as(c_int, 1);
pub const __WIN64__ = @as(c_int, 1);
pub const __MINGW64__ = @as(c_int, 1);
pub const __MSVCRT__ = @as(c_int, 1);
pub const __MINGW32__ = @as(c_int, 1);
pub const __declspec = @compileError("unable to translate C expr: unexpected token '__attribute__'");
// (no file):429:9
pub const _cdecl = @compileError("unable to translate macro: undefined identifier `__cdecl__`");
// (no file):430:9
pub const __cdecl = @compileError("unable to translate macro: undefined identifier `__cdecl__`");
// (no file):431:9
pub const _stdcall = @compileError("unable to translate macro: undefined identifier `__stdcall__`");
// (no file):432:9
pub const __stdcall = @compileError("unable to translate macro: undefined identifier `__stdcall__`");
// (no file):433:9
pub const _fastcall = @compileError("unable to translate macro: undefined identifier `__fastcall__`");
// (no file):434:9
pub const __fastcall = @compileError("unable to translate macro: undefined identifier `__fastcall__`");
// (no file):435:9
pub const _thiscall = @compileError("unable to translate macro: undefined identifier `__thiscall__`");
// (no file):436:9
pub const __thiscall = @compileError("unable to translate macro: undefined identifier `__thiscall__`");
// (no file):437:9
pub const _pascal = @compileError("unable to translate macro: undefined identifier `__pascal__`");
// (no file):438:9
pub const __pascal = @compileError("unable to translate macro: undefined identifier `__pascal__`");
// (no file):439:9
pub const __STDC__ = @as(c_int, 1);
pub const __STDC_HOSTED__ = @as(c_int, 1);
pub const __STDC_VERSION__ = @as(c_long, 201710);
pub const __STDC_UTF_16__ = @as(c_int, 1);
pub const __STDC_UTF_32__ = @as(c_int, 1);
pub const __MSVCRT_VERSION__ = @as(c_int, 0xE00);
pub const _WIN32_WINNT = @as(c_int, 0x0a00);
pub const _DEBUG = @as(c_int, 1);
pub const _TIME_H_ = "";
pub const _INC_CRTDEFS = "";
pub const _INC_CORECRT = "";
pub const _INC__MINGW_H = "";
pub const _INC_CRTDEFS_MACRO = "";
pub const __STRINGIFY = @compileError("unable to translate C expr: unexpected token '#'");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw_mac.h:10:9
pub inline fn __MINGW64_STRINGIFY(x: anytype) @TypeOf(__STRINGIFY(x)) {
    _ = &x;
    return __STRINGIFY(x);
}
pub const __MINGW64_VERSION_MAJOR = @as(c_int, 12);
pub const __MINGW64_VERSION_MINOR = @as(c_int, 0);
pub const __MINGW64_VERSION_BUGFIX = @as(c_int, 0);
pub const __MINGW64_VERSION_RC = @as(c_int, 0);
pub const __MINGW64_VERSION_STR = __MINGW64_STRINGIFY(__MINGW64_VERSION_MAJOR) ++ "." ++ __MINGW64_STRINGIFY(__MINGW64_VERSION_MINOR) ++ "." ++ __MINGW64_STRINGIFY(__MINGW64_VERSION_BUGFIX);
pub const __MINGW64_VERSION_STATE = "alpha";
pub const __MINGW32_MAJOR_VERSION = @as(c_int, 3);
pub const __MINGW32_MINOR_VERSION = @as(c_int, 11);
pub const _M_AMD64 = @as(c_int, 100);
pub const _M_X64 = @as(c_int, 100);
pub const @"_" = @as(c_int, 1);
pub const __MINGW_USE_UNDERSCORE_PREFIX = @as(c_int, 0);
pub const __MINGW_IMP_SYMBOL = @compileError("unable to translate macro: undefined identifier `__imp_`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw_mac.h:119:11
pub const __MINGW_IMP_LSYMBOL = @compileError("unable to translate macro: undefined identifier `__imp_`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw_mac.h:120:11
pub inline fn __MINGW_USYMBOL(sym: anytype) @TypeOf(sym) {
    _ = &sym;
    return sym;
}
pub const __MINGW_LSYMBOL = @compileError("unable to translate C expr: unexpected token '##'");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw_mac.h:122:11
pub const __MINGW_ASM_CALL = @compileError("unable to translate C expr: unexpected token '__asm__'");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw_mac.h:130:9
pub const __MINGW_ASM_CRT_CALL = @compileError("unable to translate C expr: unexpected token '__asm__'");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw_mac.h:131:9
pub const __MINGW_EXTENSION = @compileError("unable to translate C expr: unexpected token '__extension__'");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw_mac.h:163:13
pub const __C89_NAMELESS = __MINGW_EXTENSION;
pub const __C89_NAMELESSSTRUCTNAME = "";
pub const __C89_NAMELESSSTRUCTNAME1 = "";
pub const __C89_NAMELESSSTRUCTNAME2 = "";
pub const __C89_NAMELESSSTRUCTNAME3 = "";
pub const __C89_NAMELESSSTRUCTNAME4 = "";
pub const __C89_NAMELESSSTRUCTNAME5 = "";
pub const __C89_NAMELESSUNIONNAME = "";
pub const __C89_NAMELESSUNIONNAME1 = "";
pub const __C89_NAMELESSUNIONNAME2 = "";
pub const __C89_NAMELESSUNIONNAME3 = "";
pub const __C89_NAMELESSUNIONNAME4 = "";
pub const __C89_NAMELESSUNIONNAME5 = "";
pub const __C89_NAMELESSUNIONNAME6 = "";
pub const __C89_NAMELESSUNIONNAME7 = "";
pub const __C89_NAMELESSUNIONNAME8 = "";
pub const __GNU_EXTENSION = __MINGW_EXTENSION;
pub const __MINGW_HAVE_ANSI_C99_PRINTF = @as(c_int, 1);
pub const __MINGW_HAVE_WIDE_C99_PRINTF = @as(c_int, 1);
pub const __MINGW_HAVE_ANSI_C99_SCANF = @as(c_int, 1);
pub const __MINGW_HAVE_WIDE_C99_SCANF = @as(c_int, 1);
pub const __MINGW_POISON_NAME = @compileError("unable to translate macro: undefined identifier `_layout_has_not_been_verified_and_its_declaration_is_most_likely_incorrect`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw_mac.h:203:11
pub const __MSABI_LONG = @import("std").zig.c_translation.Macros.L_SUFFIX;
pub const __MINGW_GCC_VERSION = ((__GNUC__ * @as(c_int, 10000)) + (__GNUC_MINOR__ * @as(c_int, 100))) + __GNUC_PATCHLEVEL__;
pub inline fn __MINGW_GNUC_PREREQ(major: anytype, minor: anytype) @TypeOf((__GNUC__ > major) or ((__GNUC__ == major) and (__GNUC_MINOR__ >= minor))) {
    _ = &major;
    _ = &minor;
    return (__GNUC__ > major) or ((__GNUC__ == major) and (__GNUC_MINOR__ >= minor));
}
pub inline fn __MINGW_MSC_PREREQ(major: anytype, minor: anytype) @TypeOf(@as(c_int, 0)) {
    _ = &major;
    _ = &minor;
    return @as(c_int, 0);
}
pub const __MINGW_ATTRIB_DEPRECATED_STR = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw_mac.h:247:11
pub const __MINGW_SEC_WARN_STR = "This function or variable may be unsafe, use _CRT_SECURE_NO_WARNINGS to disable deprecation";
pub const __MINGW_MSVC2005_DEPREC_STR = "This POSIX function is deprecated beginning in Visual C++ 2005, use _CRT_NONSTDC_NO_DEPRECATE to disable deprecation";
pub const __MINGW_ATTRIB_DEPRECATED_MSVC2005 = __MINGW_ATTRIB_DEPRECATED_STR(__MINGW_MSVC2005_DEPREC_STR);
pub const __MINGW_ATTRIB_DEPRECATED_SEC_WARN = __MINGW_ATTRIB_DEPRECATED_STR(__MINGW_SEC_WARN_STR);
pub const __MINGW_MS_PRINTF = @compileError("unable to translate macro: undefined identifier `__format__`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw_mac.h:270:9
pub const __MINGW_MS_SCANF = @compileError("unable to translate macro: undefined identifier `__format__`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw_mac.h:273:9
pub const __MINGW_GNU_PRINTF = @compileError("unable to translate macro: undefined identifier `__format__`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw_mac.h:276:9
pub const __MINGW_GNU_SCANF = @compileError("unable to translate macro: undefined identifier `__format__`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw_mac.h:279:9
pub const __mingw_ovr = @compileError("unable to translate macro: undefined identifier `__unused__`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw_mac.h:289:11
pub const __mingw_static_ovr = __mingw_ovr;
pub const __mingw_attribute_artificial = @compileError("unable to translate macro: undefined identifier `__artificial__`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw_mac.h:298:11
pub const __MINGW_SELECTANY = @compileError("unable to translate macro: undefined identifier `__selectany__`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw_mac.h:304:9
pub const __MINGW_FORTIFY_LEVEL = @as(c_int, 0);
pub const __mingw_bos_ovr = __mingw_ovr;
pub const __MINGW_FORTIFY_VA_ARG = @as(c_int, 0);
pub const _INC_MINGW_SECAPI = "";
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES = @as(c_int, 0);
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY = @as(c_int, 0);
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES = @as(c_int, 0);
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT = @as(c_int, 0);
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY = @as(c_int, 0);
pub const __MINGW_CRT_NAME_CONCAT2 = @compileError("unable to translate macro: undefined identifier `_s`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw_secapi.h:41:9
pub const __CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY_0_3_ = @compileError("unable to translate C expr: unexpected token ';'");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw_secapi.h:69:9
pub const __LONG32 = c_long;
pub const __MINGW_IMPORT = @compileError("unable to translate macro: undefined identifier `__dllimport__`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:44:12
pub const __USE_CRTIMP = @as(c_int, 1);
pub const _CRTIMP = @compileError("unable to translate macro: undefined identifier `__dllimport__`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:52:15
pub const __DECLSPEC_SUPPORTED = "";
pub const USE___UUIDOF = @as(c_int, 0);
pub const _inline = @compileError("unable to translate C expr: unexpected token '__inline'");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:74:9
pub const __CRT_INLINE = @compileError("unable to translate macro: undefined identifier `__gnu_inline__`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:83:11
pub const __MINGW_INTRIN_INLINE = @compileError("unable to translate macro: undefined identifier `__always_inline__`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:90:9
pub const __CRT__NO_INLINE = @as(c_int, 1);
pub const __UNUSED_PARAM = @compileError("unable to translate macro: undefined identifier `__unused__`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:104:11
pub const __restrict_arr = @compileError("unable to translate C expr: unexpected token '__restrict'");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:119:10
pub const __MINGW_ATTRIB_NORETURN = @compileError("unable to translate macro: undefined identifier `__noreturn__`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:135:9
pub const __MINGW_ATTRIB_CONST = @compileError("unable to translate C expr: unexpected token '__attribute__'");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:136:9
pub const __MINGW_ATTRIB_MALLOC = @compileError("unable to translate macro: undefined identifier `__malloc__`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:146:9
pub const __MINGW_ATTRIB_PURE = @compileError("unable to translate macro: undefined identifier `__pure__`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:147:9
pub const __MINGW_ATTRIB_NONNULL = @compileError("unable to translate macro: undefined identifier `__nonnull__`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:160:9
pub const __MINGW_ATTRIB_UNUSED = @compileError("unable to translate macro: undefined identifier `__unused__`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:166:9
pub const __MINGW_ATTRIB_USED = @compileError("unable to translate macro: undefined identifier `__used__`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:172:9
pub const __MINGW_ATTRIB_DEPRECATED = @compileError("unable to translate macro: undefined identifier `__deprecated__`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:173:9
pub const __MINGW_ATTRIB_DEPRECATED_MSG = @compileError("unable to translate macro: undefined identifier `__deprecated__`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:175:9
pub const __MINGW_NOTHROW = @compileError("unable to translate macro: undefined identifier `__nothrow__`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:190:9
pub const __MINGW_ATTRIB_NO_OPTIMIZE = "";
pub const __MINGW_PRAGMA_PARAM = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:208:9
pub const __MINGW_BROKEN_INTERFACE = @compileError("unable to translate macro: undefined identifier `message`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:211:9
pub const _UCRT = "";
pub const _INT128_DEFINED = "";
pub const __int8 = u8;
pub const __int16 = c_short;
pub const __int32 = c_int;
pub const __int64 = c_longlong;
pub const __ptr32 = "";
pub const __ptr64 = "";
pub const __unaligned = "";
pub const __w64 = "";
pub const __forceinline = @compileError("unable to translate macro: undefined identifier `__always_inline__`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:266:9
pub const __nothrow = "";
pub const _INC_VADEFS = "";
pub const MINGW_SDK_INIT = "";
pub const MINGW_HAS_SECURE_API = @as(c_int, 1);
pub const __STDC_SECURE_LIB__ = @as(c_long, 200411);
pub const __GOT_SECURE_LIB__ = __STDC_SECURE_LIB__;
pub const MINGW_DDK_H = "";
pub const MINGW_HAS_DDK_H = @as(c_int, 1);
pub const _CRT_PACKING = @as(c_int, 8);
pub const __GNUC_VA_LIST = "";
pub const _VA_LIST_DEFINED = "";
pub inline fn _ADDRESSOF(v: anytype) @TypeOf(&v) {
    _ = &v;
    return &v;
}
pub const _crt_va_start = @compileError("unable to translate macro: undefined identifier `__builtin_va_start`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/vadefs.h:48:9
pub const _crt_va_arg = @compileError("unable to translate C expr: unexpected token 'an identifier'");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/vadefs.h:49:9
pub const _crt_va_end = @compileError("unable to translate macro: undefined identifier `__builtin_va_end`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/vadefs.h:50:9
pub const _crt_va_copy = @compileError("unable to translate macro: undefined identifier `__builtin_va_copy`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/vadefs.h:51:9
pub const __CRT_STRINGIZE = @compileError("unable to translate C expr: unexpected token '#'");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:285:9
pub inline fn _CRT_STRINGIZE(_Value: anytype) @TypeOf(__CRT_STRINGIZE(_Value)) {
    _ = &_Value;
    return __CRT_STRINGIZE(_Value);
}
pub const __CRT_WIDE = @compileError("unable to translate macro: undefined identifier `L`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:290:9
pub inline fn _CRT_WIDE(_String: anytype) @TypeOf(__CRT_WIDE(_String)) {
    _ = &_String;
    return __CRT_WIDE(_String);
}
pub const _W64 = "";
pub const _CRTIMP_NOIA64 = _CRTIMP;
pub const _CRTIMP2 = _CRTIMP;
pub const _CRTIMP_ALTERNATIVE = _CRTIMP;
pub const _CRT_ALTERNATIVE_IMPORTED = "";
pub const _MRTIMP2 = _CRTIMP;
pub const _DLL = "";
pub const _MT = "";
pub const _MCRTIMP = _CRTIMP;
pub const _CRTIMP_PURE = _CRTIMP;
pub const _PGLOBAL = "";
pub const _AGLOBAL = "";
pub const _SECURECRT_FILL_BUFFER_PATTERN = @as(c_int, 0xFD);
pub const _CRT_DEPRECATE_TEXT = @compileError("unable to translate macro: undefined identifier `deprecated`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:349:9
pub const _CRT_INSECURE_DEPRECATE_MEMORY = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:352:9
pub const _CRT_INSECURE_DEPRECATE_GLOBALS = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:356:9
pub const _CRT_MANAGED_HEAP_DEPRECATE = "";
pub const _CRT_OBSOLETE = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:364:9
pub const _CONST_RETURN = "";
pub const UNALIGNED = "";
pub const _CRT_ALIGN = @compileError("unable to translate macro: undefined identifier `__aligned__`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:391:9
pub const __CRTDECL = __cdecl;
pub const _ARGMAX = @as(c_int, 100);
pub const _TRUNCATE = @import("std").zig.c_translation.cast(usize, -@as(c_int, 1));
pub inline fn _CRT_UNUSED(x: anytype) anyopaque {
    _ = &x;
    return @import("std").zig.c_translation.cast(anyopaque, x);
}
pub const __USE_MINGW_ANSI_STDIO = @as(c_int, 0);
pub const _CRT_glob = @compileError("unable to translate macro: undefined identifier `_dowildcard`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:455:9
pub const __ANONYMOUS_DEFINED = "";
pub const _ANONYMOUS_UNION = __MINGW_EXTENSION;
pub const _ANONYMOUS_STRUCT = __MINGW_EXTENSION;
pub const _UNION_NAME = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:475:9
pub const _STRUCT_NAME = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:476:9
pub const DUMMYUNIONNAME = "";
pub const DUMMYUNIONNAME1 = "";
pub const DUMMYUNIONNAME2 = "";
pub const DUMMYUNIONNAME3 = "";
pub const DUMMYUNIONNAME4 = "";
pub const DUMMYUNIONNAME5 = "";
pub const DUMMYUNIONNAME6 = "";
pub const DUMMYUNIONNAME7 = "";
pub const DUMMYUNIONNAME8 = "";
pub const DUMMYUNIONNAME9 = "";
pub const DUMMYSTRUCTNAME = "";
pub const DUMMYSTRUCTNAME1 = "";
pub const DUMMYSTRUCTNAME2 = "";
pub const DUMMYSTRUCTNAME3 = "";
pub const DUMMYSTRUCTNAME4 = "";
pub const DUMMYSTRUCTNAME5 = "";
pub const __CRT_UUID_DECL = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:563:9
pub const __MINGW_DEBUGBREAK_IMPL = !(__has_builtin(__debugbreak) != 0);
pub const __MINGW_FASTFAIL_IMPL = !(__has_builtin(__fastfail) != 0);
pub const __MINGW_PREFETCH_IMPL = @compileError("unable to translate macro: undefined identifier `__prefetch`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_mingw.h:620:9
pub const _CRTNOALIAS = "";
pub const _CRTRESTRICT = "";
pub const _SIZE_T_DEFINED = "";
pub const _SSIZE_T_DEFINED = "";
pub const _RSIZE_T_DEFINED = "";
pub const _INTPTR_T_DEFINED = "";
pub const __intptr_t_defined = "";
pub const _UINTPTR_T_DEFINED = "";
pub const __uintptr_t_defined = "";
pub const _PTRDIFF_T_DEFINED = "";
pub const _PTRDIFF_T_ = "";
pub const _WCHAR_T_DEFINED = "";
pub const _WCTYPE_T_DEFINED = "";
pub const _WINT_T = "";
pub const _ERRCODE_DEFINED = "";
pub const _TIME32_T_DEFINED = "";
pub const _TIME64_T_DEFINED = "";
pub const _TIME_T_DEFINED = "";
pub const _CRT_SECURE_CPP_NOTHROW = @compileError("unable to translate macro: undefined identifier `throw`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/corecrt.h:143:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0 = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/corecrt.h:262:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1 = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/corecrt.h:263:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2 = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/corecrt.h:264:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3 = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/corecrt.h:265:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4 = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/corecrt.h:266:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1 = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/corecrt.h:267:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_2 = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/corecrt.h:268:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_3 = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/corecrt.h:269:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_2_0 = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/corecrt.h:270:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/corecrt.h:271:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/corecrt.h:272:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_SPLITPATH = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/corecrt.h:273:9
pub const __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0 = @compileError("unable to translate macro: undefined identifier `__func_name`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/corecrt.h:277:9
pub const __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1 = @compileError("unable to translate macro: undefined identifier `__func_name`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/corecrt.h:279:9
pub const __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2 = @compileError("unable to translate macro: undefined identifier `__func_name`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/corecrt.h:281:9
pub const __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3 = @compileError("unable to translate macro: undefined identifier `__func_name`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/corecrt.h:283:9
pub const __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4 = @compileError("unable to translate macro: undefined identifier `__func_name`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/corecrt.h:285:9
pub const __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/corecrt.h:422:9
pub const __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/corecrt.h:423:9
pub const __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/corecrt.h:424:9
pub const __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/corecrt.h:425:9
pub const __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/corecrt.h:426:9
pub const _TAGLC_ID_DEFINED = "";
pub const _THREADLOCALEINFO = "";
pub const __crt_typefix = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/corecrt.h:486:9
pub const _CRT_USE_WINAPI_FAMILY_DESKTOP_APP = "";
pub const _SECIMP = @compileError("unable to translate macro: undefined identifier `dllimport`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/time.h:20:9
pub const _TIMEB_H_ = "";
pub const _TIMEB_DEFINED = "";
pub const _timeb = __timeb64;
pub const _ftime = _ftime64;
pub const _TIMESPEC_DEFINED = "";
pub const _TIMEB_H_S = "";
pub const _ftime_s = _ftime64_s;
pub const _CLOCK_T_DEFINED = "";
pub const NULL = @import("std").zig.c_translation.cast(?*anyopaque, @as(c_int, 0));
pub const _TM_DEFINED = "";
pub const CLOCKS_PER_SEC = @as(c_int, 1000);
pub const TIME_UTC = @as(c_int, 1);
pub const _daylight = __daylight().*;
pub const _dstbias = __dstbias().*;
pub const _timezone = __timezone().*;
pub const _tzname = __tzname();
pub const __MINGW_STRFTIME_FORMAT = strftime;
pub const _INC_WTIME_INL = "";
pub const _INC_WTIME_S_INL = "";
pub const _WTIME_DEFINED = "";
pub const CLK_TCK = CLOCKS_PER_SEC;
pub const __MINGW_ATTRIB_DEPRECATED_UCRT = __MINGW_ATTRIB_DEPRECATED_MSG("Only provided for source compatibility; this variable might " ++ "not always be accurate when linking to UCRT.");
pub const _TIMEVAL_DEFINED = "";
pub inline fn timerisset(tvp: anytype) @TypeOf((tvp.*.tv_sec != 0) or (tvp.*.tv_usec != 0)) {
    _ = &tvp;
    return (tvp.*.tv_sec != 0) or (tvp.*.tv_usec != 0);
}
pub inline fn timercmp(tvp: anytype, uvp: anytype, cmp: anytype) @TypeOf(((tvp.*.tv_sec ++ cmp(uvp).*.tv_sec) != 0) or ((tvp.*.tv_sec == uvp.*.tv_sec) and ((tvp.*.tv_usec ++ cmp(uvp).*.tv_usec) != 0))) {
    _ = &tvp;
    _ = &uvp;
    _ = &cmp;
    return ((tvp.*.tv_sec ++ cmp(uvp).*.tv_sec) != 0) or ((tvp.*.tv_sec == uvp.*.tv_sec) and ((tvp.*.tv_usec ++ cmp(uvp).*.tv_usec) != 0));
}
pub const timerclear = @compileError("unable to translate C expr: unexpected token '='");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/_timeval.h:20:9
pub const _TIMEZONE_DEFINED = "";
pub const _UNISTD_H = "";
pub const __UNISTD_H_SOURCED__ = @as(c_int, 1);
pub const _IO_H_ = "";
pub const _INC_STRING = "";
pub const _NLSCMP_DEFINED = "";
pub const _NLSCMPERROR = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const _WConst_return = "";
pub const _CRT_MEMORY_DEFINED = "";
pub const _WSTRING_DEFINED = "";
pub const wcswcs = wcsstr;
pub const _INC_STRING_S = "";
pub const _WSTRING_S_DEFINED = "";
pub const _FSIZE_T_DEFINED = "";
pub const _finddata_t = _finddata64i32_t;
pub const _finddatai64_t = __finddata64_t;
pub const _findfirst = _findfirst64i32;
pub const _findnext = _findnext64i32;
pub const _findfirsti64 = _findfirst64;
pub const _findnexti64 = _findnext64;
pub const _FINDDATA_T_DEFINED = "";
pub const _wfinddata_t = _wfinddata64i32_t;
pub const _wfinddatai64_t = _wfinddata64_t;
pub const _wfindfirst = _wfindfirst64i32;
pub const _wfindnext = _wfindnext64i32;
pub const _wfindfirsti64 = _wfindfirst64;
pub const _wfindnexti64 = _wfindnext64;
pub const _WFINDDATA_T_DEFINED = "";
pub const _A_NORMAL = @as(c_int, 0x00);
pub const _A_RDONLY = @as(c_int, 0x01);
pub const _A_HIDDEN = @as(c_int, 0x02);
pub const _A_SYSTEM = @as(c_int, 0x04);
pub const _A_SUBDIR = @as(c_int, 0x10);
pub const _A_ARCH = @as(c_int, 0x20);
pub const _OFF_T_DEFINED = "";
pub const _OFF_T_ = "";
pub const _OFF64_T_DEFINED = "";
pub const _FILE_OFFSET_BITS_SET_OFFT = "";
pub const F_OK = @as(c_int, 0);
pub const X_OK = @as(c_int, 1);
pub const W_OK = @as(c_int, 2);
pub const R_OK = @as(c_int, 4);
pub const _CRT_DIRECTORY_DEFINED = "";
pub const _WIO_DEFINED = "";
pub const _FILE_OFFSET_BITS_SET_LSEEK = "";
pub const _INC_PROCESS = "";
pub const _INC_CORECRT_STARTUP = "";
pub const _acmdln = __p__acmdln().*;
pub const _wcmdln = __p__wcmdln().*;
pub const _INC_TYPES = "";
pub const _INO_T_DEFINED = "";
pub const _DEV_T_DEFINED = "";
pub const _PID_T_ = "";
pub const _MODE_T_ = "";
pub const _SIGSET_T_ = "";
pub const _P_WAIT = @as(c_int, 0);
pub const _P_NOWAIT = @as(c_int, 1);
pub const _OLD_P_OVERLAY = @as(c_int, 2);
pub const _P_NOWAITO = @as(c_int, 3);
pub const _P_DETACH = @as(c_int, 4);
pub const _P_OVERLAY = @as(c_int, 2);
pub const _WAIT_CHILD = @as(c_int, 0);
pub const _WAIT_GRANDCHILD = @as(c_int, 1);
pub const _CRT_TERMINATE_DEFINED = "";
pub const _SPAWNV_DEFINED = "";
pub const _CRT_SYSTEM_DEFINED = "";
pub const _WEXEC_DEFINED = "";
pub const _WSPAWN_DEFINED = "";
pub const _CRT_WSYSTEM_DEFINED = "";
pub const P_WAIT = _P_WAIT;
pub const P_NOWAIT = _P_NOWAIT;
pub const P_OVERLAY = _P_OVERLAY;
pub const OLD_P_OVERLAY = _OLD_P_OVERLAY;
pub const P_NOWAITO = _P_NOWAITO;
pub const P_DETACH = _P_DETACH;
pub const WAIT_CHILD = _WAIT_CHILD;
pub const WAIT_GRANDCHILD = _WAIT_GRANDCHILD;
pub const _CRT_GETPID_DEFINED = "";
pub const __GETOPT_H__ = "";
pub const SEEK_SET = @as(c_int, 0);
pub const SEEK_CUR = @as(c_int, 1);
pub const SEEK_END = @as(c_int, 2);
pub const STDIN_FILENO = @as(c_int, 0);
pub const STDOUT_FILENO = @as(c_int, 1);
pub const STDERR_FILENO = @as(c_int, 2);
pub const FTRUNCATE_DEFINED = "";
pub const _FILE_OFFSET_BITS_SET_FTRUNCATE = "";
pub const _CRT_SWAB_DEFINED = "";
pub const __STDBOOL_H = "";
pub const __bool_true_false_are_defined = @as(c_int, 1);
pub const @"bool" = bool;
pub const @"true" = @as(c_int, 1);
pub const @"false" = @as(c_int, 0);
pub const _INC_STDIO = "";
pub const _STDIO_CONFIG_DEFINED = "";
pub const _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION = @as(c_ulonglong, 0x0001);
pub const _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR = @as(c_ulonglong, 0x0002);
pub const _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS = @as(c_ulonglong, 0x0004);
pub const _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY = @as(c_ulonglong, 0x0008);
pub const _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS = @as(c_ulonglong, 0x0010);
pub const _CRT_INTERNAL_SCANF_SECURECRT = @as(c_ulonglong, 0x0001);
pub const _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS = @as(c_ulonglong, 0x0002);
pub const _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY = @as(c_ulonglong, 0x0004);
pub const _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS = _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS;
pub const _CRT_INTERNAL_LOCAL_SCANF_OPTIONS = _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS;
pub const BUFSIZ = @as(c_int, 512);
pub const _NFILE = _NSTREAM_;
pub const _NSTREAM_ = @as(c_int, 512);
pub const _IOB_ENTRIES = @as(c_int, 20);
pub const EOF = -@as(c_int, 1);
pub const _FILE_DEFINED = "";
pub const _P_tmpdir = "\\";
pub const _wP_tmpdir = "\\";
pub const L_tmpnam = @as(c_int, 260);
pub const FILENAME_MAX = @as(c_int, 260);
pub const FOPEN_MAX = @as(c_int, 20);
pub const _SYS_OPEN = @as(c_int, 20);
pub const TMP_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const _iob = __iob_func();
pub const _FPOS_T_DEFINED = "";
pub inline fn _FPOSOFF(fp: anytype) c_long {
    _ = &fp;
    return @import("std").zig.c_translation.cast(c_long, fp);
}
pub const _STDSTREAM_DEFINED = "";
pub const stdin = __acrt_iob_func(@as(c_int, 0));
pub const stdout = __acrt_iob_func(@as(c_int, 1));
pub const stderr = __acrt_iob_func(@as(c_int, 2));
pub const _IOFBF = @as(c_int, 0x0000);
pub const _IOLBF = @as(c_int, 0x0040);
pub const _IONBF = @as(c_int, 0x0004);
pub const __MINGW_PRINTF_FORMAT = printf;
pub const __MINGW_SCANF_FORMAT = scanf;
pub const _FILE_OFFSET_BITS_SET_FSEEKO = "";
pub const _FILE_OFFSET_BITS_SET_FTELLO = "";
pub const _CRT_PERROR_DEFINED = "";
pub const popen = _popen;
pub const pclose = _pclose;
pub const _WSTDIO_DEFINED = "";
pub const WEOF = @import("std").zig.c_translation.cast(wint_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFFFF, .hex));
pub const _INC_SWPRINTF_INL = "";
pub const _CRT_WPERROR_DEFINED = "";
pub const wpopen = _wpopen;
pub inline fn _putwc_nolock(_c: anytype, _stm: anytype) @TypeOf(_fputwc_nolock(_c, _stm)) {
    _ = &_c;
    _ = &_stm;
    return _fputwc_nolock(_c, _stm);
}
pub inline fn _getwc_nolock(_c: anytype) @TypeOf(_fgetwc_nolock(_c)) {
    _ = &_c;
    return _fgetwc_nolock(_c);
}
pub const _STDIO_DEFINED = "";
pub inline fn _getchar_nolock() @TypeOf(_getc_nolock(stdin)) {
    return _getc_nolock(stdin);
}
pub inline fn _putchar_nolock(_c: anytype) @TypeOf(_putc_nolock(_c, stdout)) {
    _ = &_c;
    return _putc_nolock(_c, stdout);
}
pub inline fn _getwchar_nolock() @TypeOf(_getwc_nolock(stdin)) {
    return _getwc_nolock(stdin);
}
pub inline fn _putwchar_nolock(_c: anytype) @TypeOf(_putwc_nolock(_c, stdout)) {
    _ = &_c;
    return _putwc_nolock(_c, stdout);
}
pub const P_tmpdir = _P_tmpdir;
pub const SYS_OPEN = _SYS_OPEN;
pub const __MINGW_MBWC_CONVERT_DEFINED = "";
pub const _INC_STDIO_S = "";
pub const _STDIO_S_DEFINED = "";
pub const L_tmpnam_s = L_tmpnam;
pub const TMP_MAX_S = TMP_MAX;
pub const _WSTDIO_S_DEFINED = "";
pub const _INC_STDLIB = "";
pub const _INC_CORECRT_WSTDLIB = "";
pub const __CLANG_LIMITS_H = "";
pub const _GCC_LIMITS_H_ = "";
pub const _INC_LIMITS = "";
pub const PATH_MAX = @as(c_int, 260);
pub const CHAR_BIT = @as(c_int, 8);
pub const SCHAR_MIN = -@as(c_int, 128);
pub const SCHAR_MAX = @as(c_int, 127);
pub const UCHAR_MAX = @as(c_int, 0xff);
pub const CHAR_MIN = SCHAR_MIN;
pub const CHAR_MAX = SCHAR_MAX;
pub const MB_LEN_MAX = @as(c_int, 5);
pub const SHRT_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 32768, .decimal);
pub const SHRT_MAX = @as(c_int, 32767);
pub const USHRT_MAX = @as(c_uint, 0xffff);
pub const INT_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal) - @as(c_int, 1);
pub const INT_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const UINT_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0xffffffff, .hex);
pub const LONG_MIN = -@as(c_long, 2147483647) - @as(c_int, 1);
pub const LONG_MAX = @as(c_long, 2147483647);
pub const ULONG_MAX = @as(c_ulong, 0xffffffff);
pub const LLONG_MAX = @as(c_longlong, 9223372036854775807);
pub const LLONG_MIN = -@as(c_longlong, 9223372036854775807) - @as(c_int, 1);
pub const ULLONG_MAX = @as(c_ulonglong, 0xffffffffffffffff);
pub const _I8_MIN = -@as(c_int, 127) - @as(c_int, 1);
pub const _I8_MAX = @as(c_int, 127);
pub const _UI8_MAX = @as(c_uint, 0xff);
pub const _I16_MIN = -@as(c_int, 32767) - @as(c_int, 1);
pub const _I16_MAX = @as(c_int, 32767);
pub const _UI16_MAX = @as(c_uint, 0xffff);
pub const _I32_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal) - @as(c_int, 1);
pub const _I32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const _UI32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0xffffffff, .hex);
pub const LONG_LONG_MAX = @as(c_longlong, 9223372036854775807);
pub const LONG_LONG_MIN = -LONG_LONG_MAX - @as(c_int, 1);
pub const ULONG_LONG_MAX = (@as(c_ulonglong, 2) * LONG_LONG_MAX) + @as(c_ulonglong, 1);
pub const _I64_MIN = -@as(c_longlong, 9223372036854775807) - @as(c_int, 1);
pub const _I64_MAX = @as(c_longlong, 9223372036854775807);
pub const _UI64_MAX = @as(c_ulonglong, 0xffffffffffffffff);
pub const SIZE_MAX = _UI64_MAX;
pub const SSIZE_MAX = _I64_MAX;
pub const EXIT_SUCCESS = @as(c_int, 0);
pub const EXIT_FAILURE = @as(c_int, 1);
pub const _ONEXIT_T_DEFINED = "";
pub const onexit_t = _onexit_t;
pub const _DIV_T_DEFINED = "";
pub const _CRT_DOUBLE_DEC = "";
pub inline fn _PTR_LD(x: anytype) [*c]u8 {
    _ = &x;
    return @import("std").zig.c_translation.cast([*c]u8, &x.*.ld);
}
pub const RAND_MAX = @as(c_int, 0x7fff);
pub const MB_CUR_MAX = ___mb_cur_max_func();
pub const __mb_cur_max = ___mb_cur_max_func();
pub inline fn __max(a: anytype, b: anytype) @TypeOf(if (a > b) a else b) {
    _ = &a;
    _ = &b;
    return if (a > b) a else b;
}
pub inline fn __min(a: anytype, b: anytype) @TypeOf(if (a < b) a else b) {
    _ = &a;
    _ = &b;
    return if (a < b) a else b;
}
pub const _MAX_PATH = @as(c_int, 260);
pub const _MAX_DRIVE = @as(c_int, 3);
pub const _MAX_DIR = @as(c_int, 256);
pub const _MAX_FNAME = @as(c_int, 256);
pub const _MAX_EXT = @as(c_int, 256);
pub const _OUT_TO_DEFAULT = @as(c_int, 0);
pub const _OUT_TO_STDERR = @as(c_int, 1);
pub const _OUT_TO_MSGBOX = @as(c_int, 2);
pub const _REPORT_ERRMODE = @as(c_int, 3);
pub const _WRITE_ABORT_MSG = @as(c_int, 0x1);
pub const _CALL_REPORTFAULT = @as(c_int, 0x2);
pub const _MAX_ENV = @as(c_int, 32767);
pub const _CRT_ERRNO_DEFINED = "";
pub const errno = _errno().*;
pub const _doserrno = __doserrno().*;
pub const _sys_nerr = __sys_nerr().*;
pub const _sys_errlist = __sys_errlist();
pub const _fmode = __p__fmode().*;
pub const __argc = __p___argc().*;
pub const __argv = __p___argv().*;
pub const __wargv = __p___wargv().*;
pub const _environ = __p__environ().*;
pub const _wenviron = __p__wenviron().*;
pub const _pgmptr = __p__pgmptr().*;
pub const _wpgmptr = __p__wpgmptr().*;
pub const _countof = @compileError("unable to translate C expr: expected ')' instead got '['");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/stdlib.h:377:9
pub const _CRT_ABS_DEFINED = "";
pub const _CRT_ATOF_DEFINED = "";
pub const _CRT_ALGO_DEFINED = "";
pub const _CRT_ALLOCATION_DEFINED = "";
pub const _WSTDLIB_DEFINED = "";
pub const _CVTBUFSIZE = @as(c_int, 309) + @as(c_int, 40);
pub const _WSTDLIBP_DEFINED = "";
pub const sys_errlist = _sys_errlist;
pub const sys_nerr = _sys_nerr;
pub const environ = _environ;
pub const _INC_STDLIB_S = "";
pub const _QSORT_S_DEFINED = "";
pub const _MALLOC_H_ = "";
pub const _HEAP_MAXREQ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFFFFFFFFFFFFFFE0, .hex);
pub const _STATIC_ASSERT = @compileError("unable to translate macro: undefined identifier `__static_assert_t`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/malloc.h:27:9
pub const _HEAPEMPTY = -@as(c_int, 1);
pub const _HEAPOK = -@as(c_int, 2);
pub const _HEAPBADBEGIN = -@as(c_int, 3);
pub const _HEAPBADNODE = -@as(c_int, 4);
pub const _HEAPEND = -@as(c_int, 5);
pub const _HEAPBADPTR = -@as(c_int, 6);
pub const _FREEENTRY = @as(c_int, 0);
pub const _USEDENTRY = @as(c_int, 1);
pub const _HEAPINFO_DEFINED = "";
pub const __MM_MALLOC_H = "";
pub const _MAX_WAIT_MALLOC_CRT = @import("std").zig.c_translation.promoteIntLiteral(c_int, 60000, .decimal);
pub const _alloca = @compileError("unable to translate macro: undefined identifier `__builtin_alloca`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/malloc.h:98:9
pub const _ALLOCA_S_THRESHOLD = @as(c_int, 1024);
pub const _ALLOCA_S_STACK_MARKER = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xCCCC, .hex);
pub const _ALLOCA_S_HEAP_MARKER = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xDDDD, .hex);
pub const _ALLOCA_S_MARKER_SIZE = @as(c_int, 16);
pub inline fn _malloca(size: anytype) @TypeOf(if ((size + _ALLOCA_S_MARKER_SIZE) <= _ALLOCA_S_THRESHOLD) _MarkAllocaS(_alloca(size + _ALLOCA_S_MARKER_SIZE), _ALLOCA_S_STACK_MARKER) else _MarkAllocaS(malloc(size + _ALLOCA_S_MARKER_SIZE), _ALLOCA_S_HEAP_MARKER)) {
    _ = &size;
    return if ((size + _ALLOCA_S_MARKER_SIZE) <= _ALLOCA_S_THRESHOLD) _MarkAllocaS(_alloca(size + _ALLOCA_S_MARKER_SIZE), _ALLOCA_S_STACK_MARKER) else _MarkAllocaS(malloc(size + _ALLOCA_S_MARKER_SIZE), _ALLOCA_S_HEAP_MARKER);
}
pub const _FREEA_INLINE = "";
pub const alloca = @compileError("unable to translate macro: undefined identifier `__builtin_alloca`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/malloc.h:164:9
pub const H_NAR = "";
pub const H_CYCLE = "";
pub const H_GLOBALS = "";
pub const _INC_CTYPE = "";
pub const _CRT_CTYPEDATA_DEFINED = "";
pub const __PCTYPE_FUNC = __pctype_func();
pub const _pctype = __pctype_func();
pub const _CRT_WCTYPEDATA_DEFINED = "";
pub const _wctype = __MINGW_IMP_SYMBOL(_wctype).*;
pub inline fn __pwctype_func() @TypeOf(__MINGW_IMP_SYMBOL(_pwctype).*) {
    return __MINGW_IMP_SYMBOL(_pwctype).*;
}
pub const _pwctype = __MINGW_IMP_SYMBOL(_pwctype).*;
pub const _UPPER = @as(c_int, 0x1);
pub const _LOWER = @as(c_int, 0x2);
pub const _DIGIT = @as(c_int, 0x4);
pub const _SPACE = @as(c_int, 0x8);
pub const _PUNCT = @as(c_int, 0x10);
pub const _CONTROL = @as(c_int, 0x20);
pub const _BLANK = @as(c_int, 0x40);
pub const _HEX = @as(c_int, 0x80);
pub const _LEADBYTE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const _ALPHA = (@as(c_int, 0x0100) | _UPPER) | _LOWER;
pub const _CTYPE_DEFINED = "";
pub const _WCTYPE_DEFINED = "";
pub inline fn __chvalidchk(a: anytype, b: anytype) @TypeOf(__PCTYPE_FUNC[@as(usize, @intCast(@import("std").zig.c_translation.cast(u8, a)))] & b) {
    _ = &a;
    _ = &b;
    return __PCTYPE_FUNC[@as(usize, @intCast(@import("std").zig.c_translation.cast(u8, a)))] & b;
}
pub inline fn _chvalidchk_l(_Char: anytype, _Flag: anytype, _Locale: anytype) @TypeOf(if (!(_Locale != 0)) __chvalidchk(_Char, _Flag) else @import("std").zig.c_translation.cast(_locale_t, _Locale).*.locinfo.*._locale_pctype[@as(usize, @intCast(@import("std").zig.c_translation.cast(u8, _Char)))] & _Flag) {
    _ = &_Char;
    _ = &_Flag;
    _ = &_Locale;
    return if (!(_Locale != 0)) __chvalidchk(_Char, _Flag) else @import("std").zig.c_translation.cast(_locale_t, _Locale).*.locinfo.*._locale_pctype[@as(usize, @intCast(@import("std").zig.c_translation.cast(u8, _Char)))] & _Flag;
}
pub inline fn _ischartype_l(_Char: anytype, _Flag: anytype, _Locale: anytype) @TypeOf(if ((_Locale != NULL) and (@import("std").zig.c_translation.cast(_locale_t, _Locale).*.locinfo.*._locale_mb_cur_max > @as(c_int, 1))) _isctype_l(_Char, _Flag, _Locale) else _chvalidchk_l(_Char, _Flag, _Locale)) {
    _ = &_Char;
    _ = &_Flag;
    _ = &_Locale;
    return if ((_Locale != NULL) and (@import("std").zig.c_translation.cast(_locale_t, _Locale).*.locinfo.*._locale_mb_cur_max > @as(c_int, 1))) _isctype_l(_Char, _Flag, _Locale) else _chvalidchk_l(_Char, _Flag, _Locale);
}
pub const _WCTYPE_INLINE_DEFINED = "";
pub inline fn _iscsymf_l(_c: anytype, _p: anytype) @TypeOf((_isalpha_l(_c, _p) != 0) or (_c == '_')) {
    _ = &_c;
    _ = &_p;
    return (_isalpha_l(_c, _p) != 0) or (_c == '_');
}
pub inline fn _iscsym_l(_c: anytype, _p: anytype) @TypeOf((_isalnum_l(_c, _p) != 0) or (_c == '_')) {
    _ = &_c;
    _ = &_p;
    return (_isalnum_l(_c, _p) != 0) or (_c == '_');
}
pub const isascii = __isascii;
pub const toascii = __toascii;
pub const iscsymf = __iscsymf;
pub const iscsym = __iscsym;
pub const DEBUG = @"false";
pub const EXIT_STATS = @"true";
pub const PRINT_INPUT_INITIAL = @"true";
pub const PRINT_DERIVATIONS_INITIAL = @"false";
pub const PRINT_CONTROL_INFO = @"false";
pub const PRINT_SURPRISE = @"false";
pub const PRINT_EVENTS_PRIORITY_THRESHOLD_INITIAL = @as(f64, 0.0);
pub const IN_DEBUG = @compileError("unable to translate C expr: unexpected token '{'");
// src/Globals.h:56:9
pub const assert = Globals_assert;
pub inline fn MIN(a: anytype, b: anytype) @TypeOf(if (a < b) a else b) {
    _ = &a;
    _ = &b;
    return if (a < b) a else b;
}
pub inline fn MAX(a: anytype, b: anytype) @TypeOf(if (a > b) a else b) {
    _ = &a;
    _ = &b;
    return if (a > b) a else b;
}
pub const NUM_ELEMENTS = @compileError("unable to translate C expr: expected ')' instead got '['");
// src/Globals.h:63:9
pub const HASH_TYPE = c_long;
pub const MY_RAND_MAX = @as(c_int, 32767);
pub const STR_HELPER = @compileError("unable to translate C expr: unexpected token '#'");
// src/Globals.h:72:9
pub inline fn STR(x: anytype) @TypeOf(STR_HELPER(x)) {
    _ = &x;
    return STR_HELPER(x);
}
pub const H_DECISION = "";
pub const H_MEMORY = "";
pub const _MATH_H_ = "";
pub const _DOMAIN = @as(c_int, 1);
pub const _SING = @as(c_int, 2);
pub const _OVERFLOW = @as(c_int, 3);
pub const _UNDERFLOW = @as(c_int, 4);
pub const _TLOSS = @as(c_int, 5);
pub const _PLOSS = @as(c_int, 6);
pub const DOMAIN = _DOMAIN;
pub const SING = _SING;
pub const OVERFLOW = _OVERFLOW;
pub const UNDERFLOW = _UNDERFLOW;
pub const TLOSS = _TLOSS;
pub const PLOSS = _PLOSS;
pub const M_E = @as(f64, 2.7182818284590452354);
pub const M_LOG2E = @as(f64, 1.4426950408889634074);
pub const M_LOG10E = @as(f64, 0.43429448190325182765);
pub const M_LN2 = @as(f64, 0.69314718055994530942);
pub const M_LN10 = @as(f64, 2.30258509299404568402);
pub const M_PI = @as(f64, 3.14159265358979323846);
pub const M_PI_2 = @as(f64, 1.57079632679489661923);
pub const M_PI_4 = @as(f64, 0.78539816339744830962);
pub const M_1_PI = @as(f64, 0.31830988618379067154);
pub const M_2_PI = @as(f64, 0.63661977236758134308);
pub const M_2_SQRTPI = @as(f64, 1.12837916709551257390);
pub const M_SQRT2 = @as(f64, 1.41421356237309504880);
pub const M_SQRT1_2 = @as(f64, 0.70710678118654752440);
pub const __MINGW_FPCLASS_DEFINED = @as(c_int, 1);
pub const _FPCLASS_SNAN = @as(c_int, 0x0001);
pub const _FPCLASS_QNAN = @as(c_int, 0x0002);
pub const _FPCLASS_NINF = @as(c_int, 0x0004);
pub const _FPCLASS_NN = @as(c_int, 0x0008);
pub const _FPCLASS_ND = @as(c_int, 0x0010);
pub const _FPCLASS_NZ = @as(c_int, 0x0020);
pub const _FPCLASS_PZ = @as(c_int, 0x0040);
pub const _FPCLASS_PD = @as(c_int, 0x0080);
pub const _FPCLASS_PN = @as(c_int, 0x0100);
pub const _FPCLASS_PINF = @as(c_int, 0x0200);
pub const __mingw_types_compatible_p = @compileError("unable to translate C expr: unexpected token 'an identifier'");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/math.h:97:9
pub const __mingw_choose_expr = @compileError("unable to translate C expr: unexpected token 'an identifier'");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/math.h:105:9
pub const __MINGW_SOFTMATH = "";
pub const HUGE_VAL = @compileError("unable to translate macro: undefined identifier `__builtin_huge_val`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/math.h:156:9
pub const _EXCEPTION_DEFINED = "";
pub const EDOM = @as(c_int, 33);
pub const ERANGE = @as(c_int, 34);
pub const _COMPLEX_DEFINED = "";
pub const _CRT_MATHERR_DEFINED = "";
pub const _SIGN_DEFINED = "";
pub const FP_SNAN = _FPCLASS_SNAN;
pub const FP_QNAN = _FPCLASS_QNAN;
pub const FP_NINF = _FPCLASS_NINF;
pub const FP_PINF = _FPCLASS_PINF;
pub const FP_NDENORM = _FPCLASS_ND;
pub const FP_PDENORM = _FPCLASS_PD;
pub const FP_NZERO = _FPCLASS_NZ;
pub const FP_PZERO = _FPCLASS_PZ;
pub const FP_NNORM = _FPCLASS_NN;
pub const FP_PNORM = _FPCLASS_PN;
pub const HUGE_VALF = __builtin_huge_valf();
pub const HUGE_VALL = @compileError("unable to translate macro: undefined identifier `__builtin_huge_vall`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/math.h:350:9
pub const INFINITY = __builtin_inff();
pub const NAN = __builtin_nanf("");
pub const FP_NAN = @as(c_int, 0x0100);
pub const FP_NORMAL = @as(c_int, 0x0400);
pub const FP_INFINITE = FP_NAN | FP_NORMAL;
pub const FP_ZERO = @as(c_int, 0x4000);
pub const FP_SUBNORMAL = FP_NORMAL | FP_ZERO;
pub inline fn __dfp_expansion(__call: anytype, __fin: anytype, x: anytype) @TypeOf(__fin) {
    _ = &__call;
    _ = &__fin;
    _ = &x;
    return __fin;
}
pub const fpclassify = @compileError("unable to translate macro: undefined identifier `__builtin_trap`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/math.h:492:9
pub inline fn isfinite(x: anytype) @TypeOf((fpclassify(x) & FP_NAN) == @as(c_int, 0)) {
    _ = &x;
    return (fpclassify(x) & FP_NAN) == @as(c_int, 0);
}
pub inline fn isinf(x: anytype) @TypeOf(fpclassify(x) == FP_INFINITE) {
    _ = &x;
    return fpclassify(x) == FP_INFINITE;
}
pub const isnan = @compileError("unable to translate macro: undefined identifier `__builtin_trap`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/math.h:586:9
pub inline fn isnormal(x: anytype) @TypeOf(fpclassify(x) == FP_NORMAL) {
    _ = &x;
    return fpclassify(x) == FP_NORMAL;
}
pub const signbit = @compileError("unable to translate macro: undefined identifier `__builtin_trap`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/math.h:646:9
pub const FP_ILOGB0 = @import("std").zig.c_translation.cast(c_int, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hex));
pub const FP_ILOGBNAN = @import("std").zig.c_translation.cast(c_int, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x7fffffff, .hex));
pub inline fn _nan() @TypeOf(nan("")) {
    return nan("");
}
pub inline fn _nanf() @TypeOf(nanf("")) {
    return nanf("");
}
pub inline fn _nanl() @TypeOf(nanl("")) {
    return nanl("");
}
pub const isgreater = @compileError("unable to translate macro: undefined identifier `__builtin_isgreater`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/math.h:1144:9
pub const isgreaterequal = @compileError("unable to translate macro: undefined identifier `__builtin_isgreaterequal`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/math.h:1145:9
pub const isless = @compileError("unable to translate macro: undefined identifier `__builtin_isless`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/math.h:1146:9
pub const islessequal = @compileError("unable to translate macro: undefined identifier `__builtin_islessequal`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/math.h:1147:9
pub const islessgreater = @compileError("unable to translate macro: undefined identifier `__builtin_islessgreater`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/math.h:1148:9
pub const isunordered = @compileError("unable to translate macro: undefined identifier `__builtin_isunordered`");
// C:\Users\56506\AppData\Roaming\Code\User\globalStorage\ziglang.vscode-zig\zig_install\lib\libc\include\any-windows-any/math.h:1149:9
pub const _copysignl = copysignl;
pub const _hypotl = hypotl;
pub const matherr = _matherr;
pub const HUGE = _HUGE;
pub const H_CONCEPT = "";
pub const H_TABLE = "";
pub const H_INFERENCE = "";
pub const EVENT_H = "";
pub const H_TERM = "";
pub const __CLANG_STDINT_H = "";
pub const _STDINT_H = "";
pub const __need_wint_t = "";
pub const __need_wchar_t = "";
pub const _WCHAR_T = "";
pub const INT8_MIN = -@as(c_int, 128);
pub const INT16_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 32768, .decimal);
pub const INT32_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal) - @as(c_int, 1);
pub const INT64_MIN = -@as(c_longlong, 9223372036854775807) - @as(c_int, 1);
pub const INT8_MAX = @as(c_int, 127);
pub const INT16_MAX = @as(c_int, 32767);
pub const INT32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const INT64_MAX = @as(c_longlong, 9223372036854775807);
pub const UINT8_MAX = @as(c_int, 255);
pub const UINT16_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const UINT32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0xffffffff, .hex);
pub const UINT64_MAX = @as(c_ulonglong, 0xffffffffffffffff);
pub const INT_LEAST8_MIN = INT8_MIN;
pub const INT_LEAST16_MIN = INT16_MIN;
pub const INT_LEAST32_MIN = INT32_MIN;
pub const INT_LEAST64_MIN = INT64_MIN;
pub const INT_LEAST8_MAX = INT8_MAX;
pub const INT_LEAST16_MAX = INT16_MAX;
pub const INT_LEAST32_MAX = INT32_MAX;
pub const INT_LEAST64_MAX = INT64_MAX;
pub const UINT_LEAST8_MAX = UINT8_MAX;
pub const UINT_LEAST16_MAX = UINT16_MAX;
pub const UINT_LEAST32_MAX = UINT32_MAX;
pub const UINT_LEAST64_MAX = UINT64_MAX;
pub const INT_FAST8_MIN = INT8_MIN;
pub const INT_FAST16_MIN = INT16_MIN;
pub const INT_FAST32_MIN = INT32_MIN;
pub const INT_FAST64_MIN = INT64_MIN;
pub const INT_FAST8_MAX = INT8_MAX;
pub const INT_FAST16_MAX = INT16_MAX;
pub const INT_FAST32_MAX = INT32_MAX;
pub const INT_FAST64_MAX = INT64_MAX;
pub const UINT_FAST8_MAX = UINT8_MAX;
pub const UINT_FAST16_MAX = UINT16_MAX;
pub const UINT_FAST32_MAX = UINT32_MAX;
pub const UINT_FAST64_MAX = UINT64_MAX;
pub const INTPTR_MIN = INT64_MIN;
pub const INTPTR_MAX = INT64_MAX;
pub const UINTPTR_MAX = UINT64_MAX;
pub const INTMAX_MIN = INT64_MIN;
pub const INTMAX_MAX = INT64_MAX;
pub const UINTMAX_MAX = UINT64_MAX;
pub const PTRDIFF_MIN = INT64_MIN;
pub const PTRDIFF_MAX = INT64_MAX;
pub const SIG_ATOMIC_MIN = INT32_MIN;
pub const SIG_ATOMIC_MAX = INT32_MAX;
pub const WCHAR_MIN = @as(c_uint, 0);
pub const WCHAR_MAX = @as(c_uint, 0xffff);
pub const WINT_MIN = @as(c_uint, 0);
pub const WINT_MAX = @as(c_uint, 0xffff);
pub inline fn INT8_C(val: anytype) @TypeOf((INT_LEAST8_MAX - INT_LEAST8_MAX) + val) {
    _ = &val;
    return (INT_LEAST8_MAX - INT_LEAST8_MAX) + val;
}
pub inline fn INT16_C(val: anytype) @TypeOf((INT_LEAST16_MAX - INT_LEAST16_MAX) + val) {
    _ = &val;
    return (INT_LEAST16_MAX - INT_LEAST16_MAX) + val;
}
pub inline fn INT32_C(val: anytype) @TypeOf((INT_LEAST32_MAX - INT_LEAST32_MAX) + val) {
    _ = &val;
    return (INT_LEAST32_MAX - INT_LEAST32_MAX) + val;
}
pub const INT64_C = @import("std").zig.c_translation.Macros.LL_SUFFIX;
pub inline fn UINT8_C(val: anytype) @TypeOf(val) {
    _ = &val;
    return val;
}
pub inline fn UINT16_C(val: anytype) @TypeOf(val) {
    _ = &val;
    return val;
}
pub const UINT32_C = @import("std").zig.c_translation.Macros.U_SUFFIX;
pub const UINT64_C = @import("std").zig.c_translation.Macros.ULL_SUFFIX;
pub const INTMAX_C = @import("std").zig.c_translation.Macros.LL_SUFFIX;
pub const UINTMAX_C = @import("std").zig.c_translation.Macros.ULL_SUFFIX;
pub const H_TRUTH = "";
pub const H_CONFIG = "";
pub const ANTICIPATION_THRESHOLD_INITIAL = @as(f64, 0.501);
pub const ANTICIPATION_CONFIDENCE_INITIAL = @as(f64, 0.01);
pub const ANTICIPATE_FOR_NOT_EXISTING_SPECIFIC_TEMPORAL_IMPLICATION = @"true";
pub const CONDITION_THRESHOLD_INITIAL = @as(f64, 0.501);
pub const DECISION_THRESHOLD_INITIAL = @as(f64, 0.501);
pub const MOTOR_BABBLING_CHANCE_INITIAL = @as(f64, 0.2);
pub const MOTOR_BABBLING_SUPPRESSION_THRESHOLD = @as(f64, 0.55);
pub const NOP_SUBGOALING = @"true";
pub const SUBSUMPTION_CONFIDENCE_THRESHOLD = @as(f64, 0.05);
pub const SUBSUMPTION_FREQUENCY_THRESHOLD = @as(f64, 0.5);
pub const NEG_GOAL_AGE_MAX = EVENT_BELIEF_DISTANCE;
pub const BELIEF_EVENT_SELECTIONS = @as(c_int, 1);
pub const GOAL_EVENT_SELECTIONS = @as(c_int, 1);
pub const EVENT_DURABILITY = @as(f64, 0.9999);
pub const CONCEPT_DURABILITY = @as(f64, 0.9);
pub const MIN_PRIORITY = @as(c_int, 0);
pub const EVENT_BELIEF_DISTANCE = @as(c_int, 20);
pub const BELIEF_CONCEPT_MATCH_TARGET = @as(c_int, 80);
pub const CONCEPT_THRESHOLD_ADAPTATION = @as(f64, 0.000001);
pub const ETERNAL_INPUT_USAGE_BOOST = @import("std").zig.c_translation.promoteIntLiteral(c_int, 1000000, .decimal);
pub const QUESTION_PRIMING_INITIAL = @as(f64, 0.1);
pub const UNIFICATION_DEPTH = @as(c_int, 31);
pub const ALLOW_VAR_INTRO = @"true";
pub const SIMILARITY_DISTANCE = @as(f64, 1.0);
pub const MAX_SEQUENCE_LEN = @as(c_int, 2);
pub const MAX_COMPOUND_OP_LEN = @as(c_int, 1);
pub const PRECONDITION_CONSEQUENCE_DISTANCE = EVENT_BELIEF_DISTANCE;
pub const CORRELATE_OUTCOME_RECENCY = EVENT_BELIEF_DISTANCE;
pub const MAX_SEQUENCE_TIMEDIFF = EVENT_BELIEF_DISTANCE;
pub const ALLOW_NOT_SELECTED_PRECONDITIONS_CONDITIONING = @"false";
pub const CONCEPTS_MAX = @as(c_int, 16384);
pub const CONCEPTS_HASHTABLE_BUCKETS = CONCEPTS_MAX;
pub const CYCLING_BELIEF_EVENTS_MAX = @as(c_int, 40);
pub const CYCLING_GOAL_EVENTS_MAX = @as(c_int, 400);
pub const OPERATIONS_MAX = @as(c_int, 10);
pub const OPERATIONS_BABBLE_ARGS_MAX = @as(c_int, 10);
pub const STAMP_SIZE = @as(c_int, 10);
pub const TABLE_SIZE = @as(c_int, 20);
pub const COMPOUND_TERM_SIZE_MAX = @as(c_int, 64);
pub const ATOMS_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65536, .decimal);
pub const ATOMS_HASHTABLE_BUCKETS = ATOMS_MAX;
pub const Atom = c_ushort;
pub const ATOMIC_TERM_LEN_MAX = @as(c_int, 32);
pub const NARSESE_LEN_MAX = @as(c_int, 2148);
pub const CYCLING_GOAL_EVENTS_LAYERS = @as(c_int, 30);
pub const VAR_INTRO_HASHTABLE_BUCKETS = COMPOUND_TERM_SIZE_MAX;
pub const OCCURRENCE_TIME_INDEX_SIZE = @as(c_int, 512);
pub const NAR_DEFAULT_FREQUENCY = @as(f64, 1.0);
pub const NAR_DEFAULT_CONFIDENCE = @as(f64, 0.9);
pub const RELIANCE = @as(f64, 0.9);
pub const TRUTH_EVIDENTAL_HORIZON_INITIAL = @as(f64, 1.0);
pub const TRUTH_PROJECTION_DECAY_INITIAL = @as(f64, 0.8);
pub const MAX_CONFIDENCE = @as(f64, 0.99);
pub const MIN_CONFIDENCE = @as(f64, 0.01);
pub const SEMANTIC_INFERENCE_NAL_LEVEL = @as(c_int, 6);
pub const ATOM_APPEARS_TWICE_FILTER = @"true";
pub const NESTED_HOL_STATEMENT_FILTER = @"true";
pub const INH_OR_SIM_HAS_DEP_VAR_FILTER = @"true";
pub const HOL_STATEMENT_COMPONENT_HAS_INVALID_INH_OR_SIM_FILTER = @"true";
pub const HOL_COMPONENT_NO_VAR_IS_INVALID_FILTER = @"true";
pub const HOL_COMPONENT_NO_ATOMIC_IS_INVALID_FILTER = @"true";
pub const JUNCTION_NOT_RIGHT_NESTED_FILTER = @"true";
pub const VARS_IN_MULTI_ELEMENT_SETS_FILTER = @"true";
pub const TERMS_WITH_VARS_AND_ATOMS_FILTER = @"true";
pub const FUNCTIONAL_EQUIVALENCE = @"true";
pub const OCCURRENCE_ETERNAL = -@as(c_int, 1);
pub const STRUCTURAL_TRUTH = @import("std").mem.zeroInit(Truth, .{
    .frequency = @as(f64, 1.0),
    .confidence = RELIANCE,
});
pub const HASH_TYPE_SIZE = @import("std").zig.c_translation.sizeof(HASH_TYPE);
pub const TERM_ATOMS_SIZE = @import("std").zig.c_translation.sizeof(Atom) * COMPOUND_TERM_SIZE_MAX;
pub const H_STAMP = "";
pub const STAMP_FREE = @as(c_int, 0);
pub const EVENT_TYPE_GOAL = @as(c_int, 1);
pub const EVENT_TYPE_BELIEF = @as(c_int, 2);
pub const EVENT_TYPE_DELETED = @as(c_int, 0);
pub const H_NARSESE = "";
pub const Narsese_RuleTableVars = "ABCMRSPXYZ";
pub const Naresese_CanonicalCopulas = "@*&|;:=$'\"/\\.-%#~+!?^_,";
pub const PRODUCT = '*';
pub const EXT_INTERSECTION = '&';
pub const INT_INTERSECTION = '|';
pub const CONJUNCTION = ';';
pub const INHERITANCE = ':';
pub const SIMILARITY = '=';
pub const TEMPORAL_IMPLICATION = '$';
pub const INT_SET = '\'';
pub const EXT_SET = '"';
pub const EXT_IMAGE1 = '/';
pub const INT_IMAGE1 = '\\';
pub const SET_ELEMT = '.';
pub const EXT_DIFFERENCE = '-';
pub const EXT_IMAGE2 = '%';
pub const INT_IMAGE2 = '#';
pub const INT_DIFFERENCE = '~';
pub const SEQUENCE = '+';
pub const NEGATION = '!';
pub const IMPLICATION = '?';
pub const EQUIVALENCE = '^';
pub const DISJUNCTION = '_';
pub const HAS_CONTINUOUS_PROPERTY = ',';
pub const SET_TERMINATOR = '@';
pub const H_IMPLICATION = "";
pub const H_VARIABLE = "";
pub const H_USAGE = "";
pub const H_OCCURRENCETIMEINDEX = "";
pub const H_INVERTEDATOMINDEX = "";
pub const H_STACK = "";
pub const H_PRIORITYQUEUE = "";
pub const H_HASHTABLE = "";
pub const H_RULETABLE = "";
pub const H_NAL = "";
pub const R2 = @compileError("unable to translate macro: undefined identifier `NAL_GenerateRule`");
// src/NAL.h:47:9
pub const R2VarIntro = @compileError("unable to translate macro: undefined identifier `NAL_GenerateRule`");
// src/NAL.h:48:9
pub const R1 = @compileError("unable to translate macro: undefined identifier `NAL_GenerateRule`");
// src/NAL.h:50:9
pub const R1Bidirectional = @compileError("unable to translate macro: undefined identifier `NAL_GenerateRule`");
// src/NAL.h:52:9
pub const ReduceTerm = @compileError("unable to translate macro: undefined identifier `NAL_GenerateReduction`");
// src/NAL.h:54:9
pub const ReduceStatement = @compileError("unable to translate macro: undefined identifier `NAL_GenerateReduction`");
// src/NAL.h:56:9
pub const H_STATS = "";
pub const NAR_DEFAULT_TRUTH = @import("std").mem.zeroInit(Truth, .{
    .frequency = NAR_DEFAULT_FREQUENCY,
    .confidence = NAR_DEFAULT_CONFIDENCE,
});
pub const STACK_TEST_STRUCTURE_SIZE = @as(c_int, 5);
pub const HASHTABLE_TEST_STRUCTURE_SIZE = @as(c_int, 10);
pub const CLEAR_SCREEN = @compileError("unable to translate C expr: unexpected token 'do'");
// src/./system_tests/system_tests.h:52:9
pub const SLEEP = "";
pub const DIRECTION_RIGHT = '>';
pub const DIRECTION_RIGHT_DOWN = 'd';
pub const DIRECTION_DOWN = '^';
pub const DIRECTION_LEFT_DOWN = 'b';
pub const DIRECTION_LEFT = '<';
pub const DIRECTION_LEFT_UP = 'p';
pub const DIRECTION_UP = 'v';
pub const DIRECTION_RIGHT_UP = 'q';
pub const worldsizeX = @as(c_int, 41);
pub const worldsizeY = @as(c_int, 21);
pub const BREAK_ON_DONE = @compileError("unable to translate macro: undefined identifier `ret`");
// src/./system_tests/Robot_Test.h:238:9
pub const H_SHELL = "";
pub const SHELL_CONTINUE = @as(c_int, 0);
pub const SHELL_RESET = @as(c_int, 1);
pub const SHELL_EXIT = @as(c_int, 2);
pub const threadlocaleinfostruct = struct_threadlocaleinfostruct;
pub const threadmbcinfostruct = struct_threadmbcinfostruct;
pub const __lc_time_data = struct___lc_time_data;
pub const localeinfo_struct = struct_localeinfo_struct;
pub const tagLC_ID = struct_tagLC_ID;
pub const __timeb32 = struct___timeb32;
pub const timeb = struct_timeb;
pub const __timeb64 = struct___timeb64;
pub const _timespec32 = struct__timespec32;
pub const _timespec64 = struct__timespec64;
pub const timespec = struct_timespec;
pub const itimerspec = struct_itimerspec;
pub const tm = struct_tm;
pub const timeval = struct_timeval;
pub const _finddata32_t = struct__finddata32_t;
pub const _finddata32i64_t = struct__finddata32i64_t;
pub const _finddata64i32_t = struct__finddata64i32_t;
pub const __finddata64_t = struct___finddata64_t;
pub const _wfinddata32_t = struct__wfinddata32_t;
pub const _wfinddata32i64_t = struct__wfinddata32i64_t;
pub const _wfinddata64i32_t = struct__wfinddata64i32_t;
pub const _wfinddata64_t = struct__wfinddata64_t;
pub const _iobuf = struct__iobuf;
pub const _div_t = struct__div_t;
pub const _ldiv_t = struct__ldiv_t;
pub const _heapinfo = struct__heapinfo;
pub const _exception = struct__exception;
pub const _complex = struct__complex;
